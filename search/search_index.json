{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83c\udf33 Dendron Dendron is a library for building applications using behavior trees and large language models. For installation instructions click here . For a tutorial overview of the library, click here . In the tutorial, you will use Dendron to build a chat system that: Performs speech recognition from a microphone using a transformer-based ASR model. Handles chat template formatting for a quantized LLM. Generates speech from text using a transformed-based TTS model. Intelligently chunks the chat output using rule-based AI to prevent overwhelming the TTS model. Uses another language model to classify user input to determine when it is socially appropriate for the language model to end the conversation. The resulting behavior tree uses LLMs in 5 different ways, but can still be run on a single RTX 3090 . For an API overview, see the menu above.","title":"Home"},{"location":"#dendron","text":"Dendron is a library for building applications using behavior trees and large language models. For installation instructions click here . For a tutorial overview of the library, click here . In the tutorial, you will use Dendron to build a chat system that: Performs speech recognition from a microphone using a transformer-based ASR model. Handles chat template formatting for a quantized LLM. Generates speech from text using a transformed-based TTS model. Intelligently chunks the chat output using rule-based AI to prevent overwhelming the TTS model. Uses another language model to classify user input to determine when it is socially appropriate for the language model to end the conversation. The resulting behavior tree uses LLMs in 5 different ways, but can still be run on a single RTX 3090 . For an API overview, see the menu above.","title":"\ud83c\udf33 Dendron"},{"location":"0_tutorial_single_node/","text":"0. Building a Chat System with Dendron: A Single Node","title":"Part 0. A Single Node"},{"location":"0_tutorial_single_node/#0-building-a-chat-system-with-dendron-a-single-node","text":"","title":"0. Building a Chat System with Dendron: A Single Node"},{"location":"1_tutorial_seq/","text":"1. Building a Chat System with Dendron: Thinking and Talking","title":"Part 1. Thinking and Talking"},{"location":"1_tutorial_seq/#1-building-a-chat-system-with-dendron-thinking-and-talking","text":"","title":"1. Building a Chat System with Dendron: Thinking and Talking"},{"location":"2_tutorial_implicit_seq/","text":"2. Building a Chat System with Dendron: Managing Chat State","title":"Part 2. Managing Chat State"},{"location":"2_tutorial_implicit_seq/#2-building-a-chat-system-with-dendron-managing-chat-state","text":"","title":"2. Building a Chat System with Dendron: Managing Chat State"},{"location":"3_tutorial_llm_conditional/","text":"3. Building a Chat System with Dendron: Learning How to Say Goodbye","title":"Part 3. Learning How to Say Goodbye"},{"location":"3_tutorial_llm_conditional/#3-building-a-chat-system-with-dendron-learning-how-to-say-goodbye","text":"","title":"3. Building a Chat System with Dendron: Learning How to Say Goodbye"},{"location":"4_tutorial_tts_asr_chat/","text":"4. Building a Chat System with Dendron: Chat with TTS and ASR","title":"Part 4. Chat with TTS and ASR"},{"location":"4_tutorial_tts_asr_chat/#4-building-a-chat-system-with-dendron-chat-with-tts-and-asr","text":"","title":"4. Building a Chat System with Dendron: Chat with TTS and ASR"},{"location":"install/","text":"Installation Installing dendron should be as easy as running the following pip command: pip install dendron If you want to install from source for testing or contributing, you can activate your development environment, git clone the dendron repository, cd into it, and run pip install -e .","title":"Installation"},{"location":"install/#installation","text":"Installing dendron should be as easy as running the following pip command: pip install dendron If you want to install from source for testing or contributing, you can activate your development environment, git clone the dendron repository, cd into it, and run pip install -e .","title":"Installation"},{"location":"theory/","text":"An Argument for the Necessity of Behavior Trees for LLM Systems We want to use LLMs and VLMs to build complex systems from simpler parts. Every sufficiently powerful formalism for building complex systems out of simpler parts has three mechanisms for achieving that goal: primitive elements, means of combination, and means of abstraction. The behavior tree formalism is no different. In our case, we have All sufficiently powerful formal systems have three common A language model \\ell is a conditional probability distribution: given a sequence of tokens t_1, \\ldots, t_n from a vocabulary V , LMs as CPDs LMs as Context->Context mappings Two issues with ad hoc solutions a. Semantics vs. Syntax: Contexts are syntactic objects b. Compositionality is unclear","title":"Theory"},{"location":"theory/#an-argument-for-the-necessity-of-behavior-trees-for-llm-systems","text":"We want to use LLMs and VLMs to build complex systems from simpler parts. Every sufficiently powerful formalism for building complex systems out of simpler parts has three mechanisms for achieving that goal: primitive elements, means of combination, and means of abstraction. The behavior tree formalism is no different. In our case, we have All sufficiently powerful formal systems have three common A language model \\ell is a conditional probability distribution: given a sequence of tokens t_1, \\ldots, t_n from a vocabulary V , LMs as CPDs LMs as Context->Context mappings Two issues with ad hoc solutions a. Semantics vs. Syntax: Contexts are syntactic objects b. Compositionality is unclear","title":"An Argument for the Necessity of Behavior Trees for LLM Systems"},{"location":"tutorial_intro/","text":"Building a Local Chat Bot with Dendron I'm going to assume that you have installed Dendron into your Python environment. If you haven't yet, check out this link . Once you have the system installed, you can move on to building a behavior tree with a single node .","title":"Introduction - Building a Local Chatbot with ASR and TTS Support"},{"location":"tutorial_intro/#building-a-local-chat-bot-with-dendron","text":"I'm going to assume that you have installed Dendron into your Python environment. If you haven't yet, check out this link . Once you have the system installed, you can move on to building a behavior tree with a single node .","title":"Building a Local Chat Bot with Dendron"},{"location":"api/action_node/","text":"ActionNode Bases: TreeNode An action node encapsulates the notion of a self-contained action or behavior. The bulk of the observable actions of a behavior tree are due to the action nodes. ActionNode s are one of the two kinds of leaf nodes in a Behavior Tree - the other being the ConditionNode . Parameters: Name Type Description Default name `str` The given name of this node. required Source code in src/dendron/action_node.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class ActionNode ( TreeNode ): \"\"\" An action node encapsulates the notion of a self-contained action or behavior. The bulk of the observable actions of a behavior tree are due to the action nodes. `ActionNode`s are one of the two kinds of leaf nodes in a Behavior Tree - the other being the `ConditionNode`. Args: name (`str`): The given name of this node. \"\"\" def __init__ ( self , name ) -> None : super () . __init__ ( name ) def set_logger ( self , new_logger ) -> None : \"\"\" Set the logger for this node. \"\"\" self . logger = new_logger def set_log_level ( self , new_level ) -> None : \"\"\" Set the log level for this node. \"\"\" self . log_level = new_level def node_type ( self ) -> NodeType : \"\"\" Get the type of this node. Returns: `NodeType`: The type (`ACTION`). \"\"\" return NodeType . ACTION def get_node_by_name ( self , name : str ) -> Optional [ TreeNode ]: \"\"\" Search for a node by its name. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" if self . name == name : return self else : return None def pretty_repr ( self , depth = 0 ) -> str : \"\"\" Return a string representation of this node at the given depth. Args: depth (`int`): The depth of this node in a surrounding tree. Returns: `str`: The indented string representation. \"\"\" tabs = ' \\t ' * depth repr = f \" { tabs } Action { self . name } \" return repr set_logger ( new_logger ) Set the logger for this node. Source code in src/dendron/action_node.py 25 26 27 28 29 def set_logger ( self , new_logger ) -> None : \"\"\" Set the logger for this node. \"\"\" self . logger = new_logger set_log_level ( new_level ) Set the log level for this node. Source code in src/dendron/action_node.py 31 32 33 34 35 def set_log_level ( self , new_level ) -> None : \"\"\" Set the log level for this node. \"\"\" self . log_level = new_level node_type () Get the type of this node. Returns: Type Description NodeType NodeType : The type ( ACTION ). Source code in src/dendron/action_node.py 37 38 39 40 41 42 43 44 def node_type ( self ) -> NodeType : \"\"\" Get the type of this node. Returns: `NodeType`: The type (`ACTION`). \"\"\" return NodeType . ACTION get_node_by_name ( name ) Search for a node by its name. Parameters: Name Type Description Default name `str` The name of the node we are looking for. required Returns: Type Description Optional [ TreeNode ] Optional[TreeNode] : Either a node with the given name, Optional [ TreeNode ] or None. Source code in src/dendron/action_node.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def get_node_by_name ( self , name : str ) -> Optional [ TreeNode ]: \"\"\" Search for a node by its name. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" if self . name == name : return self else : return None","title":"ActionNode"},{"location":"api/action_node/#actionnode","text":"Bases: TreeNode An action node encapsulates the notion of a self-contained action or behavior. The bulk of the observable actions of a behavior tree are due to the action nodes. ActionNode s are one of the two kinds of leaf nodes in a Behavior Tree - the other being the ConditionNode . Parameters: Name Type Description Default name `str` The given name of this node. required Source code in src/dendron/action_node.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class ActionNode ( TreeNode ): \"\"\" An action node encapsulates the notion of a self-contained action or behavior. The bulk of the observable actions of a behavior tree are due to the action nodes. `ActionNode`s are one of the two kinds of leaf nodes in a Behavior Tree - the other being the `ConditionNode`. Args: name (`str`): The given name of this node. \"\"\" def __init__ ( self , name ) -> None : super () . __init__ ( name ) def set_logger ( self , new_logger ) -> None : \"\"\" Set the logger for this node. \"\"\" self . logger = new_logger def set_log_level ( self , new_level ) -> None : \"\"\" Set the log level for this node. \"\"\" self . log_level = new_level def node_type ( self ) -> NodeType : \"\"\" Get the type of this node. Returns: `NodeType`: The type (`ACTION`). \"\"\" return NodeType . ACTION def get_node_by_name ( self , name : str ) -> Optional [ TreeNode ]: \"\"\" Search for a node by its name. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" if self . name == name : return self else : return None def pretty_repr ( self , depth = 0 ) -> str : \"\"\" Return a string representation of this node at the given depth. Args: depth (`int`): The depth of this node in a surrounding tree. Returns: `str`: The indented string representation. \"\"\" tabs = ' \\t ' * depth repr = f \" { tabs } Action { self . name } \" return repr","title":"ActionNode"},{"location":"api/action_node/#dendron.action_node.ActionNode.set_logger","text":"Set the logger for this node. Source code in src/dendron/action_node.py 25 26 27 28 29 def set_logger ( self , new_logger ) -> None : \"\"\" Set the logger for this node. \"\"\" self . logger = new_logger","title":"set_logger"},{"location":"api/action_node/#dendron.action_node.ActionNode.set_log_level","text":"Set the log level for this node. Source code in src/dendron/action_node.py 31 32 33 34 35 def set_log_level ( self , new_level ) -> None : \"\"\" Set the log level for this node. \"\"\" self . log_level = new_level","title":"set_log_level"},{"location":"api/action_node/#dendron.action_node.ActionNode.node_type","text":"Get the type of this node. Returns: Type Description NodeType NodeType : The type ( ACTION ). Source code in src/dendron/action_node.py 37 38 39 40 41 42 43 44 def node_type ( self ) -> NodeType : \"\"\" Get the type of this node. Returns: `NodeType`: The type (`ACTION`). \"\"\" return NodeType . ACTION","title":"node_type"},{"location":"api/action_node/#dendron.action_node.ActionNode.get_node_by_name","text":"Search for a node by its name. Parameters: Name Type Description Default name `str` The name of the node we are looking for. required Returns: Type Description Optional [ TreeNode ] Optional[TreeNode] : Either a node with the given name, Optional [ TreeNode ] or None. Source code in src/dendron/action_node.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def get_node_by_name ( self , name : str ) -> Optional [ TreeNode ]: \"\"\" Search for a node by its name. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" if self . name == name : return self else : return None","title":"get_node_by_name"},{"location":"api/basic_types/","text":"Basic Types NodeType Bases: Enum Enum containing the types of nodes allowed in the behavior tree framework. Some of these are experimental. Source code in src/dendron/basic_types.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class NodeType ( Enum ): \"\"\" Enum containing the types of nodes allowed in the behavior tree framework. Some of these are experimental. \"\"\" UNDEFINED = 0 ACTION = 1 CONDITION = 2 CONTROL = 3 DECORATOR = 4 GOAL = 5 CONJUNCTION = 6 DISJUNCTION = 7 SUBTREE = 8 NodeStatus Bases: Enum Enum containing the allowable return values from node tick functions. Source code in src/dendron/basic_types.py 18 19 20 21 22 23 24 25 26 27 class NodeStatus ( Enum ): \"\"\" Enum containing the allowable return values from node `tick` functions. \"\"\" IDLE = 0 RUNNING = 1 SUCCESS = 2 FAILURE = 3 SKIPPED = 4 Quantization Bases: Enum Enum representing currently allowable quantization levels for neural models. TwoBit is currently aspirational. Source code in src/dendron/basic_types.py 29 30 31 32 33 34 35 36 37 class Quantization ( Enum ): \"\"\" Enum representing currently allowable quantization levels for neural models. `TwoBit` is currently aspirational. \"\"\" NoQuantization = 0 , TwoBit = 2 , FourBit = 4 , EightBit = 8 ,","title":"Basic Types"},{"location":"api/basic_types/#basic-types","text":"","title":"Basic Types"},{"location":"api/basic_types/#nodetype","text":"Bases: Enum Enum containing the types of nodes allowed in the behavior tree framework. Some of these are experimental. Source code in src/dendron/basic_types.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class NodeType ( Enum ): \"\"\" Enum containing the types of nodes allowed in the behavior tree framework. Some of these are experimental. \"\"\" UNDEFINED = 0 ACTION = 1 CONDITION = 2 CONTROL = 3 DECORATOR = 4 GOAL = 5 CONJUNCTION = 6 DISJUNCTION = 7 SUBTREE = 8","title":"NodeType"},{"location":"api/basic_types/#nodestatus","text":"Bases: Enum Enum containing the allowable return values from node tick functions. Source code in src/dendron/basic_types.py 18 19 20 21 22 23 24 25 26 27 class NodeStatus ( Enum ): \"\"\" Enum containing the allowable return values from node `tick` functions. \"\"\" IDLE = 0 RUNNING = 1 SUCCESS = 2 FAILURE = 3 SKIPPED = 4","title":"NodeStatus"},{"location":"api/basic_types/#quantization","text":"Bases: Enum Enum representing currently allowable quantization levels for neural models. TwoBit is currently aspirational. Source code in src/dendron/basic_types.py 29 30 31 32 33 34 35 36 37 class Quantization ( Enum ): \"\"\" Enum representing currently allowable quantization levels for neural models. `TwoBit` is currently aspirational. \"\"\" NoQuantization = 0 , TwoBit = 2 , FourBit = 4 , EightBit = 8 ,","title":"Quantization"},{"location":"api/behavior_tree/","text":"BehaviorTree A BehaviorTree instance is a container for the nodes that make up a behavior tree. This object is responsible for maintaining a root node of the tree, a blackboard that is shared among the nodes of the tree, and a thread pool for asynchronous action nodes. Parameters: Name Type Description Default tree_name `str` The given name of this tree. required root_node `dendron.tree_node.TreeNode` The root node of this tree. required bb `dendron.blackboard.Blackboard` An optional pre-initialized blackboard to use in this tree. None num_workers `int` An optional number of workings to initialize the thread pool with. 4 Source code in src/dendron/behavior_tree.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 class BehaviorTree : \"\"\" A `BehaviorTree` instance is a container for the nodes that make up a behavior tree. This object is responsible for maintaining a root node of the tree, a blackboard that is shared among the nodes of the tree, and a thread pool for asynchronous action nodes. Args: tree_name (`str`): The given name of this tree. root_node (`dendron.tree_node.TreeNode`): The root node of this tree. bb (`dendron.blackboard.Blackboard`): An optional pre-initialized blackboard to use in this tree. num_workers (`int`): An optional number of workings to initialize the thread pool with. \"\"\" def __init__ ( self , tree_name : str , root_node : TreeNode , bb : Blackboard = None , num_workers = 4 ) -> None : self . tree_name = tree_name self . root = root_node if bb is None : self . blackboard = Blackboard () else : self . blackboard = bb self . root . set_blackboard ( self . blackboard ) self . root . set_tree ( self ) self . num_workers = num_workers self . logger = None self . log_file_name = None self . executor = futures . ThreadPoolExecutor ( max_workers = num_workers ) def __getstate__ ( self ): state = self . __dict__ . copy () del state [ 'executor' ] return state def __setstate__ ( self , state ): self . __dict__ . update ( state ) self . executor = futures . ThreadPoolExecutor ( max_workers = self . num_workers ) def __del__ ( self ): self . disable_logging () def enable_logging ( self ) -> None : \"\"\" Turn on logging for every node in this tree. By default, each `tick()` call in every node results in a logging event. \"\"\" if self . logger is None : self . logger = logging . getLogger ( self . tree_name ) self . logger . setLevel ( logging . DEBUG ) handler = logging . StreamHandler () handler . setLevel ( logging . DEBUG ) formatter = logging . Formatter ( \" %(asctime)s - %(name)s - %(levelname)s - %(message)s \" ) handler . setFormatter ( formatter ) self . logger . addHandler ( handler ) self . root . set_logger ( self . logger ) def disable_logging ( self ) -> None : \"\"\" Turn logging off. \"\"\" if self . logger is not None : for h in self . logger . handlers : h . close () self . logger . removeHandler ( h ) self . logger = None self . log_file_name = None # TODO set root logger to None? def set_log_level ( self , log_level ) -> None : \"\"\" Set the log level for the tree. This is a no-op if logging is not enabled. \"\"\" level_to_set = None if type ( log_level ) == str : lvl = log_level . upper () match lvl : case \"DEBUG\" : level_to_set = logging . DEBUG case \"INFO\" : level_to_set = logging . INFO case \"WARNING\" : level_to_set = logging . WARNING case \"ERROR\" : level_to_set = logging . ERROR case \"CRITICAL\" : level_to_set = logging . CRITICAL elif type ( log_level ) == int : level_to_set = log_level else : raise TypeError ( \"log_level must be either int or str\" ) if self . logger is not None : self . logger . setLevel ( level_to_set ) for h in self . logger . handlers : h . setLevel ( level_to_set ) self . root . set_log_level ( level_to_set ) def set_log_filename ( self , filename : Optional [ str ]) -> None : \"\"\" If we want to log to a file instead of the command line, we use this method to set a a file name. Alternatively, if we are logging to a file and want to log to a stream instead, we can call this method with the filename set to `None`. Args: filename (`Optional[str]`): If `None`, log to a stream. If a `filename`, log to a file with that name. \"\"\" if self . logger is not None : for h in self . logger . handlers : h . close () self . logger . removeHandler ( h ) log_level = self . logger . level f = logging . Formatter ( \" %(asctime)s - %(name)s - %(levelname)s - %(message)s \" ) if filename is None : handler = logging . StreamHandler () handler . setLevel ( log_level ) handler . setFormatter ( f ) self . logger . addHandler ( handler ) else : handler = logging . FileHandler ( filename ) handler . setLevel ( log_level ) handler . setFormatter ( f ) self . logger . addHandler ( handler ) def set_root ( self , new_root : TreeNode ) -> None : \"\"\" Set the root of the tree to a new node. Args: new_root (`dendron.tree_node.TreeNode`): The new root node. \"\"\" self . root = new_root new_root . set_tree ( self ) def status ( self ) -> NodeStatus : \"\"\" Return the current status of this tree. The status of a tree is the current status of the root node of hte tree. Returns: `NodeStatus`: The status of the tree's root. \"\"\" return self . root . get_status () def reset ( self ) -> None : \"\"\" Instruct the root of the tree to `reset()`. \"\"\" self . root . reset () def halt_tree ( self ) -> None : \"\"\" Instruct the root of the tree to `halt()`. \"\"\" self . root . halt_node () # TODO consider deprecating def blackboard_get ( self , key ) -> Any : return self . blackboard [ key ] # TODO consider deprecating def blackboard_set ( self , key , value ) -> None : self . blackboard [ key ] = value def get_node_by_name ( self , name : str ) -> Optional [ TreeNode ]: \"\"\" Search for a node by its name. Forwards the call to the current root node. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" if self . root : return self . root . get_node_by_name ( name ) else : return None def tick_once ( self ) -> NodeStatus : \"\"\" Instruct the root of the tree to execute its `tick()` function. This is the primary interface to run a `BehaviorTree`. Returns: `NodeStatus`: The status returned by the root. \"\"\" return self . root . execute_tick () def tick_while_running ( self ) -> NodeStatus : \"\"\" Repeatedly `tick()` the behavior tree as long as the status returned by the root is `RUNNING`. At present, this is only possible if the tree contains one or more asynchronous nodes. Returns: `NodeStatus`: The status ultimately returned by the root. \"\"\" status = self . root . execute_tick () while status == NodeStatus . RUNNING : status = self . root . execute_tick () return status def pretty_print ( self ) -> None : \"\"\" Print an indented version of this tree to the command line. Indentation shows structure. \"\"\" print ( self . root . pretty_repr ()) disable_logging () Turn logging off. Source code in src/dendron/behavior_tree.py 74 75 76 77 78 79 80 81 82 83 def disable_logging ( self ) -> None : \"\"\" Turn logging off. \"\"\" if self . logger is not None : for h in self . logger . handlers : h . close () self . logger . removeHandler ( h ) self . logger = None self . log_file_name = None enable_logging () Turn on logging for every node in this tree. By default, each tick() call in every node results in a logging event. Source code in src/dendron/behavior_tree.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def enable_logging ( self ) -> None : \"\"\" Turn on logging for every node in this tree. By default, each `tick()` call in every node results in a logging event. \"\"\" if self . logger is None : self . logger = logging . getLogger ( self . tree_name ) self . logger . setLevel ( logging . DEBUG ) handler = logging . StreamHandler () handler . setLevel ( logging . DEBUG ) formatter = logging . Formatter ( \" %(asctime)s - %(name)s - %(levelname)s - %(message)s \" ) handler . setFormatter ( formatter ) self . logger . addHandler ( handler ) self . root . set_logger ( self . logger ) get_node_by_name ( name ) Search for a node by its name. Forwards the call to the current root node. Parameters: Name Type Description Default name `str` The name of the node we are looking for. required Returns: Type Description Optional [ TreeNode ] Optional[TreeNode] : Either a node with the given name, Optional [ TreeNode ] or None. Source code in src/dendron/behavior_tree.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def get_node_by_name ( self , name : str ) -> Optional [ TreeNode ]: \"\"\" Search for a node by its name. Forwards the call to the current root node. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" if self . root : return self . root . get_node_by_name ( name ) else : return None halt_tree () Instruct the root of the tree to halt() . Source code in src/dendron/behavior_tree.py 176 177 178 179 180 def halt_tree ( self ) -> None : \"\"\" Instruct the root of the tree to `halt()`. \"\"\" self . root . halt_node () pretty_print () Print an indented version of this tree to the command line. Indentation shows structure. Source code in src/dendron/behavior_tree.py 235 236 237 238 239 240 def pretty_print ( self ) -> None : \"\"\" Print an indented version of this tree to the command line. Indentation shows structure. \"\"\" print ( self . root . pretty_repr ()) reset () Instruct the root of the tree to reset() . Source code in src/dendron/behavior_tree.py 170 171 172 173 174 def reset ( self ) -> None : \"\"\" Instruct the root of the tree to `reset()`. \"\"\" self . root . reset () set_log_filename ( filename ) If we want to log to a file instead of the command line, we use this method to set a a file name. Alternatively, if we are logging to a file and want to log to a stream instead, we can call this method with the filename set to None . Parameters: Name Type Description Default filename `Optional[str]` If None , log to a stream. If a filename , log to a file with that name. required Source code in src/dendron/behavior_tree.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def set_log_filename ( self , filename : Optional [ str ]) -> None : \"\"\" If we want to log to a file instead of the command line, we use this method to set a a file name. Alternatively, if we are logging to a file and want to log to a stream instead, we can call this method with the filename set to `None`. Args: filename (`Optional[str]`): If `None`, log to a stream. If a `filename`, log to a file with that name. \"\"\" if self . logger is not None : for h in self . logger . handlers : h . close () self . logger . removeHandler ( h ) log_level = self . logger . level f = logging . Formatter ( \" %(asctime)s - %(name)s - %(levelname)s - %(message)s \" ) if filename is None : handler = logging . StreamHandler () handler . setLevel ( log_level ) handler . setFormatter ( f ) self . logger . addHandler ( handler ) else : handler = logging . FileHandler ( filename ) handler . setLevel ( log_level ) handler . setFormatter ( f ) self . logger . addHandler ( handler ) set_log_level ( log_level ) Set the log level for the tree. This is a no-op if logging is not enabled. Source code in src/dendron/behavior_tree.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def set_log_level ( self , log_level ) -> None : \"\"\" Set the log level for the tree. This is a no-op if logging is not enabled. \"\"\" level_to_set = None if type ( log_level ) == str : lvl = log_level . upper () match lvl : case \"DEBUG\" : level_to_set = logging . DEBUG case \"INFO\" : level_to_set = logging . INFO case \"WARNING\" : level_to_set = logging . WARNING case \"ERROR\" : level_to_set = logging . ERROR case \"CRITICAL\" : level_to_set = logging . CRITICAL elif type ( log_level ) == int : level_to_set = log_level else : raise TypeError ( \"log_level must be either int or str\" ) if self . logger is not None : self . logger . setLevel ( level_to_set ) for h in self . logger . handlers : h . setLevel ( level_to_set ) self . root . set_log_level ( level_to_set ) set_root ( new_root ) Set the root of the tree to a new node. Parameters: Name Type Description Default new_root `dendron.tree_node.TreeNode` The new root node. required Source code in src/dendron/behavior_tree.py 149 150 151 152 153 154 155 156 157 158 def set_root ( self , new_root : TreeNode ) -> None : \"\"\" Set the root of the tree to a new node. Args: new_root (`dendron.tree_node.TreeNode`): The new root node. \"\"\" self . root = new_root new_root . set_tree ( self ) status () Return the current status of this tree. The status of a tree is the current status of the root node of hte tree. Returns: Type Description NodeStatus NodeStatus : The status of the tree's root. Source code in src/dendron/behavior_tree.py 160 161 162 163 164 165 166 167 168 def status ( self ) -> NodeStatus : \"\"\" Return the current status of this tree. The status of a tree is the current status of the root node of hte tree. Returns: `NodeStatus`: The status of the tree's root. \"\"\" return self . root . get_status () tick_once () Instruct the root of the tree to execute its tick() function. This is the primary interface to run a BehaviorTree . Returns: Type Description NodeStatus NodeStatus : The status returned by the root. Source code in src/dendron/behavior_tree.py 208 209 210 211 212 213 214 215 216 217 def tick_once ( self ) -> NodeStatus : \"\"\" Instruct the root of the tree to execute its `tick()` function. This is the primary interface to run a `BehaviorTree`. Returns: `NodeStatus`: The status returned by the root. \"\"\" return self . root . execute_tick () tick_while_running () Repeatedly tick() the behavior tree as long as the status returned by the root is RUNNING . At present, this is only possible if the tree contains one or more asynchronous nodes. Returns: Type Description NodeStatus NodeStatus : The status ultimately returned by the root. Source code in src/dendron/behavior_tree.py 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def tick_while_running ( self ) -> NodeStatus : \"\"\" Repeatedly `tick()` the behavior tree as long as the status returned by the root is `RUNNING`. At present, this is only possible if the tree contains one or more asynchronous nodes. Returns: `NodeStatus`: The status ultimately returned by the root. \"\"\" status = self . root . execute_tick () while status == NodeStatus . RUNNING : status = self . root . execute_tick () return status","title":"BehaviorTree"},{"location":"api/behavior_tree/#behaviortree","text":"A BehaviorTree instance is a container for the nodes that make up a behavior tree. This object is responsible for maintaining a root node of the tree, a blackboard that is shared among the nodes of the tree, and a thread pool for asynchronous action nodes. Parameters: Name Type Description Default tree_name `str` The given name of this tree. required root_node `dendron.tree_node.TreeNode` The root node of this tree. required bb `dendron.blackboard.Blackboard` An optional pre-initialized blackboard to use in this tree. None num_workers `int` An optional number of workings to initialize the thread pool with. 4 Source code in src/dendron/behavior_tree.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 class BehaviorTree : \"\"\" A `BehaviorTree` instance is a container for the nodes that make up a behavior tree. This object is responsible for maintaining a root node of the tree, a blackboard that is shared among the nodes of the tree, and a thread pool for asynchronous action nodes. Args: tree_name (`str`): The given name of this tree. root_node (`dendron.tree_node.TreeNode`): The root node of this tree. bb (`dendron.blackboard.Blackboard`): An optional pre-initialized blackboard to use in this tree. num_workers (`int`): An optional number of workings to initialize the thread pool with. \"\"\" def __init__ ( self , tree_name : str , root_node : TreeNode , bb : Blackboard = None , num_workers = 4 ) -> None : self . tree_name = tree_name self . root = root_node if bb is None : self . blackboard = Blackboard () else : self . blackboard = bb self . root . set_blackboard ( self . blackboard ) self . root . set_tree ( self ) self . num_workers = num_workers self . logger = None self . log_file_name = None self . executor = futures . ThreadPoolExecutor ( max_workers = num_workers ) def __getstate__ ( self ): state = self . __dict__ . copy () del state [ 'executor' ] return state def __setstate__ ( self , state ): self . __dict__ . update ( state ) self . executor = futures . ThreadPoolExecutor ( max_workers = self . num_workers ) def __del__ ( self ): self . disable_logging () def enable_logging ( self ) -> None : \"\"\" Turn on logging for every node in this tree. By default, each `tick()` call in every node results in a logging event. \"\"\" if self . logger is None : self . logger = logging . getLogger ( self . tree_name ) self . logger . setLevel ( logging . DEBUG ) handler = logging . StreamHandler () handler . setLevel ( logging . DEBUG ) formatter = logging . Formatter ( \" %(asctime)s - %(name)s - %(levelname)s - %(message)s \" ) handler . setFormatter ( formatter ) self . logger . addHandler ( handler ) self . root . set_logger ( self . logger ) def disable_logging ( self ) -> None : \"\"\" Turn logging off. \"\"\" if self . logger is not None : for h in self . logger . handlers : h . close () self . logger . removeHandler ( h ) self . logger = None self . log_file_name = None # TODO set root logger to None? def set_log_level ( self , log_level ) -> None : \"\"\" Set the log level for the tree. This is a no-op if logging is not enabled. \"\"\" level_to_set = None if type ( log_level ) == str : lvl = log_level . upper () match lvl : case \"DEBUG\" : level_to_set = logging . DEBUG case \"INFO\" : level_to_set = logging . INFO case \"WARNING\" : level_to_set = logging . WARNING case \"ERROR\" : level_to_set = logging . ERROR case \"CRITICAL\" : level_to_set = logging . CRITICAL elif type ( log_level ) == int : level_to_set = log_level else : raise TypeError ( \"log_level must be either int or str\" ) if self . logger is not None : self . logger . setLevel ( level_to_set ) for h in self . logger . handlers : h . setLevel ( level_to_set ) self . root . set_log_level ( level_to_set ) def set_log_filename ( self , filename : Optional [ str ]) -> None : \"\"\" If we want to log to a file instead of the command line, we use this method to set a a file name. Alternatively, if we are logging to a file and want to log to a stream instead, we can call this method with the filename set to `None`. Args: filename (`Optional[str]`): If `None`, log to a stream. If a `filename`, log to a file with that name. \"\"\" if self . logger is not None : for h in self . logger . handlers : h . close () self . logger . removeHandler ( h ) log_level = self . logger . level f = logging . Formatter ( \" %(asctime)s - %(name)s - %(levelname)s - %(message)s \" ) if filename is None : handler = logging . StreamHandler () handler . setLevel ( log_level ) handler . setFormatter ( f ) self . logger . addHandler ( handler ) else : handler = logging . FileHandler ( filename ) handler . setLevel ( log_level ) handler . setFormatter ( f ) self . logger . addHandler ( handler ) def set_root ( self , new_root : TreeNode ) -> None : \"\"\" Set the root of the tree to a new node. Args: new_root (`dendron.tree_node.TreeNode`): The new root node. \"\"\" self . root = new_root new_root . set_tree ( self ) def status ( self ) -> NodeStatus : \"\"\" Return the current status of this tree. The status of a tree is the current status of the root node of hte tree. Returns: `NodeStatus`: The status of the tree's root. \"\"\" return self . root . get_status () def reset ( self ) -> None : \"\"\" Instruct the root of the tree to `reset()`. \"\"\" self . root . reset () def halt_tree ( self ) -> None : \"\"\" Instruct the root of the tree to `halt()`. \"\"\" self . root . halt_node () # TODO consider deprecating def blackboard_get ( self , key ) -> Any : return self . blackboard [ key ] # TODO consider deprecating def blackboard_set ( self , key , value ) -> None : self . blackboard [ key ] = value def get_node_by_name ( self , name : str ) -> Optional [ TreeNode ]: \"\"\" Search for a node by its name. Forwards the call to the current root node. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" if self . root : return self . root . get_node_by_name ( name ) else : return None def tick_once ( self ) -> NodeStatus : \"\"\" Instruct the root of the tree to execute its `tick()` function. This is the primary interface to run a `BehaviorTree`. Returns: `NodeStatus`: The status returned by the root. \"\"\" return self . root . execute_tick () def tick_while_running ( self ) -> NodeStatus : \"\"\" Repeatedly `tick()` the behavior tree as long as the status returned by the root is `RUNNING`. At present, this is only possible if the tree contains one or more asynchronous nodes. Returns: `NodeStatus`: The status ultimately returned by the root. \"\"\" status = self . root . execute_tick () while status == NodeStatus . RUNNING : status = self . root . execute_tick () return status def pretty_print ( self ) -> None : \"\"\" Print an indented version of this tree to the command line. Indentation shows structure. \"\"\" print ( self . root . pretty_repr ())","title":"BehaviorTree"},{"location":"api/behavior_tree/#dendron.behavior_tree.BehaviorTree.disable_logging","text":"Turn logging off. Source code in src/dendron/behavior_tree.py 74 75 76 77 78 79 80 81 82 83 def disable_logging ( self ) -> None : \"\"\" Turn logging off. \"\"\" if self . logger is not None : for h in self . logger . handlers : h . close () self . logger . removeHandler ( h ) self . logger = None self . log_file_name = None","title":"disable_logging"},{"location":"api/behavior_tree/#dendron.behavior_tree.BehaviorTree.enable_logging","text":"Turn on logging for every node in this tree. By default, each tick() call in every node results in a logging event. Source code in src/dendron/behavior_tree.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def enable_logging ( self ) -> None : \"\"\" Turn on logging for every node in this tree. By default, each `tick()` call in every node results in a logging event. \"\"\" if self . logger is None : self . logger = logging . getLogger ( self . tree_name ) self . logger . setLevel ( logging . DEBUG ) handler = logging . StreamHandler () handler . setLevel ( logging . DEBUG ) formatter = logging . Formatter ( \" %(asctime)s - %(name)s - %(levelname)s - %(message)s \" ) handler . setFormatter ( formatter ) self . logger . addHandler ( handler ) self . root . set_logger ( self . logger )","title":"enable_logging"},{"location":"api/behavior_tree/#dendron.behavior_tree.BehaviorTree.get_node_by_name","text":"Search for a node by its name. Forwards the call to the current root node. Parameters: Name Type Description Default name `str` The name of the node we are looking for. required Returns: Type Description Optional [ TreeNode ] Optional[TreeNode] : Either a node with the given name, Optional [ TreeNode ] or None. Source code in src/dendron/behavior_tree.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def get_node_by_name ( self , name : str ) -> Optional [ TreeNode ]: \"\"\" Search for a node by its name. Forwards the call to the current root node. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" if self . root : return self . root . get_node_by_name ( name ) else : return None","title":"get_node_by_name"},{"location":"api/behavior_tree/#dendron.behavior_tree.BehaviorTree.halt_tree","text":"Instruct the root of the tree to halt() . Source code in src/dendron/behavior_tree.py 176 177 178 179 180 def halt_tree ( self ) -> None : \"\"\" Instruct the root of the tree to `halt()`. \"\"\" self . root . halt_node ()","title":"halt_tree"},{"location":"api/behavior_tree/#dendron.behavior_tree.BehaviorTree.pretty_print","text":"Print an indented version of this tree to the command line. Indentation shows structure. Source code in src/dendron/behavior_tree.py 235 236 237 238 239 240 def pretty_print ( self ) -> None : \"\"\" Print an indented version of this tree to the command line. Indentation shows structure. \"\"\" print ( self . root . pretty_repr ())","title":"pretty_print"},{"location":"api/behavior_tree/#dendron.behavior_tree.BehaviorTree.reset","text":"Instruct the root of the tree to reset() . Source code in src/dendron/behavior_tree.py 170 171 172 173 174 def reset ( self ) -> None : \"\"\" Instruct the root of the tree to `reset()`. \"\"\" self . root . reset ()","title":"reset"},{"location":"api/behavior_tree/#dendron.behavior_tree.BehaviorTree.set_log_filename","text":"If we want to log to a file instead of the command line, we use this method to set a a file name. Alternatively, if we are logging to a file and want to log to a stream instead, we can call this method with the filename set to None . Parameters: Name Type Description Default filename `Optional[str]` If None , log to a stream. If a filename , log to a file with that name. required Source code in src/dendron/behavior_tree.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def set_log_filename ( self , filename : Optional [ str ]) -> None : \"\"\" If we want to log to a file instead of the command line, we use this method to set a a file name. Alternatively, if we are logging to a file and want to log to a stream instead, we can call this method with the filename set to `None`. Args: filename (`Optional[str]`): If `None`, log to a stream. If a `filename`, log to a file with that name. \"\"\" if self . logger is not None : for h in self . logger . handlers : h . close () self . logger . removeHandler ( h ) log_level = self . logger . level f = logging . Formatter ( \" %(asctime)s - %(name)s - %(levelname)s - %(message)s \" ) if filename is None : handler = logging . StreamHandler () handler . setLevel ( log_level ) handler . setFormatter ( f ) self . logger . addHandler ( handler ) else : handler = logging . FileHandler ( filename ) handler . setLevel ( log_level ) handler . setFormatter ( f ) self . logger . addHandler ( handler )","title":"set_log_filename"},{"location":"api/behavior_tree/#dendron.behavior_tree.BehaviorTree.set_log_level","text":"Set the log level for the tree. This is a no-op if logging is not enabled. Source code in src/dendron/behavior_tree.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def set_log_level ( self , log_level ) -> None : \"\"\" Set the log level for the tree. This is a no-op if logging is not enabled. \"\"\" level_to_set = None if type ( log_level ) == str : lvl = log_level . upper () match lvl : case \"DEBUG\" : level_to_set = logging . DEBUG case \"INFO\" : level_to_set = logging . INFO case \"WARNING\" : level_to_set = logging . WARNING case \"ERROR\" : level_to_set = logging . ERROR case \"CRITICAL\" : level_to_set = logging . CRITICAL elif type ( log_level ) == int : level_to_set = log_level else : raise TypeError ( \"log_level must be either int or str\" ) if self . logger is not None : self . logger . setLevel ( level_to_set ) for h in self . logger . handlers : h . setLevel ( level_to_set ) self . root . set_log_level ( level_to_set )","title":"set_log_level"},{"location":"api/behavior_tree/#dendron.behavior_tree.BehaviorTree.set_root","text":"Set the root of the tree to a new node. Parameters: Name Type Description Default new_root `dendron.tree_node.TreeNode` The new root node. required Source code in src/dendron/behavior_tree.py 149 150 151 152 153 154 155 156 157 158 def set_root ( self , new_root : TreeNode ) -> None : \"\"\" Set the root of the tree to a new node. Args: new_root (`dendron.tree_node.TreeNode`): The new root node. \"\"\" self . root = new_root new_root . set_tree ( self )","title":"set_root"},{"location":"api/behavior_tree/#dendron.behavior_tree.BehaviorTree.status","text":"Return the current status of this tree. The status of a tree is the current status of the root node of hte tree. Returns: Type Description NodeStatus NodeStatus : The status of the tree's root. Source code in src/dendron/behavior_tree.py 160 161 162 163 164 165 166 167 168 def status ( self ) -> NodeStatus : \"\"\" Return the current status of this tree. The status of a tree is the current status of the root node of hte tree. Returns: `NodeStatus`: The status of the tree's root. \"\"\" return self . root . get_status ()","title":"status"},{"location":"api/behavior_tree/#dendron.behavior_tree.BehaviorTree.tick_once","text":"Instruct the root of the tree to execute its tick() function. This is the primary interface to run a BehaviorTree . Returns: Type Description NodeStatus NodeStatus : The status returned by the root. Source code in src/dendron/behavior_tree.py 208 209 210 211 212 213 214 215 216 217 def tick_once ( self ) -> NodeStatus : \"\"\" Instruct the root of the tree to execute its `tick()` function. This is the primary interface to run a `BehaviorTree`. Returns: `NodeStatus`: The status returned by the root. \"\"\" return self . root . execute_tick ()","title":"tick_once"},{"location":"api/behavior_tree/#dendron.behavior_tree.BehaviorTree.tick_while_running","text":"Repeatedly tick() the behavior tree as long as the status returned by the root is RUNNING . At present, this is only possible if the tree contains one or more asynchronous nodes. Returns: Type Description NodeStatus NodeStatus : The status ultimately returned by the root. Source code in src/dendron/behavior_tree.py 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def tick_while_running ( self ) -> NodeStatus : \"\"\" Repeatedly `tick()` the behavior tree as long as the status returned by the root is `RUNNING`. At present, this is only possible if the tree contains one or more asynchronous nodes. Returns: `NodeStatus`: The status ultimately returned by the root. \"\"\" status = self . root . execute_tick () while status == NodeStatus . RUNNING : status = self . root . execute_tick () return status","title":"tick_while_running"},{"location":"api/behavior_tree_factory/","text":"BehaviorTreeFactory A factory for behavior trees. This allows the registration of new node types and the generation of BehaviorTree s from XML files. A factory maintains state that allows node repetition and subtree insertion to be automatically handled. Source code in src/dendron/behavior_tree_factory.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 class BehaviorTreeFactory : \"\"\" A factory for behavior trees. This allows the registration of new node types and the generation of `BehaviorTree`s from XML files. A factory maintains state that allows node repetition and subtree insertion to be automatically handled. \"\"\" def __init__ ( self ) -> None : self . registry = {} self . node_counts = {} self . node_types = {} self . functors = {} self . neural_configs = {} self . registry [ \"Fallback\" ] = FallbackNode self . registry [ \"Sequence\" ] = SequenceNode self . registry [ \"Inverter\" ] = InverterNode self . registry [ \"AlwaysSuccess\" ] = AlwaysSuccess self . registry [ \"AlwaysFailure\" ] = AlwaysFailure self . registry [ \"AsyncAction\" ] = AsyncAction self . registry [ \"CausalLMAction\" ] = CausalLMAction self . registry [ \"ImageLMAction\" ] = ImageLMAction self . registry [ \"PipelineAction\" ] = PipelineAction # We replace SubTree nodes with the subtree root, so # we use None as a placeholder here. self . registry [ \"SubTree\" ] = None self . node_counts [ \"Fallback\" ] = 0 self . node_counts [ \"Sequence\" ] = 0 self . node_counts [ \"Inverter\" ] = 0 self . node_counts [ \"AlwaysSuccess\" ] = 0 self . node_counts [ \"AlwaysFailure\" ] = 0 self . node_counts [ \"AsyncAction\" ] = 0 self . node_counts [ \"CausalLMAction\" ] = 0 self . node_counts [ \"ImageLMAction\" ] = 0 self . node_counts [ \"PipelineAction\" ] = 0 self . node_types [ \"Fallback\" ] = NodeType . CONTROL self . node_types [ \"Sequence\" ] = NodeType . CONTROL self . node_types [ \"Inverter\" ] = NodeType . DECORATOR self . node_types [ \"AlwaysSuccess\" ] = NodeType . ACTION self . node_types [ \"AlwaysFailure\" ] = NodeType . ACTION self . node_types [ \"AsyncAction\" ] = NodeType . ACTION self . node_types [ \"CausalLMAction\" ] = NodeType . ACTION self . node_types [ \"ImageLMAction\" ] = NodeType . ACTION self . node_types [ \"PipelineAction\" ] = NodeType . ACTION self . node_types [ \"SubTree\" ] = NodeType . SUBTREE self . current_blackboard = None self . tree_nodes_model = None self . behavior_trees = {} def register_neural_config ( self , name , cfg ) -> None : \"\"\" Register a configuration object for a neural network based node. Args: name (str): The name of the configuration object. This should match the name used in Groot. cfg: The configuration object. At present, one of `CausalLMActionConfig`, `ImageLMActionConfig`, `PipelineActionConfig`, or `CompletionConditionConfig`. \"\"\" self . neural_configs [ name ] = cfg def register_action_type ( self , name , action ) -> None : \"\"\" Register a new type of action node. Args: name (str): The name of the new action node type. action: The constructor (class name) of the new node type. \"\"\" self . registry [ name ] = action self . node_counts [ name ] = 0 self . node_types [ name ] = NodeType . ACTION def register_condition_type ( self , name , condition ) -> None : \"\"\" Register a new type of condition node. Args: name (str): The name of the new condition type. condition: The constructor (class name) of the new node type. \"\"\" self . registry [ name ] = condition self . node_counts [ name ] = 0 self . node_types [ name ] = NodeType . CONDITION def register_decorator_type ( self , name , decorator ) -> None : \"\"\" Register a new type of decorator node. Args: name (str): The name of the new decorator type. decorator: The constructor (class name) of the new node type. \"\"\" self . registry [ name ] = decorator self . node_counts [ name ] = 0 self . node_types [ name ] = NodeType . DECORATOR def register_simple_action ( self , name , action_function ) -> None : \"\"\" Register a new simple action. Allows the specification of an action and a callback in one step. Args: name (str): The name of the new simple action node type. action_function (Callable): A callback to execute each time this node is ticked. \"\"\" self . registry [ name ] = SimpleAction self . functors [ name ] = action_function self . node_counts [ name ] = 0 self . node_types [ name ] = NodeType . ACTION def register_simple_condition ( self , name , condition_function ) -> None : \"\"\" Register a new simple condition. Allows the specification of a condition and a callback in one step. Args: name (str): The name of the simple condition node type. condition_function (Callable): A callback to execute each time this node is ticked. \"\"\" self . registry [ name ] = SimpleConditionNode self . functors [ name ] = condition_function self . node_counts [ name ] = 0 self . node_types [ name ] = NodeType . CONDITION def create_from_groot ( self , xml_filename : str ) -> BehaviorTree : \"\"\" Create a `BehaviorTree` instance from an XML file generated by the open-source Groot2 program. Args: xml_filename (`str`): The name of the file containing the XML. Returns: `BehaviorTree`: A behavior tree that instantiates the structure described in the XML file. \"\"\" self . current_blackboard = Blackboard () xml_tree = ET . parse ( xml_filename ) xml_root = xml_tree . getroot () if not \"BTCPP_format\" in xml_root . attrib : raise RuntimeError ( \"XML missing BTCPP_format\" ) if xml_root . attrib [ \"BTCPP_format\" ] != \"4\" : raise RuntimeError ( \"BTCPP_format must be 4\" ) has_main_tree = \"main_tree_to_execute\" in xml_root . attrib main_tree_name = None if has_main_tree : main_tree_name = xml_root . attrib [ \"main_tree_to_execute\" ] tree_nodes_xml = None behavior_tree_xml = [] main_tree = None for child in xml_root : if child . tag == \"TreeNodesModel\" : tree_nodes_xml = child elif child . tag == \"BehaviorTree\" : if \"ID\" in child . attrib and child . attrib [ \"ID\" ] == main_tree_name : main_tree = child else : behavior_tree_xml . append ( child ) # load TreeNodesModel for child in tree_nodes_xml : match child . tag : case \"Action\" : self . node_types [ child . attrib [ \"ID\" ]] = NodeType . ACTION case \"Condition\" : self . node_types [ child . attrib [ \"ID\" ]] = NodeType . CONDITION case \"Control\" : self . node_types [ child . attrib [ \"ID\" ]] = NodeType . CONTROL case \"Decorator\" : self . node_types [ child . attrib [ \"ID\" ]] = NodeType . DECORATOR if not has_main_tree and len ( behavior_tree_xml ) > 1 : raise RuntimeError ( \"Multiple behavior trees but no main tree.\" ) if main_tree is None and len ( behavior_tree_xml ) == 1 : main_tree = behavior_tree_xml [ 0 ] # load each behavior tree ## convert the other trees parse_order = get_parse_order ( xml_root ) for tree_name in parse_order : if tree_name == main_tree_name : continue tree = None for child in xml_root : if child . tag != \"BehaviorTree\" : continue child_name = child . attrib [ \"ID\" ] if child_name != tree_name : continue else : tree = self . parse_behavior_tree_groot ( child_name , child ) self . behavior_trees [ tree_name ] = tree # parse the main tree last main_tree = self . parse_behavior_tree_groot ( main_tree . attrib [ \"ID\" ], main_tree ) self . behavior_trees [ main_tree_name ] = main_tree return main_tree def parse_behavior_tree_groot ( self , tree_name , xml_node ) -> BehaviorTree : tree_type = self . node_types [ xml_node [ 0 ] . tag ] root_node = None match tree_type : case NodeType . ACTION : root_node = self . parse_action_node_groot ( xml_node [ 0 ]) case NodeType . CONDITION : root_node = self . parse_condition_node_groot ( xml_node [ 0 ]) case NodeType . CONTROL : root_node = self . parse_control_node_groot ( xml_node [ 0 ]) case NodeType . DECORATOR : root_node = self . parse_decorator_node_groot ( xml_node [ 0 ]) case NodeType . SUBTREE : root_node = self . parse_subtree_node_groot ( xml_node [ 0 ]) bt = BehaviorTree ( tree_name , root_node ) return bt def parse_action_node_groot ( self , xml_node ) -> ActionNode : tag = xml_node . tag if not tag in self . registry : raise KeyError ( f \"Undefined action { tag } .\" ) node_id = self . node_counts [ tag ] node_name = tag + \"_\" + str ( node_id ) if self . registry [ tag ] == SimpleAction : f = self . functors [ tag ] new_node = self . registry [ tag ]( node_name , f ) else : new_node = self . registry [ tag ]( node_name ) self . node_counts [ tag ] += 1 if xml_node . attrib : for key in xml_node . attrib : self . current_blackboard [ key ] = xml_node . attrib [ key ] return new_node def parse_condition_node_groot ( self , xml_node ) -> ConditionNode : tag = xml_node . tag if not tag in self . registry : raise KeyError ( f \"Undefined condition { tag } .\" ) node_id = self . node_counts [ tag ] node_name = tag + \"_\" + str ( node_id ) if self . registry [ tag ] == SimpleConditionNode : f = self . functors [ tag ] new_node = self . registry [ tag ]( node_name , f ) else : new_node = self . registry [ tag ]( node_name ) self . node_counts [ tag ] += 1 if xml_node . attrib : for key in xml_node . attrib : self . current_blackboard [ key ] = xml_node . attrib [ key ] return new_node def parse_control_node_groot ( self , xml_node ) -> ControlNode : tag = xml_node . tag if not tag in self . registry : raise KeyError ( f \"Undefined control { tag } .\" ) node_id = self . node_counts [ tag ] node_name = tag + \"_\" + str ( node_id ) self . node_counts [ tag ] += 1 if xml_node . attrib : for key in xml_node . attrib : self . current_blackboard [ key ] = xml_node . attrib [ key ] # parse children child_nodes = [] for child_xml in xml_node : if not child_xml . tag in self . registry : raise RuntimeError ( f \"Unregistered node { child_xml . tag } \" ) match self . node_types [ child_xml . tag ]: case NodeType . ACTION : child_node = self . parse_action_node_groot ( child_xml ) case NodeType . CONDITION : child_node = self . parse_condition_node_groot ( child_xml ) case NodeType . CONTROL : child_node = self . parse_control_node_groot ( child_xml ) case NodeType . DECORATOR : child_node = self . parse_decorator_node_groot ( child_xml ) case NodeType . SUBTREE : child_node = self . parse_subtree_node_groot ( child_xml ) child_nodes . append ( child_node ) new_node = self . registry [ tag ]( node_name , child_nodes ) return new_node def parse_decorator_node_groot ( self , xml_node ) -> DecoratorNode : tag = xml_node . tag if not tag in self . registry : raise KeyError ( f \"Undefined decorator { tag } .\" ) node_id = self . node_counts [ tag ] node_name = tag + \"_\" + str ( node_id ) self . node_counts [ tag ] += 1 if xml_node . attrib : for key in xml_node . attrib : self . current_blackboard [ key ] = xml_node . attrib [ key ] child_node = None child_xml = xml_node [ 0 ] match self . node_types [ child_xml . tag ]: case NodeType . ACTION : child_node = self . parse_action_node_groot ( child_xml ) case NodeType . CONDITION : child_node = self . parse_condition_node_groot ( child_xml ) case NodeType . CONTROL : child_node = self . parse_control_node_groot ( child_xml ) case NodeType . DECORATOR : child_node = self . parse_decorator_node_groot ( child_xml ) case NodeType . SUBTREE : child_node = self . parse_subtree_node_groot ( child_xml ) new_node = self . registry [ tag ]( node_name , child_node ) return new_node def parse_subtree_node_groot ( self , xml_node ) -> TreeNode : subtree_name = xml_node . attrib [ \"ID\" ] # TODO is deepcopy good enough? return deepcopy ( self . behavior_trees [ subtree_name ] . root ) register_neural_config ( name , cfg ) Register a configuration object for a neural network based node. Parameters: Name Type Description Default name str The name of the configuration object. This should match the name used in Groot. required cfg The configuration object. At present, one of CausalLMActionConfig , ImageLMActionConfig , PipelineActionConfig , or CompletionConditionConfig . required Source code in src/dendron/behavior_tree_factory.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def register_neural_config ( self , name , cfg ) -> None : \"\"\" Register a configuration object for a neural network based node. Args: name (str): The name of the configuration object. This should match the name used in Groot. cfg: The configuration object. At present, one of `CausalLMActionConfig`, `ImageLMActionConfig`, `PipelineActionConfig`, or `CompletionConditionConfig`. \"\"\" self . neural_configs [ name ] = cfg register_action_type ( name , action ) Register a new type of action node. Parameters: Name Type Description Default name str The name of the new action node type. required action The constructor (class name) of the new node type. required Source code in src/dendron/behavior_tree_factory.py 97 98 99 100 101 102 103 104 105 106 107 108 109 def register_action_type ( self , name , action ) -> None : \"\"\" Register a new type of action node. Args: name (str): The name of the new action node type. action: The constructor (class name) of the new node type. \"\"\" self . registry [ name ] = action self . node_counts [ name ] = 0 self . node_types [ name ] = NodeType . ACTION register_condition_type ( name , condition ) Register a new type of condition node. Parameters: Name Type Description Default name str The name of the new condition type. required condition The constructor (class name) of the new node type. required Source code in src/dendron/behavior_tree_factory.py 111 112 113 114 115 116 117 118 119 120 121 122 123 def register_condition_type ( self , name , condition ) -> None : \"\"\" Register a new type of condition node. Args: name (str): The name of the new condition type. condition: The constructor (class name) of the new node type. \"\"\" self . registry [ name ] = condition self . node_counts [ name ] = 0 self . node_types [ name ] = NodeType . CONDITION register_decorator_type ( name , decorator ) Register a new type of decorator node. Parameters: Name Type Description Default name str The name of the new decorator type. required decorator The constructor (class name) of the new node type. required Source code in src/dendron/behavior_tree_factory.py 125 126 127 128 129 130 131 132 133 134 135 136 137 def register_decorator_type ( self , name , decorator ) -> None : \"\"\" Register a new type of decorator node. Args: name (str): The name of the new decorator type. decorator: The constructor (class name) of the new node type. \"\"\" self . registry [ name ] = decorator self . node_counts [ name ] = 0 self . node_types [ name ] = NodeType . DECORATOR register_simple_action ( name , action_function ) Register a new simple action. Allows the specification of an action and a callback in one step. Parameters: Name Type Description Default name str The name of the new simple action node type. required action_function Callable A callback to execute each time this node is ticked. required Source code in src/dendron/behavior_tree_factory.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def register_simple_action ( self , name , action_function ) -> None : \"\"\" Register a new simple action. Allows the specification of an action and a callback in one step. Args: name (str): The name of the new simple action node type. action_function (Callable): A callback to execute each time this node is ticked. \"\"\" self . registry [ name ] = SimpleAction self . functors [ name ] = action_function self . node_counts [ name ] = 0 self . node_types [ name ] = NodeType . ACTION register_simple_condition ( name , condition_function ) Register a new simple condition. Allows the specification of a condition and a callback in one step. Parameters: Name Type Description Default name str The name of the simple condition node type. required condition_function Callable A callback to execute each time this node is ticked. required Source code in src/dendron/behavior_tree_factory.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def register_simple_condition ( self , name , condition_function ) -> None : \"\"\" Register a new simple condition. Allows the specification of a condition and a callback in one step. Args: name (str): The name of the simple condition node type. condition_function (Callable): A callback to execute each time this node is ticked. \"\"\" self . registry [ name ] = SimpleConditionNode self . functors [ name ] = condition_function self . node_counts [ name ] = 0 self . node_types [ name ] = NodeType . CONDITION create_from_groot ( xml_filename ) Create a BehaviorTree instance from an XML file generated by the open-source Groot2 program. Parameters: Name Type Description Default xml_filename `str` The name of the file containing the XML. required Returns: Type Description BehaviorTree BehaviorTree : A behavior tree that instantiates the structure BehaviorTree described in the XML file. Source code in src/dendron/behavior_tree_factory.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def create_from_groot ( self , xml_filename : str ) -> BehaviorTree : \"\"\" Create a `BehaviorTree` instance from an XML file generated by the open-source Groot2 program. Args: xml_filename (`str`): The name of the file containing the XML. Returns: `BehaviorTree`: A behavior tree that instantiates the structure described in the XML file. \"\"\" self . current_blackboard = Blackboard () xml_tree = ET . parse ( xml_filename ) xml_root = xml_tree . getroot () if not \"BTCPP_format\" in xml_root . attrib : raise RuntimeError ( \"XML missing BTCPP_format\" ) if xml_root . attrib [ \"BTCPP_format\" ] != \"4\" : raise RuntimeError ( \"BTCPP_format must be 4\" ) has_main_tree = \"main_tree_to_execute\" in xml_root . attrib main_tree_name = None if has_main_tree : main_tree_name = xml_root . attrib [ \"main_tree_to_execute\" ] tree_nodes_xml = None behavior_tree_xml = [] main_tree = None for child in xml_root : if child . tag == \"TreeNodesModel\" : tree_nodes_xml = child elif child . tag == \"BehaviorTree\" : if \"ID\" in child . attrib and child . attrib [ \"ID\" ] == main_tree_name : main_tree = child else : behavior_tree_xml . append ( child ) # load TreeNodesModel for child in tree_nodes_xml : match child . tag : case \"Action\" : self . node_types [ child . attrib [ \"ID\" ]] = NodeType . ACTION case \"Condition\" : self . node_types [ child . attrib [ \"ID\" ]] = NodeType . CONDITION case \"Control\" : self . node_types [ child . attrib [ \"ID\" ]] = NodeType . CONTROL case \"Decorator\" : self . node_types [ child . attrib [ \"ID\" ]] = NodeType . DECORATOR if not has_main_tree and len ( behavior_tree_xml ) > 1 : raise RuntimeError ( \"Multiple behavior trees but no main tree.\" ) if main_tree is None and len ( behavior_tree_xml ) == 1 : main_tree = behavior_tree_xml [ 0 ] # load each behavior tree ## convert the other trees parse_order = get_parse_order ( xml_root ) for tree_name in parse_order : if tree_name == main_tree_name : continue tree = None for child in xml_root : if child . tag != \"BehaviorTree\" : continue child_name = child . attrib [ \"ID\" ] if child_name != tree_name : continue else : tree = self . parse_behavior_tree_groot ( child_name , child ) self . behavior_trees [ tree_name ] = tree # parse the main tree last main_tree = self . parse_behavior_tree_groot ( main_tree . attrib [ \"ID\" ], main_tree ) self . behavior_trees [ main_tree_name ] = main_tree return main_tree","title":"BehaviorTreeFactory"},{"location":"api/behavior_tree_factory/#behaviortreefactory","text":"A factory for behavior trees. This allows the registration of new node types and the generation of BehaviorTree s from XML files. A factory maintains state that allows node repetition and subtree insertion to be automatically handled. Source code in src/dendron/behavior_tree_factory.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 class BehaviorTreeFactory : \"\"\" A factory for behavior trees. This allows the registration of new node types and the generation of `BehaviorTree`s from XML files. A factory maintains state that allows node repetition and subtree insertion to be automatically handled. \"\"\" def __init__ ( self ) -> None : self . registry = {} self . node_counts = {} self . node_types = {} self . functors = {} self . neural_configs = {} self . registry [ \"Fallback\" ] = FallbackNode self . registry [ \"Sequence\" ] = SequenceNode self . registry [ \"Inverter\" ] = InverterNode self . registry [ \"AlwaysSuccess\" ] = AlwaysSuccess self . registry [ \"AlwaysFailure\" ] = AlwaysFailure self . registry [ \"AsyncAction\" ] = AsyncAction self . registry [ \"CausalLMAction\" ] = CausalLMAction self . registry [ \"ImageLMAction\" ] = ImageLMAction self . registry [ \"PipelineAction\" ] = PipelineAction # We replace SubTree nodes with the subtree root, so # we use None as a placeholder here. self . registry [ \"SubTree\" ] = None self . node_counts [ \"Fallback\" ] = 0 self . node_counts [ \"Sequence\" ] = 0 self . node_counts [ \"Inverter\" ] = 0 self . node_counts [ \"AlwaysSuccess\" ] = 0 self . node_counts [ \"AlwaysFailure\" ] = 0 self . node_counts [ \"AsyncAction\" ] = 0 self . node_counts [ \"CausalLMAction\" ] = 0 self . node_counts [ \"ImageLMAction\" ] = 0 self . node_counts [ \"PipelineAction\" ] = 0 self . node_types [ \"Fallback\" ] = NodeType . CONTROL self . node_types [ \"Sequence\" ] = NodeType . CONTROL self . node_types [ \"Inverter\" ] = NodeType . DECORATOR self . node_types [ \"AlwaysSuccess\" ] = NodeType . ACTION self . node_types [ \"AlwaysFailure\" ] = NodeType . ACTION self . node_types [ \"AsyncAction\" ] = NodeType . ACTION self . node_types [ \"CausalLMAction\" ] = NodeType . ACTION self . node_types [ \"ImageLMAction\" ] = NodeType . ACTION self . node_types [ \"PipelineAction\" ] = NodeType . ACTION self . node_types [ \"SubTree\" ] = NodeType . SUBTREE self . current_blackboard = None self . tree_nodes_model = None self . behavior_trees = {} def register_neural_config ( self , name , cfg ) -> None : \"\"\" Register a configuration object for a neural network based node. Args: name (str): The name of the configuration object. This should match the name used in Groot. cfg: The configuration object. At present, one of `CausalLMActionConfig`, `ImageLMActionConfig`, `PipelineActionConfig`, or `CompletionConditionConfig`. \"\"\" self . neural_configs [ name ] = cfg def register_action_type ( self , name , action ) -> None : \"\"\" Register a new type of action node. Args: name (str): The name of the new action node type. action: The constructor (class name) of the new node type. \"\"\" self . registry [ name ] = action self . node_counts [ name ] = 0 self . node_types [ name ] = NodeType . ACTION def register_condition_type ( self , name , condition ) -> None : \"\"\" Register a new type of condition node. Args: name (str): The name of the new condition type. condition: The constructor (class name) of the new node type. \"\"\" self . registry [ name ] = condition self . node_counts [ name ] = 0 self . node_types [ name ] = NodeType . CONDITION def register_decorator_type ( self , name , decorator ) -> None : \"\"\" Register a new type of decorator node. Args: name (str): The name of the new decorator type. decorator: The constructor (class name) of the new node type. \"\"\" self . registry [ name ] = decorator self . node_counts [ name ] = 0 self . node_types [ name ] = NodeType . DECORATOR def register_simple_action ( self , name , action_function ) -> None : \"\"\" Register a new simple action. Allows the specification of an action and a callback in one step. Args: name (str): The name of the new simple action node type. action_function (Callable): A callback to execute each time this node is ticked. \"\"\" self . registry [ name ] = SimpleAction self . functors [ name ] = action_function self . node_counts [ name ] = 0 self . node_types [ name ] = NodeType . ACTION def register_simple_condition ( self , name , condition_function ) -> None : \"\"\" Register a new simple condition. Allows the specification of a condition and a callback in one step. Args: name (str): The name of the simple condition node type. condition_function (Callable): A callback to execute each time this node is ticked. \"\"\" self . registry [ name ] = SimpleConditionNode self . functors [ name ] = condition_function self . node_counts [ name ] = 0 self . node_types [ name ] = NodeType . CONDITION def create_from_groot ( self , xml_filename : str ) -> BehaviorTree : \"\"\" Create a `BehaviorTree` instance from an XML file generated by the open-source Groot2 program. Args: xml_filename (`str`): The name of the file containing the XML. Returns: `BehaviorTree`: A behavior tree that instantiates the structure described in the XML file. \"\"\" self . current_blackboard = Blackboard () xml_tree = ET . parse ( xml_filename ) xml_root = xml_tree . getroot () if not \"BTCPP_format\" in xml_root . attrib : raise RuntimeError ( \"XML missing BTCPP_format\" ) if xml_root . attrib [ \"BTCPP_format\" ] != \"4\" : raise RuntimeError ( \"BTCPP_format must be 4\" ) has_main_tree = \"main_tree_to_execute\" in xml_root . attrib main_tree_name = None if has_main_tree : main_tree_name = xml_root . attrib [ \"main_tree_to_execute\" ] tree_nodes_xml = None behavior_tree_xml = [] main_tree = None for child in xml_root : if child . tag == \"TreeNodesModel\" : tree_nodes_xml = child elif child . tag == \"BehaviorTree\" : if \"ID\" in child . attrib and child . attrib [ \"ID\" ] == main_tree_name : main_tree = child else : behavior_tree_xml . append ( child ) # load TreeNodesModel for child in tree_nodes_xml : match child . tag : case \"Action\" : self . node_types [ child . attrib [ \"ID\" ]] = NodeType . ACTION case \"Condition\" : self . node_types [ child . attrib [ \"ID\" ]] = NodeType . CONDITION case \"Control\" : self . node_types [ child . attrib [ \"ID\" ]] = NodeType . CONTROL case \"Decorator\" : self . node_types [ child . attrib [ \"ID\" ]] = NodeType . DECORATOR if not has_main_tree and len ( behavior_tree_xml ) > 1 : raise RuntimeError ( \"Multiple behavior trees but no main tree.\" ) if main_tree is None and len ( behavior_tree_xml ) == 1 : main_tree = behavior_tree_xml [ 0 ] # load each behavior tree ## convert the other trees parse_order = get_parse_order ( xml_root ) for tree_name in parse_order : if tree_name == main_tree_name : continue tree = None for child in xml_root : if child . tag != \"BehaviorTree\" : continue child_name = child . attrib [ \"ID\" ] if child_name != tree_name : continue else : tree = self . parse_behavior_tree_groot ( child_name , child ) self . behavior_trees [ tree_name ] = tree # parse the main tree last main_tree = self . parse_behavior_tree_groot ( main_tree . attrib [ \"ID\" ], main_tree ) self . behavior_trees [ main_tree_name ] = main_tree return main_tree def parse_behavior_tree_groot ( self , tree_name , xml_node ) -> BehaviorTree : tree_type = self . node_types [ xml_node [ 0 ] . tag ] root_node = None match tree_type : case NodeType . ACTION : root_node = self . parse_action_node_groot ( xml_node [ 0 ]) case NodeType . CONDITION : root_node = self . parse_condition_node_groot ( xml_node [ 0 ]) case NodeType . CONTROL : root_node = self . parse_control_node_groot ( xml_node [ 0 ]) case NodeType . DECORATOR : root_node = self . parse_decorator_node_groot ( xml_node [ 0 ]) case NodeType . SUBTREE : root_node = self . parse_subtree_node_groot ( xml_node [ 0 ]) bt = BehaviorTree ( tree_name , root_node ) return bt def parse_action_node_groot ( self , xml_node ) -> ActionNode : tag = xml_node . tag if not tag in self . registry : raise KeyError ( f \"Undefined action { tag } .\" ) node_id = self . node_counts [ tag ] node_name = tag + \"_\" + str ( node_id ) if self . registry [ tag ] == SimpleAction : f = self . functors [ tag ] new_node = self . registry [ tag ]( node_name , f ) else : new_node = self . registry [ tag ]( node_name ) self . node_counts [ tag ] += 1 if xml_node . attrib : for key in xml_node . attrib : self . current_blackboard [ key ] = xml_node . attrib [ key ] return new_node def parse_condition_node_groot ( self , xml_node ) -> ConditionNode : tag = xml_node . tag if not tag in self . registry : raise KeyError ( f \"Undefined condition { tag } .\" ) node_id = self . node_counts [ tag ] node_name = tag + \"_\" + str ( node_id ) if self . registry [ tag ] == SimpleConditionNode : f = self . functors [ tag ] new_node = self . registry [ tag ]( node_name , f ) else : new_node = self . registry [ tag ]( node_name ) self . node_counts [ tag ] += 1 if xml_node . attrib : for key in xml_node . attrib : self . current_blackboard [ key ] = xml_node . attrib [ key ] return new_node def parse_control_node_groot ( self , xml_node ) -> ControlNode : tag = xml_node . tag if not tag in self . registry : raise KeyError ( f \"Undefined control { tag } .\" ) node_id = self . node_counts [ tag ] node_name = tag + \"_\" + str ( node_id ) self . node_counts [ tag ] += 1 if xml_node . attrib : for key in xml_node . attrib : self . current_blackboard [ key ] = xml_node . attrib [ key ] # parse children child_nodes = [] for child_xml in xml_node : if not child_xml . tag in self . registry : raise RuntimeError ( f \"Unregistered node { child_xml . tag } \" ) match self . node_types [ child_xml . tag ]: case NodeType . ACTION : child_node = self . parse_action_node_groot ( child_xml ) case NodeType . CONDITION : child_node = self . parse_condition_node_groot ( child_xml ) case NodeType . CONTROL : child_node = self . parse_control_node_groot ( child_xml ) case NodeType . DECORATOR : child_node = self . parse_decorator_node_groot ( child_xml ) case NodeType . SUBTREE : child_node = self . parse_subtree_node_groot ( child_xml ) child_nodes . append ( child_node ) new_node = self . registry [ tag ]( node_name , child_nodes ) return new_node def parse_decorator_node_groot ( self , xml_node ) -> DecoratorNode : tag = xml_node . tag if not tag in self . registry : raise KeyError ( f \"Undefined decorator { tag } .\" ) node_id = self . node_counts [ tag ] node_name = tag + \"_\" + str ( node_id ) self . node_counts [ tag ] += 1 if xml_node . attrib : for key in xml_node . attrib : self . current_blackboard [ key ] = xml_node . attrib [ key ] child_node = None child_xml = xml_node [ 0 ] match self . node_types [ child_xml . tag ]: case NodeType . ACTION : child_node = self . parse_action_node_groot ( child_xml ) case NodeType . CONDITION : child_node = self . parse_condition_node_groot ( child_xml ) case NodeType . CONTROL : child_node = self . parse_control_node_groot ( child_xml ) case NodeType . DECORATOR : child_node = self . parse_decorator_node_groot ( child_xml ) case NodeType . SUBTREE : child_node = self . parse_subtree_node_groot ( child_xml ) new_node = self . registry [ tag ]( node_name , child_node ) return new_node def parse_subtree_node_groot ( self , xml_node ) -> TreeNode : subtree_name = xml_node . attrib [ \"ID\" ] # TODO is deepcopy good enough? return deepcopy ( self . behavior_trees [ subtree_name ] . root )","title":"BehaviorTreeFactory"},{"location":"api/behavior_tree_factory/#dendron.behavior_tree_factory.BehaviorTreeFactory.register_neural_config","text":"Register a configuration object for a neural network based node. Parameters: Name Type Description Default name str The name of the configuration object. This should match the name used in Groot. required cfg The configuration object. At present, one of CausalLMActionConfig , ImageLMActionConfig , PipelineActionConfig , or CompletionConditionConfig . required Source code in src/dendron/behavior_tree_factory.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def register_neural_config ( self , name , cfg ) -> None : \"\"\" Register a configuration object for a neural network based node. Args: name (str): The name of the configuration object. This should match the name used in Groot. cfg: The configuration object. At present, one of `CausalLMActionConfig`, `ImageLMActionConfig`, `PipelineActionConfig`, or `CompletionConditionConfig`. \"\"\" self . neural_configs [ name ] = cfg","title":"register_neural_config"},{"location":"api/behavior_tree_factory/#dendron.behavior_tree_factory.BehaviorTreeFactory.register_action_type","text":"Register a new type of action node. Parameters: Name Type Description Default name str The name of the new action node type. required action The constructor (class name) of the new node type. required Source code in src/dendron/behavior_tree_factory.py 97 98 99 100 101 102 103 104 105 106 107 108 109 def register_action_type ( self , name , action ) -> None : \"\"\" Register a new type of action node. Args: name (str): The name of the new action node type. action: The constructor (class name) of the new node type. \"\"\" self . registry [ name ] = action self . node_counts [ name ] = 0 self . node_types [ name ] = NodeType . ACTION","title":"register_action_type"},{"location":"api/behavior_tree_factory/#dendron.behavior_tree_factory.BehaviorTreeFactory.register_condition_type","text":"Register a new type of condition node. Parameters: Name Type Description Default name str The name of the new condition type. required condition The constructor (class name) of the new node type. required Source code in src/dendron/behavior_tree_factory.py 111 112 113 114 115 116 117 118 119 120 121 122 123 def register_condition_type ( self , name , condition ) -> None : \"\"\" Register a new type of condition node. Args: name (str): The name of the new condition type. condition: The constructor (class name) of the new node type. \"\"\" self . registry [ name ] = condition self . node_counts [ name ] = 0 self . node_types [ name ] = NodeType . CONDITION","title":"register_condition_type"},{"location":"api/behavior_tree_factory/#dendron.behavior_tree_factory.BehaviorTreeFactory.register_decorator_type","text":"Register a new type of decorator node. Parameters: Name Type Description Default name str The name of the new decorator type. required decorator The constructor (class name) of the new node type. required Source code in src/dendron/behavior_tree_factory.py 125 126 127 128 129 130 131 132 133 134 135 136 137 def register_decorator_type ( self , name , decorator ) -> None : \"\"\" Register a new type of decorator node. Args: name (str): The name of the new decorator type. decorator: The constructor (class name) of the new node type. \"\"\" self . registry [ name ] = decorator self . node_counts [ name ] = 0 self . node_types [ name ] = NodeType . DECORATOR","title":"register_decorator_type"},{"location":"api/behavior_tree_factory/#dendron.behavior_tree_factory.BehaviorTreeFactory.register_simple_action","text":"Register a new simple action. Allows the specification of an action and a callback in one step. Parameters: Name Type Description Default name str The name of the new simple action node type. required action_function Callable A callback to execute each time this node is ticked. required Source code in src/dendron/behavior_tree_factory.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def register_simple_action ( self , name , action_function ) -> None : \"\"\" Register a new simple action. Allows the specification of an action and a callback in one step. Args: name (str): The name of the new simple action node type. action_function (Callable): A callback to execute each time this node is ticked. \"\"\" self . registry [ name ] = SimpleAction self . functors [ name ] = action_function self . node_counts [ name ] = 0 self . node_types [ name ] = NodeType . ACTION","title":"register_simple_action"},{"location":"api/behavior_tree_factory/#dendron.behavior_tree_factory.BehaviorTreeFactory.register_simple_condition","text":"Register a new simple condition. Allows the specification of a condition and a callback in one step. Parameters: Name Type Description Default name str The name of the simple condition node type. required condition_function Callable A callback to execute each time this node is ticked. required Source code in src/dendron/behavior_tree_factory.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def register_simple_condition ( self , name , condition_function ) -> None : \"\"\" Register a new simple condition. Allows the specification of a condition and a callback in one step. Args: name (str): The name of the simple condition node type. condition_function (Callable): A callback to execute each time this node is ticked. \"\"\" self . registry [ name ] = SimpleConditionNode self . functors [ name ] = condition_function self . node_counts [ name ] = 0 self . node_types [ name ] = NodeType . CONDITION","title":"register_simple_condition"},{"location":"api/behavior_tree_factory/#dendron.behavior_tree_factory.BehaviorTreeFactory.create_from_groot","text":"Create a BehaviorTree instance from an XML file generated by the open-source Groot2 program. Parameters: Name Type Description Default xml_filename `str` The name of the file containing the XML. required Returns: Type Description BehaviorTree BehaviorTree : A behavior tree that instantiates the structure BehaviorTree described in the XML file. Source code in src/dendron/behavior_tree_factory.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def create_from_groot ( self , xml_filename : str ) -> BehaviorTree : \"\"\" Create a `BehaviorTree` instance from an XML file generated by the open-source Groot2 program. Args: xml_filename (`str`): The name of the file containing the XML. Returns: `BehaviorTree`: A behavior tree that instantiates the structure described in the XML file. \"\"\" self . current_blackboard = Blackboard () xml_tree = ET . parse ( xml_filename ) xml_root = xml_tree . getroot () if not \"BTCPP_format\" in xml_root . attrib : raise RuntimeError ( \"XML missing BTCPP_format\" ) if xml_root . attrib [ \"BTCPP_format\" ] != \"4\" : raise RuntimeError ( \"BTCPP_format must be 4\" ) has_main_tree = \"main_tree_to_execute\" in xml_root . attrib main_tree_name = None if has_main_tree : main_tree_name = xml_root . attrib [ \"main_tree_to_execute\" ] tree_nodes_xml = None behavior_tree_xml = [] main_tree = None for child in xml_root : if child . tag == \"TreeNodesModel\" : tree_nodes_xml = child elif child . tag == \"BehaviorTree\" : if \"ID\" in child . attrib and child . attrib [ \"ID\" ] == main_tree_name : main_tree = child else : behavior_tree_xml . append ( child ) # load TreeNodesModel for child in tree_nodes_xml : match child . tag : case \"Action\" : self . node_types [ child . attrib [ \"ID\" ]] = NodeType . ACTION case \"Condition\" : self . node_types [ child . attrib [ \"ID\" ]] = NodeType . CONDITION case \"Control\" : self . node_types [ child . attrib [ \"ID\" ]] = NodeType . CONTROL case \"Decorator\" : self . node_types [ child . attrib [ \"ID\" ]] = NodeType . DECORATOR if not has_main_tree and len ( behavior_tree_xml ) > 1 : raise RuntimeError ( \"Multiple behavior trees but no main tree.\" ) if main_tree is None and len ( behavior_tree_xml ) == 1 : main_tree = behavior_tree_xml [ 0 ] # load each behavior tree ## convert the other trees parse_order = get_parse_order ( xml_root ) for tree_name in parse_order : if tree_name == main_tree_name : continue tree = None for child in xml_root : if child . tag != \"BehaviorTree\" : continue child_name = child . attrib [ \"ID\" ] if child_name != tree_name : continue else : tree = self . parse_behavior_tree_groot ( child_name , child ) self . behavior_trees [ tree_name ] = tree # parse the main tree last main_tree = self . parse_behavior_tree_groot ( main_tree . attrib [ \"ID\" ], main_tree ) self . behavior_trees [ main_tree_name ] = main_tree return main_tree","title":"create_from_groot"},{"location":"api/blackboard/","text":"Blackboard A blackboard for a Behavior Tree. Implements a key-value mapping that is accessible by all of the nodes in a behavior tree. Source code in src/dendron/blackboard.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class Blackboard : \"\"\" A blackboard for a Behavior Tree. Implements a key-value mapping that is accessible by all of the nodes in a behavior tree. \"\"\" def __init__ ( self ) -> None : self . entry_mapping = {} self . value_mapping = {} self . print_len = 16 def set_print_len ( self , new_len : int ) -> None : \"\"\" Set the width of the columns for printing this blackboard. Args: new_len (`int`): The new column width for printing. \"\"\" if new_len <= 0 : raise ValueError ( \"print length must be positive\" ) self . print_len = new_len for key , entry in self . entry_mapping . items (): entry . print_len = new_len def register_entry ( self , entry : BlackboardEntryMetadata ) -> None : \"\"\" Register a new metadata entry for this blackboard. Primarily useful for specfying a type constructor to use with values that go with a certain key. Args: entry (`dendron.blackboard.BlackboardEntryMetadata`): The entry to register. \"\"\" self . entry_mapping [ entry . key ] = entry def get_entry ( self , key : Any ) -> Any : \"\"\" Return the value associated with the given key. Args: key (`Any`): Key to query on. Usually a `str`. \"\"\" return self . entry_mapping [ key ] def set_entry ( self , key : Any , description : Optional [ str ] = None , type_constructor : Optional [ Type ] = None ) -> None : \"\"\" Set the metadata for a particular key in anticipation of future values. Args: key (`Any`): Key to query on. Usually a `str`. description (`Optional[str`]): An optional human-readable description of the key-value pair. type_constructor (`Type`): An optional type constructor to convert data upon reading. \"\"\" if not key in self . entry_mapping . keys (): raise KeyError ( f \" { new_entry . key } not in blackboard.\" ) old_entry = self . entry_mapping [ key ] new_entry = deepcopy ( old_entry ) if description is not None : new_entry . description = description if type_constructor is not None : new_entry . type_constructor = type_constructor self . entry_mapping [ key ] = new_entry def __getitem__ ( self , key : Any ) -> Any : \"\"\" Get the value associated with the given key. Args: key (`Any`): The key we want the value for. Returns: `Any` : The value in the blackboard corresponding to `key`. \"\"\" if not key in self . entry_mapping . keys (): raise KeyError ( f \"Entry { key } not in blackboard.\" ) target_type = self . entry_mapping [ key ] . type_constructor temp_value = self . value_mapping [ key ] if type ( temp_value ) != target_type : return target_type ( temp_value ) else : return self . value_mapping [ key ] def get ( self , key : Any ) -> Any : \"\"\" Get the value associated with the given key. Args: key (`Any`): The key we want the value for. Returns: `Any` : The value in the blackboard corresponding to `key`. \"\"\" return self . __getitem__ ( key ) def __delitem__ ( self , key : Any ) -> None : \"\"\" Delete an entry from the blackboard. Args: key (`Any`): The key we want to remove from the blackboard. \"\"\" del self . value_mapping [ key ] del self . entry_mapping [ key ] def __setitem__ ( self , key : Any , value : Any ) -> None : \"\"\" Add a key-value pair to the blackboard. If `key` is not already in the Args: key (`Any`): Key to query on. Usually a `str`. value (`Any`): The value that `key` maps to. \"\"\" if key not in self . entry_mapping . keys (): new_entry = BlackboardEntryMetadata ( key , \"Autogenerated entry\" , type ( value )) self . register_entry ( new_entry ) self . value_mapping [ key ] = value def set ( self , key : Any , value : Any ) -> None : \"\"\" Add a key-value pair to the blackboard. Wrapper around __setitem__. \"\"\" self . __setitem__ ( key , value ) def __iter__ ( self ) -> Iterator : \"\"\" Get an iterator over key-value pairs. Returns: `Iterator`: The iterator over the value dict. \"\"\" return iter ( self . value_mapping ) def __len__ ( self ) -> int : \"\"\" Get the number of key-value pairs in the blackboard. Returns: `int`: The number of key-value pairs. \"\"\" return len ( self . value_mapping ) def __str__ ( self ) -> str : \"\"\" Get a tabular representation of this blackboard in a `str`. Returns: `str`: A string that prints as a table of keys and values. \"\"\" key_header_field = f \" { 'Key' :{ self . print_len } . { self . print_len }} \" desc_header_field = f \" { 'Description' :{ self . print_len } . { self . print_len }} \" type_header_field = f \" { 'Type' :{ self . print_len } . { self . print_len }} \" value_header_field = f \" { 'Value' :{ self . print_len } . { self . print_len }} \" bb_str = f \" { key_header_field } | { desc_header_field } | { type_header_field } | { value_header_field } | \\n \" bb_str += f \" { '=' * ( self . print_len * 4 + 11 ) } \\n \" for key , value in self . value_mapping . items (): entry = self . entry_mapping [ key ] value_string = str ( value ) value_field = f \" { value_string :{ self . print_len } . { self . print_len }} \" bb_str += f \" { str ( entry ) } | { value_field } | \\n \" return bb_str __delitem__ ( key ) Delete an entry from the blackboard. Parameters: Name Type Description Default key `Any` The key we want to remove from the blackboard. required Source code in src/dendron/blackboard.py 126 127 128 129 130 131 132 133 134 135 def __delitem__ ( self , key : Any ) -> None : \"\"\" Delete an entry from the blackboard. Args: key (`Any`): The key we want to remove from the blackboard. \"\"\" del self . value_mapping [ key ] del self . entry_mapping [ key ] __getitem__ ( key ) Get the value associated with the given key. Parameters: Name Type Description Default key `Any` The key we want the value for. required Returns: Type Description Any Any : The value in the blackboard corresponding to key . Source code in src/dendron/blackboard.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def __getitem__ ( self , key : Any ) -> Any : \"\"\" Get the value associated with the given key. Args: key (`Any`): The key we want the value for. Returns: `Any` : The value in the blackboard corresponding to `key`. \"\"\" if not key in self . entry_mapping . keys (): raise KeyError ( f \"Entry { key } not in blackboard.\" ) target_type = self . entry_mapping [ key ] . type_constructor temp_value = self . value_mapping [ key ] if type ( temp_value ) != target_type : return target_type ( temp_value ) else : return self . value_mapping [ key ] __iter__ () Get an iterator over key-value pairs. Returns: Type Description Iterator Iterator : The iterator over the value dict. Source code in src/dendron/blackboard.py 160 161 162 163 164 165 166 167 def __iter__ ( self ) -> Iterator : \"\"\" Get an iterator over key-value pairs. Returns: `Iterator`: The iterator over the value dict. \"\"\" return iter ( self . value_mapping ) __len__ () Get the number of key-value pairs in the blackboard. Returns: Type Description int int : The number of key-value pairs. Source code in src/dendron/blackboard.py 169 170 171 172 173 174 175 176 def __len__ ( self ) -> int : \"\"\" Get the number of key-value pairs in the blackboard. Returns: `int`: The number of key-value pairs. \"\"\" return len ( self . value_mapping ) __setitem__ ( key , value ) Add a key-value pair to the blackboard. If key is not already in the Parameters: Name Type Description Default key `Any` Key to query on. Usually a str . required value `Any` The value that key maps to. required Source code in src/dendron/blackboard.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def __setitem__ ( self , key : Any , value : Any ) -> None : \"\"\" Add a key-value pair to the blackboard. If `key` is not already in the Args: key (`Any`): Key to query on. Usually a `str`. value (`Any`): The value that `key` maps to. \"\"\" if key not in self . entry_mapping . keys (): new_entry = BlackboardEntryMetadata ( key , \"Autogenerated entry\" , type ( value )) self . register_entry ( new_entry ) self . value_mapping [ key ] = value __str__ () Get a tabular representation of this blackboard in a str . Returns: Type Description str str : A string that prints as a table of keys and values. Source code in src/dendron/blackboard.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def __str__ ( self ) -> str : \"\"\" Get a tabular representation of this blackboard in a `str`. Returns: `str`: A string that prints as a table of keys and values. \"\"\" key_header_field = f \" { 'Key' :{ self . print_len } . { self . print_len }} \" desc_header_field = f \" { 'Description' :{ self . print_len } . { self . print_len }} \" type_header_field = f \" { 'Type' :{ self . print_len } . { self . print_len }} \" value_header_field = f \" { 'Value' :{ self . print_len } . { self . print_len }} \" bb_str = f \" { key_header_field } | { desc_header_field } | { type_header_field } | { value_header_field } | \\n \" bb_str += f \" { '=' * ( self . print_len * 4 + 11 ) } \\n \" for key , value in self . value_mapping . items (): entry = self . entry_mapping [ key ] value_string = str ( value ) value_field = f \" { value_string :{ self . print_len } . { self . print_len }} \" bb_str += f \" { str ( entry ) } | { value_field } | \\n \" return bb_str get ( key ) Get the value associated with the given key. Parameters: Name Type Description Default key `Any` The key we want the value for. required Returns: Type Description Any Any : The value in the blackboard corresponding to key . Source code in src/dendron/blackboard.py 113 114 115 116 117 118 119 120 121 122 123 124 def get ( self , key : Any ) -> Any : \"\"\" Get the value associated with the given key. Args: key (`Any`): The key we want the value for. Returns: `Any` : The value in the blackboard corresponding to `key`. \"\"\" return self . __getitem__ ( key ) get_entry ( key ) Return the value associated with the given key. Parameters: Name Type Description Default key `Any` Key to query on. Usually a str . required Source code in src/dendron/blackboard.py 60 61 62 63 64 65 66 67 68 def get_entry ( self , key : Any ) -> Any : \"\"\" Return the value associated with the given key. Args: key (`Any`): Key to query on. Usually a `str`. \"\"\" return self . entry_mapping [ key ] register_entry ( entry ) Register a new metadata entry for this blackboard. Primarily useful for specfying a type constructor to use with values that go with a certain key. Parameters: Name Type Description Default entry `dendron.blackboard.BlackboardEntryMetadata` The entry to register. required Source code in src/dendron/blackboard.py 48 49 50 51 52 53 54 55 56 57 58 def register_entry ( self , entry : BlackboardEntryMetadata ) -> None : \"\"\" Register a new metadata entry for this blackboard. Primarily useful for specfying a type constructor to use with values that go with a certain key. Args: entry (`dendron.blackboard.BlackboardEntryMetadata`): The entry to register. \"\"\" self . entry_mapping [ entry . key ] = entry set ( key , value ) Add a key-value pair to the blackboard. Wrapper around setitem . Source code in src/dendron/blackboard.py 153 154 155 156 157 158 def set ( self , key : Any , value : Any ) -> None : \"\"\" Add a key-value pair to the blackboard. Wrapper around __setitem__. \"\"\" self . __setitem__ ( key , value ) set_entry ( key , description = None , type_constructor = None ) Set the metadata for a particular key in anticipation of future values. Parameters: Name Type Description Default key `Any` Key to query on. Usually a str . required description `Optional[str`] An optional human-readable description of the key-value pair. None type_constructor `Type` An optional type constructor to convert data upon reading. None Source code in src/dendron/blackboard.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def set_entry ( self , key : Any , description : Optional [ str ] = None , type_constructor : Optional [ Type ] = None ) -> None : \"\"\" Set the metadata for a particular key in anticipation of future values. Args: key (`Any`): Key to query on. Usually a `str`. description (`Optional[str`]): An optional human-readable description of the key-value pair. type_constructor (`Type`): An optional type constructor to convert data upon reading. \"\"\" if not key in self . entry_mapping . keys (): raise KeyError ( f \" { new_entry . key } not in blackboard.\" ) old_entry = self . entry_mapping [ key ] new_entry = deepcopy ( old_entry ) if description is not None : new_entry . description = description if type_constructor is not None : new_entry . type_constructor = type_constructor self . entry_mapping [ key ] = new_entry set_print_len ( new_len ) Set the width of the columns for printing this blackboard. Parameters: Name Type Description Default new_len `int` The new column width for printing. required Source code in src/dendron/blackboard.py 34 35 36 37 38 39 40 41 42 43 44 45 46 def set_print_len ( self , new_len : int ) -> None : \"\"\" Set the width of the columns for printing this blackboard. Args: new_len (`int`): The new column width for printing. \"\"\" if new_len <= 0 : raise ValueError ( \"print length must be positive\" ) self . print_len = new_len for key , entry in self . entry_mapping . items (): entry . print_len = new_len","title":"Blackboard"},{"location":"api/blackboard/#blackboard","text":"A blackboard for a Behavior Tree. Implements a key-value mapping that is accessible by all of the nodes in a behavior tree. Source code in src/dendron/blackboard.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class Blackboard : \"\"\" A blackboard for a Behavior Tree. Implements a key-value mapping that is accessible by all of the nodes in a behavior tree. \"\"\" def __init__ ( self ) -> None : self . entry_mapping = {} self . value_mapping = {} self . print_len = 16 def set_print_len ( self , new_len : int ) -> None : \"\"\" Set the width of the columns for printing this blackboard. Args: new_len (`int`): The new column width for printing. \"\"\" if new_len <= 0 : raise ValueError ( \"print length must be positive\" ) self . print_len = new_len for key , entry in self . entry_mapping . items (): entry . print_len = new_len def register_entry ( self , entry : BlackboardEntryMetadata ) -> None : \"\"\" Register a new metadata entry for this blackboard. Primarily useful for specfying a type constructor to use with values that go with a certain key. Args: entry (`dendron.blackboard.BlackboardEntryMetadata`): The entry to register. \"\"\" self . entry_mapping [ entry . key ] = entry def get_entry ( self , key : Any ) -> Any : \"\"\" Return the value associated with the given key. Args: key (`Any`): Key to query on. Usually a `str`. \"\"\" return self . entry_mapping [ key ] def set_entry ( self , key : Any , description : Optional [ str ] = None , type_constructor : Optional [ Type ] = None ) -> None : \"\"\" Set the metadata for a particular key in anticipation of future values. Args: key (`Any`): Key to query on. Usually a `str`. description (`Optional[str`]): An optional human-readable description of the key-value pair. type_constructor (`Type`): An optional type constructor to convert data upon reading. \"\"\" if not key in self . entry_mapping . keys (): raise KeyError ( f \" { new_entry . key } not in blackboard.\" ) old_entry = self . entry_mapping [ key ] new_entry = deepcopy ( old_entry ) if description is not None : new_entry . description = description if type_constructor is not None : new_entry . type_constructor = type_constructor self . entry_mapping [ key ] = new_entry def __getitem__ ( self , key : Any ) -> Any : \"\"\" Get the value associated with the given key. Args: key (`Any`): The key we want the value for. Returns: `Any` : The value in the blackboard corresponding to `key`. \"\"\" if not key in self . entry_mapping . keys (): raise KeyError ( f \"Entry { key } not in blackboard.\" ) target_type = self . entry_mapping [ key ] . type_constructor temp_value = self . value_mapping [ key ] if type ( temp_value ) != target_type : return target_type ( temp_value ) else : return self . value_mapping [ key ] def get ( self , key : Any ) -> Any : \"\"\" Get the value associated with the given key. Args: key (`Any`): The key we want the value for. Returns: `Any` : The value in the blackboard corresponding to `key`. \"\"\" return self . __getitem__ ( key ) def __delitem__ ( self , key : Any ) -> None : \"\"\" Delete an entry from the blackboard. Args: key (`Any`): The key we want to remove from the blackboard. \"\"\" del self . value_mapping [ key ] del self . entry_mapping [ key ] def __setitem__ ( self , key : Any , value : Any ) -> None : \"\"\" Add a key-value pair to the blackboard. If `key` is not already in the Args: key (`Any`): Key to query on. Usually a `str`. value (`Any`): The value that `key` maps to. \"\"\" if key not in self . entry_mapping . keys (): new_entry = BlackboardEntryMetadata ( key , \"Autogenerated entry\" , type ( value )) self . register_entry ( new_entry ) self . value_mapping [ key ] = value def set ( self , key : Any , value : Any ) -> None : \"\"\" Add a key-value pair to the blackboard. Wrapper around __setitem__. \"\"\" self . __setitem__ ( key , value ) def __iter__ ( self ) -> Iterator : \"\"\" Get an iterator over key-value pairs. Returns: `Iterator`: The iterator over the value dict. \"\"\" return iter ( self . value_mapping ) def __len__ ( self ) -> int : \"\"\" Get the number of key-value pairs in the blackboard. Returns: `int`: The number of key-value pairs. \"\"\" return len ( self . value_mapping ) def __str__ ( self ) -> str : \"\"\" Get a tabular representation of this blackboard in a `str`. Returns: `str`: A string that prints as a table of keys and values. \"\"\" key_header_field = f \" { 'Key' :{ self . print_len } . { self . print_len }} \" desc_header_field = f \" { 'Description' :{ self . print_len } . { self . print_len }} \" type_header_field = f \" { 'Type' :{ self . print_len } . { self . print_len }} \" value_header_field = f \" { 'Value' :{ self . print_len } . { self . print_len }} \" bb_str = f \" { key_header_field } | { desc_header_field } | { type_header_field } | { value_header_field } | \\n \" bb_str += f \" { '=' * ( self . print_len * 4 + 11 ) } \\n \" for key , value in self . value_mapping . items (): entry = self . entry_mapping [ key ] value_string = str ( value ) value_field = f \" { value_string :{ self . print_len } . { self . print_len }} \" bb_str += f \" { str ( entry ) } | { value_field } | \\n \" return bb_str","title":"Blackboard"},{"location":"api/blackboard/#dendron.blackboard.Blackboard.__delitem__","text":"Delete an entry from the blackboard. Parameters: Name Type Description Default key `Any` The key we want to remove from the blackboard. required Source code in src/dendron/blackboard.py 126 127 128 129 130 131 132 133 134 135 def __delitem__ ( self , key : Any ) -> None : \"\"\" Delete an entry from the blackboard. Args: key (`Any`): The key we want to remove from the blackboard. \"\"\" del self . value_mapping [ key ] del self . entry_mapping [ key ]","title":"__delitem__"},{"location":"api/blackboard/#dendron.blackboard.Blackboard.__getitem__","text":"Get the value associated with the given key. Parameters: Name Type Description Default key `Any` The key we want the value for. required Returns: Type Description Any Any : The value in the blackboard corresponding to key . Source code in src/dendron/blackboard.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def __getitem__ ( self , key : Any ) -> Any : \"\"\" Get the value associated with the given key. Args: key (`Any`): The key we want the value for. Returns: `Any` : The value in the blackboard corresponding to `key`. \"\"\" if not key in self . entry_mapping . keys (): raise KeyError ( f \"Entry { key } not in blackboard.\" ) target_type = self . entry_mapping [ key ] . type_constructor temp_value = self . value_mapping [ key ] if type ( temp_value ) != target_type : return target_type ( temp_value ) else : return self . value_mapping [ key ]","title":"__getitem__"},{"location":"api/blackboard/#dendron.blackboard.Blackboard.__iter__","text":"Get an iterator over key-value pairs. Returns: Type Description Iterator Iterator : The iterator over the value dict. Source code in src/dendron/blackboard.py 160 161 162 163 164 165 166 167 def __iter__ ( self ) -> Iterator : \"\"\" Get an iterator over key-value pairs. Returns: `Iterator`: The iterator over the value dict. \"\"\" return iter ( self . value_mapping )","title":"__iter__"},{"location":"api/blackboard/#dendron.blackboard.Blackboard.__len__","text":"Get the number of key-value pairs in the blackboard. Returns: Type Description int int : The number of key-value pairs. Source code in src/dendron/blackboard.py 169 170 171 172 173 174 175 176 def __len__ ( self ) -> int : \"\"\" Get the number of key-value pairs in the blackboard. Returns: `int`: The number of key-value pairs. \"\"\" return len ( self . value_mapping )","title":"__len__"},{"location":"api/blackboard/#dendron.blackboard.Blackboard.__setitem__","text":"Add a key-value pair to the blackboard. If key is not already in the Parameters: Name Type Description Default key `Any` Key to query on. Usually a str . required value `Any` The value that key maps to. required Source code in src/dendron/blackboard.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def __setitem__ ( self , key : Any , value : Any ) -> None : \"\"\" Add a key-value pair to the blackboard. If `key` is not already in the Args: key (`Any`): Key to query on. Usually a `str`. value (`Any`): The value that `key` maps to. \"\"\" if key not in self . entry_mapping . keys (): new_entry = BlackboardEntryMetadata ( key , \"Autogenerated entry\" , type ( value )) self . register_entry ( new_entry ) self . value_mapping [ key ] = value","title":"__setitem__"},{"location":"api/blackboard/#dendron.blackboard.Blackboard.__str__","text":"Get a tabular representation of this blackboard in a str . Returns: Type Description str str : A string that prints as a table of keys and values. Source code in src/dendron/blackboard.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def __str__ ( self ) -> str : \"\"\" Get a tabular representation of this blackboard in a `str`. Returns: `str`: A string that prints as a table of keys and values. \"\"\" key_header_field = f \" { 'Key' :{ self . print_len } . { self . print_len }} \" desc_header_field = f \" { 'Description' :{ self . print_len } . { self . print_len }} \" type_header_field = f \" { 'Type' :{ self . print_len } . { self . print_len }} \" value_header_field = f \" { 'Value' :{ self . print_len } . { self . print_len }} \" bb_str = f \" { key_header_field } | { desc_header_field } | { type_header_field } | { value_header_field } | \\n \" bb_str += f \" { '=' * ( self . print_len * 4 + 11 ) } \\n \" for key , value in self . value_mapping . items (): entry = self . entry_mapping [ key ] value_string = str ( value ) value_field = f \" { value_string :{ self . print_len } . { self . print_len }} \" bb_str += f \" { str ( entry ) } | { value_field } | \\n \" return bb_str","title":"__str__"},{"location":"api/blackboard/#dendron.blackboard.Blackboard.get","text":"Get the value associated with the given key. Parameters: Name Type Description Default key `Any` The key we want the value for. required Returns: Type Description Any Any : The value in the blackboard corresponding to key . Source code in src/dendron/blackboard.py 113 114 115 116 117 118 119 120 121 122 123 124 def get ( self , key : Any ) -> Any : \"\"\" Get the value associated with the given key. Args: key (`Any`): The key we want the value for. Returns: `Any` : The value in the blackboard corresponding to `key`. \"\"\" return self . __getitem__ ( key )","title":"get"},{"location":"api/blackboard/#dendron.blackboard.Blackboard.get_entry","text":"Return the value associated with the given key. Parameters: Name Type Description Default key `Any` Key to query on. Usually a str . required Source code in src/dendron/blackboard.py 60 61 62 63 64 65 66 67 68 def get_entry ( self , key : Any ) -> Any : \"\"\" Return the value associated with the given key. Args: key (`Any`): Key to query on. Usually a `str`. \"\"\" return self . entry_mapping [ key ]","title":"get_entry"},{"location":"api/blackboard/#dendron.blackboard.Blackboard.register_entry","text":"Register a new metadata entry for this blackboard. Primarily useful for specfying a type constructor to use with values that go with a certain key. Parameters: Name Type Description Default entry `dendron.blackboard.BlackboardEntryMetadata` The entry to register. required Source code in src/dendron/blackboard.py 48 49 50 51 52 53 54 55 56 57 58 def register_entry ( self , entry : BlackboardEntryMetadata ) -> None : \"\"\" Register a new metadata entry for this blackboard. Primarily useful for specfying a type constructor to use with values that go with a certain key. Args: entry (`dendron.blackboard.BlackboardEntryMetadata`): The entry to register. \"\"\" self . entry_mapping [ entry . key ] = entry","title":"register_entry"},{"location":"api/blackboard/#dendron.blackboard.Blackboard.set","text":"Add a key-value pair to the blackboard. Wrapper around setitem . Source code in src/dendron/blackboard.py 153 154 155 156 157 158 def set ( self , key : Any , value : Any ) -> None : \"\"\" Add a key-value pair to the blackboard. Wrapper around __setitem__. \"\"\" self . __setitem__ ( key , value )","title":"set"},{"location":"api/blackboard/#dendron.blackboard.Blackboard.set_entry","text":"Set the metadata for a particular key in anticipation of future values. Parameters: Name Type Description Default key `Any` Key to query on. Usually a str . required description `Optional[str`] An optional human-readable description of the key-value pair. None type_constructor `Type` An optional type constructor to convert data upon reading. None Source code in src/dendron/blackboard.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def set_entry ( self , key : Any , description : Optional [ str ] = None , type_constructor : Optional [ Type ] = None ) -> None : \"\"\" Set the metadata for a particular key in anticipation of future values. Args: key (`Any`): Key to query on. Usually a `str`. description (`Optional[str`]): An optional human-readable description of the key-value pair. type_constructor (`Type`): An optional type constructor to convert data upon reading. \"\"\" if not key in self . entry_mapping . keys (): raise KeyError ( f \" { new_entry . key } not in blackboard.\" ) old_entry = self . entry_mapping [ key ] new_entry = deepcopy ( old_entry ) if description is not None : new_entry . description = description if type_constructor is not None : new_entry . type_constructor = type_constructor self . entry_mapping [ key ] = new_entry","title":"set_entry"},{"location":"api/blackboard/#dendron.blackboard.Blackboard.set_print_len","text":"Set the width of the columns for printing this blackboard. Parameters: Name Type Description Default new_len `int` The new column width for printing. required Source code in src/dendron/blackboard.py 34 35 36 37 38 39 40 41 42 43 44 45 46 def set_print_len ( self , new_len : int ) -> None : \"\"\" Set the width of the columns for printing this blackboard. Args: new_len (`int`): The new column width for printing. \"\"\" if new_len <= 0 : raise ValueError ( \"print length must be positive\" ) self . print_len = new_len for key , entry in self . entry_mapping . items (): entry . print_len = new_len","title":"set_print_len"},{"location":"api/condition_node/","text":"ConditionNode Bases: TreeNode A condition node is a node that always must return either SUCCESS or FAILURE - it can never be left in a RUNNING state. Such nodes are intended to model boolean conditions (hence the name). ConditionNode s are one of the two kinds of leaf nodes in a Behavior Tree - the other being the ActionNode . Parameters: Name Type Description Default name `str` The given name of this node. required Source code in src/dendron/condition_node.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class ConditionNode ( TreeNode ): \"\"\" A condition node is a node that always *must* return either `SUCCESS` or `FAILURE` - it can never be left in a `RUNNING` state. Such nodes are intended to model boolean conditions (hence the name). `ConditionNode`s are one of the two kinds of leaf nodes in a Behavior Tree - the other being the `ActionNode`. Args: name (`str`): The given name of this node. \"\"\" def __init__ ( self , name ) -> None : super () . __init__ ( name ) def set_logger ( self , new_logger ) -> None : \"\"\" Set the logger for this node. \"\"\" self . logger = new_logger def set_log_level ( self , new_level ) -> None : \"\"\" Set the log level for this node. \"\"\" self . log_level = new_level def node_type ( self ) -> NodeType : \"\"\" Get the type of this node. Returns: `NodeType`: The type (`CONDITION`). \"\"\" return NodeType . CONDITION def get_node_by_name ( self , name : str ) -> Optional [ TreeNode ]: \"\"\" Search for a node by its name. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" if self . name == name : return self else : return None def pretty_repr ( self , depth = 0 ) -> str : \"\"\" Return a string representation of this node at the given depth. Args: depth (`int`): The depth of this node in a surrounding tree. Returns: `str`: The indented string representation. \"\"\" tabs = ' \\t ' * depth repr = f \" { tabs } Condition { self . name } \" return repr get_node_by_name ( name ) Search for a node by its name. Parameters: Name Type Description Default name `str` The name of the node we are looking for. required Returns: Type Description Optional [ TreeNode ] Optional[TreeNode] : Either a node with the given name, Optional [ TreeNode ] or None. Source code in src/dendron/condition_node.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def get_node_by_name ( self , name : str ) -> Optional [ TreeNode ]: \"\"\" Search for a node by its name. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" if self . name == name : return self else : return None node_type () Get the type of this node. Returns: Type Description NodeType NodeType : The type ( CONDITION ). Source code in src/dendron/condition_node.py 37 38 39 40 41 42 43 44 def node_type ( self ) -> NodeType : \"\"\" Get the type of this node. Returns: `NodeType`: The type (`CONDITION`). \"\"\" return NodeType . CONDITION pretty_repr ( depth = 0 ) Return a string representation of this node at the given depth. Parameters: Name Type Description Default depth `int` The depth of this node in a surrounding tree. 0 Returns: Type Description str str : The indented string representation. Source code in src/dendron/condition_node.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def pretty_repr ( self , depth = 0 ) -> str : \"\"\" Return a string representation of this node at the given depth. Args: depth (`int`): The depth of this node in a surrounding tree. Returns: `str`: The indented string representation. \"\"\" tabs = ' \\t ' * depth repr = f \" { tabs } Condition { self . name } \" return repr set_log_level ( new_level ) Set the log level for this node. Source code in src/dendron/condition_node.py 31 32 33 34 35 def set_log_level ( self , new_level ) -> None : \"\"\" Set the log level for this node. \"\"\" self . log_level = new_level set_logger ( new_logger ) Set the logger for this node. Source code in src/dendron/condition_node.py 25 26 27 28 29 def set_logger ( self , new_logger ) -> None : \"\"\" Set the logger for this node. \"\"\" self . logger = new_logger","title":"ConditionNode"},{"location":"api/condition_node/#conditionnode","text":"Bases: TreeNode A condition node is a node that always must return either SUCCESS or FAILURE - it can never be left in a RUNNING state. Such nodes are intended to model boolean conditions (hence the name). ConditionNode s are one of the two kinds of leaf nodes in a Behavior Tree - the other being the ActionNode . Parameters: Name Type Description Default name `str` The given name of this node. required Source code in src/dendron/condition_node.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class ConditionNode ( TreeNode ): \"\"\" A condition node is a node that always *must* return either `SUCCESS` or `FAILURE` - it can never be left in a `RUNNING` state. Such nodes are intended to model boolean conditions (hence the name). `ConditionNode`s are one of the two kinds of leaf nodes in a Behavior Tree - the other being the `ActionNode`. Args: name (`str`): The given name of this node. \"\"\" def __init__ ( self , name ) -> None : super () . __init__ ( name ) def set_logger ( self , new_logger ) -> None : \"\"\" Set the logger for this node. \"\"\" self . logger = new_logger def set_log_level ( self , new_level ) -> None : \"\"\" Set the log level for this node. \"\"\" self . log_level = new_level def node_type ( self ) -> NodeType : \"\"\" Get the type of this node. Returns: `NodeType`: The type (`CONDITION`). \"\"\" return NodeType . CONDITION def get_node_by_name ( self , name : str ) -> Optional [ TreeNode ]: \"\"\" Search for a node by its name. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" if self . name == name : return self else : return None def pretty_repr ( self , depth = 0 ) -> str : \"\"\" Return a string representation of this node at the given depth. Args: depth (`int`): The depth of this node in a surrounding tree. Returns: `str`: The indented string representation. \"\"\" tabs = ' \\t ' * depth repr = f \" { tabs } Condition { self . name } \" return repr","title":"ConditionNode"},{"location":"api/condition_node/#dendron.condition_node.ConditionNode.get_node_by_name","text":"Search for a node by its name. Parameters: Name Type Description Default name `str` The name of the node we are looking for. required Returns: Type Description Optional [ TreeNode ] Optional[TreeNode] : Either a node with the given name, Optional [ TreeNode ] or None. Source code in src/dendron/condition_node.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def get_node_by_name ( self , name : str ) -> Optional [ TreeNode ]: \"\"\" Search for a node by its name. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" if self . name == name : return self else : return None","title":"get_node_by_name"},{"location":"api/condition_node/#dendron.condition_node.ConditionNode.node_type","text":"Get the type of this node. Returns: Type Description NodeType NodeType : The type ( CONDITION ). Source code in src/dendron/condition_node.py 37 38 39 40 41 42 43 44 def node_type ( self ) -> NodeType : \"\"\" Get the type of this node. Returns: `NodeType`: The type (`CONDITION`). \"\"\" return NodeType . CONDITION","title":"node_type"},{"location":"api/condition_node/#dendron.condition_node.ConditionNode.pretty_repr","text":"Return a string representation of this node at the given depth. Parameters: Name Type Description Default depth `int` The depth of this node in a surrounding tree. 0 Returns: Type Description str str : The indented string representation. Source code in src/dendron/condition_node.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def pretty_repr ( self , depth = 0 ) -> str : \"\"\" Return a string representation of this node at the given depth. Args: depth (`int`): The depth of this node in a surrounding tree. Returns: `str`: The indented string representation. \"\"\" tabs = ' \\t ' * depth repr = f \" { tabs } Condition { self . name } \" return repr","title":"pretty_repr"},{"location":"api/condition_node/#dendron.condition_node.ConditionNode.set_log_level","text":"Set the log level for this node. Source code in src/dendron/condition_node.py 31 32 33 34 35 def set_log_level ( self , new_level ) -> None : \"\"\" Set the log level for this node. \"\"\" self . log_level = new_level","title":"set_log_level"},{"location":"api/condition_node/#dendron.condition_node.ConditionNode.set_logger","text":"Set the logger for this node. Source code in src/dendron/condition_node.py 25 26 27 28 29 def set_logger ( self , new_logger ) -> None : \"\"\" Set the logger for this node. \"\"\" self . logger = new_logger","title":"set_logger"},{"location":"api/control_node/","text":"ControlNode Bases: TreeNode Base class for a control node. A control node maintains a list of children that it ticks under some conditions. The node tracks the state of its children as they tick, and decides whether or not to continue based on its internal logic. Parameters: Name Type Description Default name `str` The given name of this control node. required children `List[TreeNode]` An optional initial list of children. None Source code in src/dendron/control_node.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 class ControlNode ( TreeNode ): \"\"\" Base class for a control node. A control node maintains a list of children that it ticks under some conditions. The node tracks the state of its children as they tick, and decides whether or not to continue based on its internal logic. Args: name (`str`): The given name of this control node. children (`List[TreeNode]`): An optional initial list of children. \"\"\" def __init__ ( self , name : str , children : List [ TreeNode ] = None ) -> None : super () . __init__ ( name ) self . children : List [ TreeNode ] = children def set_tree ( self , tree : BehaviorTree ) -> None : \"\"\" Set the tree of this node, and then have each of the children set their tree similarly. Args: tree (`dendron.behavior_tree.BehaviorTree`): The tree that will contain this node. \"\"\" self . tree = tree for c in self . children : c . set_tree ( tree ) def set_logger ( self , new_logger ) -> None : \"\"\" Set the logger for this node, and then forward the logger to the children. Args: new_logger (`logging.Logger`): The Logger to use. \"\"\" self . logger = new_logger for c in self . children : c . set_logger ( new_logger ) def set_log_level ( self , new_level ) -> None : \"\"\" Set the log level for this node, then forward that level for the children to use. \"\"\" self . log_level = new_level for c in self . children : c . set_log_level ( new_level ) def add_child ( self , child : TreeNode ) -> None : \"\"\" Add a new child node to the end of the list. Args: child (`dendron.tree_node.TreeNode`): The new child node. \"\"\" self . children . append ( child ) def add_children ( self , children : List [ TreeNode ]) -> None : \"\"\" Add a list of children to the end of the list. Args: children (`List[TreeNode]`): The list of `TreeNode`s to add. \"\"\" self . children . extend ( children ) def set_blackboard ( self , bb : Blackboard ) -> None : \"\"\" Set the blackboard for this node, and then forward to the children. Args: bb (`dendron.blackboard.Blackboard`): The new blackboard to use. \"\"\" self . blackboard = bb for child in self . children : child . set_blackboard ( bb ) def get_node_by_name ( self , name : str ) -> Optional [ TreeNode ]: \"\"\" Search for a node by its name. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" if self . name == name : return self else : for child in self . children : node = child . get_node_by_name ( name ) if node != None : return node return None def children_count ( self ) -> int : \"\"\" Get the current number of children. Returns: `int`: The length of the children list. \"\"\" return len ( self . children ) def children ( self ) -> List [ TreeNode ]: \"\"\" Get the list of children. Returns: `List[TreeNode]`: The `self.children` list. \"\"\" return self . children def child ( self , index : int ) -> TreeNode : \"\"\" Get the child that is at position `index` in the list. Does not perform bounds checking. Args: index (`int`): The index of the child we want. Returns: `TreeNode`: The child at the desired index. \"\"\" return self . children [ index ] def node_type ( self ) -> NodeType : \"\"\" Return this node's `NodeType`. Returns: `NodeType`: The type (`CONTROL`). \"\"\" return NodeType . CONTROL def halt_node ( self ) -> None : \"\"\" Reset the children and then reset this node. \"\"\" self . reset_children () self . reset_status () def reset ( self ) -> None : \"\"\" Instruct each child to reset. \"\"\" for child in self . children : child . reset () add_child ( child ) Add a new child node to the end of the list. Parameters: Name Type Description Default child `dendron.tree_node.TreeNode` The new child node. required Source code in src/dendron/control_node.py 67 68 69 70 71 72 73 74 75 def add_child ( self , child : TreeNode ) -> None : \"\"\" Add a new child node to the end of the list. Args: child (`dendron.tree_node.TreeNode`): The new child node. \"\"\" self . children . append ( child ) add_children ( children ) Add a list of children to the end of the list. Parameters: Name Type Description Default children `List[TreeNode]` The list of TreeNode s to add. required Source code in src/dendron/control_node.py 77 78 79 80 81 82 83 84 85 def add_children ( self , children : List [ TreeNode ]) -> None : \"\"\" Add a list of children to the end of the list. Args: children (`List[TreeNode]`): The list of `TreeNode`s to add. \"\"\" self . children . extend ( children ) child ( index ) Get the child that is at position index in the list. Does not perform bounds checking. Parameters: Name Type Description Default index `int` The index of the child we want. required Returns: Type Description TreeNode TreeNode : The child at the desired index. Source code in src/dendron/control_node.py 139 140 141 142 143 144 145 146 147 148 149 150 151 def child ( self , index : int ) -> TreeNode : \"\"\" Get the child that is at position `index` in the list. Does not perform bounds checking. Args: index (`int`): The index of the child we want. Returns: `TreeNode`: The child at the desired index. \"\"\" return self . children [ index ] children () Get the list of children. Returns: Type Description List [ TreeNode ] List[TreeNode] : The self.children list. Source code in src/dendron/control_node.py 130 131 132 133 134 135 136 137 def children ( self ) -> List [ TreeNode ]: \"\"\" Get the list of children. Returns: `List[TreeNode]`: The `self.children` list. \"\"\" return self . children children_count () Get the current number of children. Returns: Type Description int int : The length of the children list. Source code in src/dendron/control_node.py 121 122 123 124 125 126 127 128 def children_count ( self ) -> int : \"\"\" Get the current number of children. Returns: `int`: The length of the children list. \"\"\" return len ( self . children ) get_node_by_name ( name ) Search for a node by its name. Parameters: Name Type Description Default name `str` The name of the node we are looking for. required Returns: Type Description Optional [ TreeNode ] Optional[TreeNode] : Either a node with the given name, Optional [ TreeNode ] or None. Source code in src/dendron/control_node.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def get_node_by_name ( self , name : str ) -> Optional [ TreeNode ]: \"\"\" Search for a node by its name. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" if self . name == name : return self else : for child in self . children : node = child . get_node_by_name ( name ) if node != None : return node return None halt_node () Reset the children and then reset this node. Source code in src/dendron/control_node.py 162 163 164 165 166 167 def halt_node ( self ) -> None : \"\"\" Reset the children and then reset this node. \"\"\" self . reset_children () self . reset_status () node_type () Return this node's NodeType . Returns: Type Description NodeType NodeType : The type ( CONTROL ). Source code in src/dendron/control_node.py 153 154 155 156 157 158 159 160 def node_type ( self ) -> NodeType : \"\"\" Return this node's `NodeType`. Returns: `NodeType`: The type (`CONTROL`). \"\"\" return NodeType . CONTROL reset () Instruct each child to reset. Source code in src/dendron/control_node.py 169 170 171 172 173 174 def reset ( self ) -> None : \"\"\" Instruct each child to reset. \"\"\" for child in self . children : child . reset () set_blackboard ( bb ) Set the blackboard for this node, and then forward to the children. Parameters: Name Type Description Default bb `dendron.blackboard.Blackboard` The new blackboard to use. required Source code in src/dendron/control_node.py 87 88 89 90 91 92 93 94 95 96 97 98 def set_blackboard ( self , bb : Blackboard ) -> None : \"\"\" Set the blackboard for this node, and then forward to the children. Args: bb (`dendron.blackboard.Blackboard`): The new blackboard to use. \"\"\" self . blackboard = bb for child in self . children : child . set_blackboard ( bb ) set_log_level ( new_level ) Set the log level for this node, then forward that level for the children to use. Source code in src/dendron/control_node.py 58 59 60 61 62 63 64 65 def set_log_level ( self , new_level ) -> None : \"\"\" Set the log level for this node, then forward that level for the children to use. \"\"\" self . log_level = new_level for c in self . children : c . set_log_level ( new_level ) set_logger ( new_logger ) Set the logger for this node, and then forward the logger to the children. Parameters: Name Type Description Default new_logger `logging.Logger` The Logger to use. required Source code in src/dendron/control_node.py 45 46 47 48 49 50 51 52 53 54 55 56 def set_logger ( self , new_logger ) -> None : \"\"\" Set the logger for this node, and then forward the logger to the children. Args: new_logger (`logging.Logger`): The Logger to use. \"\"\" self . logger = new_logger for c in self . children : c . set_logger ( new_logger ) set_tree ( tree ) Set the tree of this node, and then have each of the children set their tree similarly. Parameters: Name Type Description Default tree `dendron.behavior_tree.BehaviorTree` The tree that will contain this node. required Source code in src/dendron/control_node.py 32 33 34 35 36 37 38 39 40 41 42 43 def set_tree ( self , tree : BehaviorTree ) -> None : \"\"\" Set the tree of this node, and then have each of the children set their tree similarly. Args: tree (`dendron.behavior_tree.BehaviorTree`): The tree that will contain this node. \"\"\" self . tree = tree for c in self . children : c . set_tree ( tree )","title":"ControlNode"},{"location":"api/control_node/#controlnode","text":"Bases: TreeNode Base class for a control node. A control node maintains a list of children that it ticks under some conditions. The node tracks the state of its children as they tick, and decides whether or not to continue based on its internal logic. Parameters: Name Type Description Default name `str` The given name of this control node. required children `List[TreeNode]` An optional initial list of children. None Source code in src/dendron/control_node.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 class ControlNode ( TreeNode ): \"\"\" Base class for a control node. A control node maintains a list of children that it ticks under some conditions. The node tracks the state of its children as they tick, and decides whether or not to continue based on its internal logic. Args: name (`str`): The given name of this control node. children (`List[TreeNode]`): An optional initial list of children. \"\"\" def __init__ ( self , name : str , children : List [ TreeNode ] = None ) -> None : super () . __init__ ( name ) self . children : List [ TreeNode ] = children def set_tree ( self , tree : BehaviorTree ) -> None : \"\"\" Set the tree of this node, and then have each of the children set their tree similarly. Args: tree (`dendron.behavior_tree.BehaviorTree`): The tree that will contain this node. \"\"\" self . tree = tree for c in self . children : c . set_tree ( tree ) def set_logger ( self , new_logger ) -> None : \"\"\" Set the logger for this node, and then forward the logger to the children. Args: new_logger (`logging.Logger`): The Logger to use. \"\"\" self . logger = new_logger for c in self . children : c . set_logger ( new_logger ) def set_log_level ( self , new_level ) -> None : \"\"\" Set the log level for this node, then forward that level for the children to use. \"\"\" self . log_level = new_level for c in self . children : c . set_log_level ( new_level ) def add_child ( self , child : TreeNode ) -> None : \"\"\" Add a new child node to the end of the list. Args: child (`dendron.tree_node.TreeNode`): The new child node. \"\"\" self . children . append ( child ) def add_children ( self , children : List [ TreeNode ]) -> None : \"\"\" Add a list of children to the end of the list. Args: children (`List[TreeNode]`): The list of `TreeNode`s to add. \"\"\" self . children . extend ( children ) def set_blackboard ( self , bb : Blackboard ) -> None : \"\"\" Set the blackboard for this node, and then forward to the children. Args: bb (`dendron.blackboard.Blackboard`): The new blackboard to use. \"\"\" self . blackboard = bb for child in self . children : child . set_blackboard ( bb ) def get_node_by_name ( self , name : str ) -> Optional [ TreeNode ]: \"\"\" Search for a node by its name. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" if self . name == name : return self else : for child in self . children : node = child . get_node_by_name ( name ) if node != None : return node return None def children_count ( self ) -> int : \"\"\" Get the current number of children. Returns: `int`: The length of the children list. \"\"\" return len ( self . children ) def children ( self ) -> List [ TreeNode ]: \"\"\" Get the list of children. Returns: `List[TreeNode]`: The `self.children` list. \"\"\" return self . children def child ( self , index : int ) -> TreeNode : \"\"\" Get the child that is at position `index` in the list. Does not perform bounds checking. Args: index (`int`): The index of the child we want. Returns: `TreeNode`: The child at the desired index. \"\"\" return self . children [ index ] def node_type ( self ) -> NodeType : \"\"\" Return this node's `NodeType`. Returns: `NodeType`: The type (`CONTROL`). \"\"\" return NodeType . CONTROL def halt_node ( self ) -> None : \"\"\" Reset the children and then reset this node. \"\"\" self . reset_children () self . reset_status () def reset ( self ) -> None : \"\"\" Instruct each child to reset. \"\"\" for child in self . children : child . reset ()","title":"ControlNode"},{"location":"api/control_node/#dendron.control_node.ControlNode.add_child","text":"Add a new child node to the end of the list. Parameters: Name Type Description Default child `dendron.tree_node.TreeNode` The new child node. required Source code in src/dendron/control_node.py 67 68 69 70 71 72 73 74 75 def add_child ( self , child : TreeNode ) -> None : \"\"\" Add a new child node to the end of the list. Args: child (`dendron.tree_node.TreeNode`): The new child node. \"\"\" self . children . append ( child )","title":"add_child"},{"location":"api/control_node/#dendron.control_node.ControlNode.add_children","text":"Add a list of children to the end of the list. Parameters: Name Type Description Default children `List[TreeNode]` The list of TreeNode s to add. required Source code in src/dendron/control_node.py 77 78 79 80 81 82 83 84 85 def add_children ( self , children : List [ TreeNode ]) -> None : \"\"\" Add a list of children to the end of the list. Args: children (`List[TreeNode]`): The list of `TreeNode`s to add. \"\"\" self . children . extend ( children )","title":"add_children"},{"location":"api/control_node/#dendron.control_node.ControlNode.child","text":"Get the child that is at position index in the list. Does not perform bounds checking. Parameters: Name Type Description Default index `int` The index of the child we want. required Returns: Type Description TreeNode TreeNode : The child at the desired index. Source code in src/dendron/control_node.py 139 140 141 142 143 144 145 146 147 148 149 150 151 def child ( self , index : int ) -> TreeNode : \"\"\" Get the child that is at position `index` in the list. Does not perform bounds checking. Args: index (`int`): The index of the child we want. Returns: `TreeNode`: The child at the desired index. \"\"\" return self . children [ index ]","title":"child"},{"location":"api/control_node/#dendron.control_node.ControlNode.children","text":"Get the list of children. Returns: Type Description List [ TreeNode ] List[TreeNode] : The self.children list. Source code in src/dendron/control_node.py 130 131 132 133 134 135 136 137 def children ( self ) -> List [ TreeNode ]: \"\"\" Get the list of children. Returns: `List[TreeNode]`: The `self.children` list. \"\"\" return self . children","title":"children"},{"location":"api/control_node/#dendron.control_node.ControlNode.children_count","text":"Get the current number of children. Returns: Type Description int int : The length of the children list. Source code in src/dendron/control_node.py 121 122 123 124 125 126 127 128 def children_count ( self ) -> int : \"\"\" Get the current number of children. Returns: `int`: The length of the children list. \"\"\" return len ( self . children )","title":"children_count"},{"location":"api/control_node/#dendron.control_node.ControlNode.get_node_by_name","text":"Search for a node by its name. Parameters: Name Type Description Default name `str` The name of the node we are looking for. required Returns: Type Description Optional [ TreeNode ] Optional[TreeNode] : Either a node with the given name, Optional [ TreeNode ] or None. Source code in src/dendron/control_node.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def get_node_by_name ( self , name : str ) -> Optional [ TreeNode ]: \"\"\" Search for a node by its name. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" if self . name == name : return self else : for child in self . children : node = child . get_node_by_name ( name ) if node != None : return node return None","title":"get_node_by_name"},{"location":"api/control_node/#dendron.control_node.ControlNode.halt_node","text":"Reset the children and then reset this node. Source code in src/dendron/control_node.py 162 163 164 165 166 167 def halt_node ( self ) -> None : \"\"\" Reset the children and then reset this node. \"\"\" self . reset_children () self . reset_status ()","title":"halt_node"},{"location":"api/control_node/#dendron.control_node.ControlNode.node_type","text":"Return this node's NodeType . Returns: Type Description NodeType NodeType : The type ( CONTROL ). Source code in src/dendron/control_node.py 153 154 155 156 157 158 159 160 def node_type ( self ) -> NodeType : \"\"\" Return this node's `NodeType`. Returns: `NodeType`: The type (`CONTROL`). \"\"\" return NodeType . CONTROL","title":"node_type"},{"location":"api/control_node/#dendron.control_node.ControlNode.reset","text":"Instruct each child to reset. Source code in src/dendron/control_node.py 169 170 171 172 173 174 def reset ( self ) -> None : \"\"\" Instruct each child to reset. \"\"\" for child in self . children : child . reset ()","title":"reset"},{"location":"api/control_node/#dendron.control_node.ControlNode.set_blackboard","text":"Set the blackboard for this node, and then forward to the children. Parameters: Name Type Description Default bb `dendron.blackboard.Blackboard` The new blackboard to use. required Source code in src/dendron/control_node.py 87 88 89 90 91 92 93 94 95 96 97 98 def set_blackboard ( self , bb : Blackboard ) -> None : \"\"\" Set the blackboard for this node, and then forward to the children. Args: bb (`dendron.blackboard.Blackboard`): The new blackboard to use. \"\"\" self . blackboard = bb for child in self . children : child . set_blackboard ( bb )","title":"set_blackboard"},{"location":"api/control_node/#dendron.control_node.ControlNode.set_log_level","text":"Set the log level for this node, then forward that level for the children to use. Source code in src/dendron/control_node.py 58 59 60 61 62 63 64 65 def set_log_level ( self , new_level ) -> None : \"\"\" Set the log level for this node, then forward that level for the children to use. \"\"\" self . log_level = new_level for c in self . children : c . set_log_level ( new_level )","title":"set_log_level"},{"location":"api/control_node/#dendron.control_node.ControlNode.set_logger","text":"Set the logger for this node, and then forward the logger to the children. Parameters: Name Type Description Default new_logger `logging.Logger` The Logger to use. required Source code in src/dendron/control_node.py 45 46 47 48 49 50 51 52 53 54 55 56 def set_logger ( self , new_logger ) -> None : \"\"\" Set the logger for this node, and then forward the logger to the children. Args: new_logger (`logging.Logger`): The Logger to use. \"\"\" self . logger = new_logger for c in self . children : c . set_logger ( new_logger )","title":"set_logger"},{"location":"api/control_node/#dendron.control_node.ControlNode.set_tree","text":"Set the tree of this node, and then have each of the children set their tree similarly. Parameters: Name Type Description Default tree `dendron.behavior_tree.BehaviorTree` The tree that will contain this node. required Source code in src/dendron/control_node.py 32 33 34 35 36 37 38 39 40 41 42 43 def set_tree ( self , tree : BehaviorTree ) -> None : \"\"\" Set the tree of this node, and then have each of the children set their tree similarly. Args: tree (`dendron.behavior_tree.BehaviorTree`): The tree that will contain this node. \"\"\" self . tree = tree for c in self . children : c . set_tree ( tree )","title":"set_tree"},{"location":"api/decorator_node/","text":"DecoratorNode Bases: TreeNode A decorator is a \"wrapper\" around a single node. The purpose of the decorator is to modify or support the action of its child in some way. Parameters: Name Type Description Default name `str` The given name of this node. required child `dendron.tree_node.TreeNode` An optional child node. If not specified, the child must be set before this node's tick() function is first called. None Source code in src/dendron/decorator_node.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class DecoratorNode ( TreeNode ): \"\"\" A decorator is a \"wrapper\" around a single node. The purpose of the decorator is to modify or support the action of its child in some way. Args: name (`str`): The given name of this node. child (`dendron.tree_node.TreeNode`): An optional child node. If not specified, the child must be set before this node's `tick()` function is first called. \"\"\" def __init__ ( self , name , child : TreeNode = None ) -> None : super () . __init__ ( name ) self . child_node : TreeNode = child def set_logger ( self , new_logger ) -> None : \"\"\" Set the logger for this node, and then forward the logger to the child node. \"\"\" self . logger = new_logger self . child_node . set_logger ( new_logger ) def set_log_level ( self , new_level ) -> None : \"\"\" Set the log level for this node, and then forward that level to the child node. \"\"\" self . log_level = new_level self . child_node . set_log_level ( new_level ) def node_type ( self ) -> NodeType : \"\"\" Return this node's type. \"\"\" return NodeType . DECORATOR def set_child ( self , child : TreeNode ) -> None : \"\"\" Set the child of this node to a new `TreeNode`. Args: child (`dendron.tree_node.TreeNode`): The new child of this decorator. \"\"\" self . child_node = child def get_child ( self ) -> TreeNode : \"\"\" Get the child of this decorator. Returns: `TreeNode`: The child of this node. \"\"\" return self . child_node def get_node_by_name ( self , name : str ) -> Optional [ TreeNode ]: \"\"\" Search for a node by its name. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" if self . name == name : return self else : return self . child_node . get_node_by_name ( name ) def halt_child ( self ) -> None : \"\"\" Instruct the child node to halt. \"\"\" self . child_node . halt_node () def set_tree ( self , tree : BehaviorTree ) -> None : \"\"\" Set the tree of this node, and then forward the tree to the child to have it set its tree. Args: tree (`dendron.behavior_tree.BehaviorTree`): The tree that contains this node. \"\"\" self . tree = tree self . child_node . set_tree ( tree ) def reset ( self ) -> None : \"\"\" Set the status of this node to IDLE and instruct the child node to reset. \"\"\" self . node_status = NodeStatus . IDLE self . child_node . reset () def pretty_repr ( self , depth = 0 ) -> str : \"\"\" Return a string representation of this node at the given depth. Args: depth (`int`): The depth of this node in a surrounding tree. Returns: `str`: The indented string representation. \"\"\" tabs = ' \\t ' * depth repr = f \" { tabs } Decorator { self . name } \\n { self . child_node . pretty_repr ( depth + 1 ) } \" return repr get_child () Get the child of this decorator. Returns: Type Description TreeNode TreeNode : The child of this node. Source code in src/dendron/decorator_node.py 61 62 63 64 65 66 67 68 def get_child ( self ) -> TreeNode : \"\"\" Get the child of this decorator. Returns: `TreeNode`: The child of this node. \"\"\" return self . child_node get_node_by_name ( name ) Search for a node by its name. Parameters: Name Type Description Default name `str` The name of the node we are looking for. required Returns: Type Description Optional [ TreeNode ] Optional[TreeNode] : Either a node with the given name, Optional [ TreeNode ] or None. Source code in src/dendron/decorator_node.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def get_node_by_name ( self , name : str ) -> Optional [ TreeNode ]: \"\"\" Search for a node by its name. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" if self . name == name : return self else : return self . child_node . get_node_by_name ( name ) halt_child () Instruct the child node to halt. Source code in src/dendron/decorator_node.py 87 88 89 90 91 def halt_child ( self ) -> None : \"\"\" Instruct the child node to halt. \"\"\" self . child_node . halt_node () node_type () Return this node's type. Source code in src/dendron/decorator_node.py 45 46 47 48 49 def node_type ( self ) -> NodeType : \"\"\" Return this node's type. \"\"\" return NodeType . DECORATOR pretty_repr ( depth = 0 ) Return a string representation of this node at the given depth. Parameters: Name Type Description Default depth `int` The depth of this node in a surrounding tree. 0 Returns: Type Description str str : The indented string representation. Source code in src/dendron/decorator_node.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def pretty_repr ( self , depth = 0 ) -> str : \"\"\" Return a string representation of this node at the given depth. Args: depth (`int`): The depth of this node in a surrounding tree. Returns: `str`: The indented string representation. \"\"\" tabs = ' \\t ' * depth repr = f \" { tabs } Decorator { self . name } \\n { self . child_node . pretty_repr ( depth + 1 ) } \" return repr reset () Set the status of this node to IDLE and instruct the child node to reset. Source code in src/dendron/decorator_node.py 105 106 107 108 109 110 111 def reset ( self ) -> None : \"\"\" Set the status of this node to IDLE and instruct the child node to reset. \"\"\" self . node_status = NodeStatus . IDLE self . child_node . reset () set_child ( child ) Set the child of this node to a new TreeNode . Parameters: Name Type Description Default child `dendron.tree_node.TreeNode` The new child of this decorator. required Source code in src/dendron/decorator_node.py 51 52 53 54 55 56 57 58 59 def set_child ( self , child : TreeNode ) -> None : \"\"\" Set the child of this node to a new `TreeNode`. Args: child (`dendron.tree_node.TreeNode`): The new child of this decorator. \"\"\" self . child_node = child set_log_level ( new_level ) Set the log level for this node, and then forward that level to the child node. Source code in src/dendron/decorator_node.py 37 38 39 40 41 42 43 def set_log_level ( self , new_level ) -> None : \"\"\" Set the log level for this node, and then forward that level to the child node. \"\"\" self . log_level = new_level self . child_node . set_log_level ( new_level ) set_logger ( new_logger ) Set the logger for this node, and then forward the logger to the child node. Source code in src/dendron/decorator_node.py 29 30 31 32 33 34 35 def set_logger ( self , new_logger ) -> None : \"\"\" Set the logger for this node, and then forward the logger to the child node. \"\"\" self . logger = new_logger self . child_node . set_logger ( new_logger ) set_tree ( tree ) Set the tree of this node, and then forward the tree to the child to have it set its tree. Parameters: Name Type Description Default tree `dendron.behavior_tree.BehaviorTree` The tree that contains this node. required Source code in src/dendron/decorator_node.py 93 94 95 96 97 98 99 100 101 102 103 def set_tree ( self , tree : BehaviorTree ) -> None : \"\"\" Set the tree of this node, and then forward the tree to the child to have it set its tree. Args: tree (`dendron.behavior_tree.BehaviorTree`): The tree that contains this node. \"\"\" self . tree = tree self . child_node . set_tree ( tree )","title":"DecoratorNode"},{"location":"api/decorator_node/#decoratornode","text":"Bases: TreeNode A decorator is a \"wrapper\" around a single node. The purpose of the decorator is to modify or support the action of its child in some way. Parameters: Name Type Description Default name `str` The given name of this node. required child `dendron.tree_node.TreeNode` An optional child node. If not specified, the child must be set before this node's tick() function is first called. None Source code in src/dendron/decorator_node.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class DecoratorNode ( TreeNode ): \"\"\" A decorator is a \"wrapper\" around a single node. The purpose of the decorator is to modify or support the action of its child in some way. Args: name (`str`): The given name of this node. child (`dendron.tree_node.TreeNode`): An optional child node. If not specified, the child must be set before this node's `tick()` function is first called. \"\"\" def __init__ ( self , name , child : TreeNode = None ) -> None : super () . __init__ ( name ) self . child_node : TreeNode = child def set_logger ( self , new_logger ) -> None : \"\"\" Set the logger for this node, and then forward the logger to the child node. \"\"\" self . logger = new_logger self . child_node . set_logger ( new_logger ) def set_log_level ( self , new_level ) -> None : \"\"\" Set the log level for this node, and then forward that level to the child node. \"\"\" self . log_level = new_level self . child_node . set_log_level ( new_level ) def node_type ( self ) -> NodeType : \"\"\" Return this node's type. \"\"\" return NodeType . DECORATOR def set_child ( self , child : TreeNode ) -> None : \"\"\" Set the child of this node to a new `TreeNode`. Args: child (`dendron.tree_node.TreeNode`): The new child of this decorator. \"\"\" self . child_node = child def get_child ( self ) -> TreeNode : \"\"\" Get the child of this decorator. Returns: `TreeNode`: The child of this node. \"\"\" return self . child_node def get_node_by_name ( self , name : str ) -> Optional [ TreeNode ]: \"\"\" Search for a node by its name. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" if self . name == name : return self else : return self . child_node . get_node_by_name ( name ) def halt_child ( self ) -> None : \"\"\" Instruct the child node to halt. \"\"\" self . child_node . halt_node () def set_tree ( self , tree : BehaviorTree ) -> None : \"\"\" Set the tree of this node, and then forward the tree to the child to have it set its tree. Args: tree (`dendron.behavior_tree.BehaviorTree`): The tree that contains this node. \"\"\" self . tree = tree self . child_node . set_tree ( tree ) def reset ( self ) -> None : \"\"\" Set the status of this node to IDLE and instruct the child node to reset. \"\"\" self . node_status = NodeStatus . IDLE self . child_node . reset () def pretty_repr ( self , depth = 0 ) -> str : \"\"\" Return a string representation of this node at the given depth. Args: depth (`int`): The depth of this node in a surrounding tree. Returns: `str`: The indented string representation. \"\"\" tabs = ' \\t ' * depth repr = f \" { tabs } Decorator { self . name } \\n { self . child_node . pretty_repr ( depth + 1 ) } \" return repr","title":"DecoratorNode"},{"location":"api/decorator_node/#dendron.decorator_node.DecoratorNode.get_child","text":"Get the child of this decorator. Returns: Type Description TreeNode TreeNode : The child of this node. Source code in src/dendron/decorator_node.py 61 62 63 64 65 66 67 68 def get_child ( self ) -> TreeNode : \"\"\" Get the child of this decorator. Returns: `TreeNode`: The child of this node. \"\"\" return self . child_node","title":"get_child"},{"location":"api/decorator_node/#dendron.decorator_node.DecoratorNode.get_node_by_name","text":"Search for a node by its name. Parameters: Name Type Description Default name `str` The name of the node we are looking for. required Returns: Type Description Optional [ TreeNode ] Optional[TreeNode] : Either a node with the given name, Optional [ TreeNode ] or None. Source code in src/dendron/decorator_node.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def get_node_by_name ( self , name : str ) -> Optional [ TreeNode ]: \"\"\" Search for a node by its name. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" if self . name == name : return self else : return self . child_node . get_node_by_name ( name )","title":"get_node_by_name"},{"location":"api/decorator_node/#dendron.decorator_node.DecoratorNode.halt_child","text":"Instruct the child node to halt. Source code in src/dendron/decorator_node.py 87 88 89 90 91 def halt_child ( self ) -> None : \"\"\" Instruct the child node to halt. \"\"\" self . child_node . halt_node ()","title":"halt_child"},{"location":"api/decorator_node/#dendron.decorator_node.DecoratorNode.node_type","text":"Return this node's type. Source code in src/dendron/decorator_node.py 45 46 47 48 49 def node_type ( self ) -> NodeType : \"\"\" Return this node's type. \"\"\" return NodeType . DECORATOR","title":"node_type"},{"location":"api/decorator_node/#dendron.decorator_node.DecoratorNode.pretty_repr","text":"Return a string representation of this node at the given depth. Parameters: Name Type Description Default depth `int` The depth of this node in a surrounding tree. 0 Returns: Type Description str str : The indented string representation. Source code in src/dendron/decorator_node.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def pretty_repr ( self , depth = 0 ) -> str : \"\"\" Return a string representation of this node at the given depth. Args: depth (`int`): The depth of this node in a surrounding tree. Returns: `str`: The indented string representation. \"\"\" tabs = ' \\t ' * depth repr = f \" { tabs } Decorator { self . name } \\n { self . child_node . pretty_repr ( depth + 1 ) } \" return repr","title":"pretty_repr"},{"location":"api/decorator_node/#dendron.decorator_node.DecoratorNode.reset","text":"Set the status of this node to IDLE and instruct the child node to reset. Source code in src/dendron/decorator_node.py 105 106 107 108 109 110 111 def reset ( self ) -> None : \"\"\" Set the status of this node to IDLE and instruct the child node to reset. \"\"\" self . node_status = NodeStatus . IDLE self . child_node . reset ()","title":"reset"},{"location":"api/decorator_node/#dendron.decorator_node.DecoratorNode.set_child","text":"Set the child of this node to a new TreeNode . Parameters: Name Type Description Default child `dendron.tree_node.TreeNode` The new child of this decorator. required Source code in src/dendron/decorator_node.py 51 52 53 54 55 56 57 58 59 def set_child ( self , child : TreeNode ) -> None : \"\"\" Set the child of this node to a new `TreeNode`. Args: child (`dendron.tree_node.TreeNode`): The new child of this decorator. \"\"\" self . child_node = child","title":"set_child"},{"location":"api/decorator_node/#dendron.decorator_node.DecoratorNode.set_log_level","text":"Set the log level for this node, and then forward that level to the child node. Source code in src/dendron/decorator_node.py 37 38 39 40 41 42 43 def set_log_level ( self , new_level ) -> None : \"\"\" Set the log level for this node, and then forward that level to the child node. \"\"\" self . log_level = new_level self . child_node . set_log_level ( new_level )","title":"set_log_level"},{"location":"api/decorator_node/#dendron.decorator_node.DecoratorNode.set_logger","text":"Set the logger for this node, and then forward the logger to the child node. Source code in src/dendron/decorator_node.py 29 30 31 32 33 34 35 def set_logger ( self , new_logger ) -> None : \"\"\" Set the logger for this node, and then forward the logger to the child node. \"\"\" self . logger = new_logger self . child_node . set_logger ( new_logger )","title":"set_logger"},{"location":"api/decorator_node/#dendron.decorator_node.DecoratorNode.set_tree","text":"Set the tree of this node, and then forward the tree to the child to have it set its tree. Parameters: Name Type Description Default tree `dendron.behavior_tree.BehaviorTree` The tree that contains this node. required Source code in src/dendron/decorator_node.py 93 94 95 96 97 98 99 100 101 102 103 def set_tree ( self , tree : BehaviorTree ) -> None : \"\"\" Set the tree of this node, and then forward the tree to the child to have it set its tree. Args: tree (`dendron.behavior_tree.BehaviorTree`): The tree that contains this node. \"\"\" self . tree = tree self . child_node . set_tree ( tree )","title":"set_tree"},{"location":"api/tree_node/","text":"TreeNode Base class for a node in a behavior tree. Parameters: Name Type Description Default name `str` The name to give to this node. required Source code in src/dendron/tree_node.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 class TreeNode : \"\"\" Base class for a node in a behavior tree. Args: name (`str`): The name to give to this node. \"\"\" def __init__ ( self , name : str ) -> None : self . name = name self . blackboard = None self . status = NodeStatus . IDLE self . pre_tick_fn = None self . post_tick_fn = None self . logger = None self . log_level = None self . tree = None def set_tree ( self , tree : BehaviorTree ) -> None : \"\"\" Set the tree that contains this node. Args: tree (`dendron.behavior_tree.BehaviorTree`): The new tree this node is a part of. \"\"\" self . tree = tree def set_logger ( self , new_logger ) -> None : raise NotImplementedError ( \"set_logger should be defined in subclass.\" ) def set_log_level ( self , new_level ) -> None : raise NotImplementedError ( \"set_log_level should be defined in subclass.\" ) def _get_level_str ( self , new_level ) -> str : if self . logger is not None : level_str = \"None\" match self . logger . level : case logging . DEBUG : level_str = \"debug\" case logging . INFO : level_str = \"info\" case logging . WARNING : level_str = \"warning\" case logging . ERROR : level_str = \"error\" case logging . CRITICAL : level_str = \"critical\" return level_str def execute_tick ( self ) -> NodeStatus : \"\"\" Performs pre-tick operations, calls the Node's tick() method, and then performs post-tick operations. If logging is enabled, then this is where log functions are called. Returns: `dendron.basic_types.NodeStatus`: The status returned by the inner call to tick(). \"\"\" if self . logger is not None : log_fn = getattr ( self . logger , self . _get_level_str ( self . log_level )) log_fn ( f \" { self . name } - pre_tick\" ) if self . pre_tick_fn is not None : self . pre_tick_fn () self . status = self . tick () if self . post_tick_fn is not None : self . post_tick_fn () if self . logger is not None : log_fn = getattr ( self . logger , self . _get_level_str ( self . log_level )) log_fn ( f \" { self . name } - post_tick { self . status } \" ) return self . status def set_description ( self , desc ) -> None : \"\"\" A textual description intended to help with automated policy construction. Args: desc (`str`): The textual description of this node's functionality. \"\"\" self . description = desc def halt_node ( self ) -> None : raise NotImplementedError ( \"Halt behavior is specified in subclass.\" ) def set_blackboard ( self , bb : Blackboard ) -> None : \"\"\" Set the blackboard to be used by this TreeNode. Args: bb (`dendron.blackboard.Blackboard`): The new blackboard. \"\"\" self . blackboard = bb # TODO consider deprecating def blackboard_set ( self , key , value ) -> None : full_key = self . name + '/' + key self . blackboard [ full_key ] = value # TODO consider deprecating def blackboard_get ( self , key ) -> Any : full_key = self . name + '/' + key return self . blackboard [ full_key ] def is_halted ( self ) -> bool : \"\"\" Query whether this node is in a halted state. Returns: `bool`: True iff the status is IDLE. \"\"\" return self . status == NodeStatus . IDLE def get_status ( self ) -> NodeStatus : \"\"\" Get the current status of this node. Returns: `dendron.basic_types.NodeStatus`: The node status. \"\"\" return self . status def set_status ( self , new_status : NodeStatus ) -> None : \"\"\" Set the node status to a new value. Args: new_status (`dendron.basic_types.NodeStatus`): The new NodeStatus. \"\"\" self . status = new_status def name ( self ) -> str : \"\"\" Get this node's human-readable name. Returns: `str`: The given name of this node. \"\"\" return self . name def node_type ( self ) -> NodeType : raise NotImplementedError ( \"Type is specified in subclass.\" ) # the problem with this is that Self is only supported in 3.11+, which # doesn't work with some libraries and packages. #def get_node_by_name(self, name : str) -> Optional[Self]: def get_node_by_name ( self , name : str ): \"\"\" Search for a node by its name. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" raise NotImplementedError ( \"get_node_by_name should be implemented in a subclass.\" ) def set_pre_tick ( self , f : Callable ) -> None : \"\"\" Specify a function-like object to be called before the `tick()` function. Args: f (`Callable`): The function to call before `tick()`. \"\"\" self . pre_tick_fn = types . MethodType ( f , self ) def set_post_tick ( self , f : Callable ) -> None : \"\"\" Specify a function-like object to be called after the `tick()` function. Args: f (`Callable`): The function to call after `tick()`. \"\"\" self . post_tick_fn = types . MethodType ( f , self ) def tick ( self ) -> NodeStatus : raise NotImplementedError ( \"Tick should be implemented in a subclass.\" ) def reset ( self ) -> None : \"\"\" Set the status of this node to IDLE. \"\"\" self . status = NodeStatus . IDLE def pretty_repr ( self , depth = 0 ) -> str : \"\"\" Return a string representation of this node at the given depth. Args: depth (`int`): The depth of this node in a surrounding tree. Returns: `str`: The indented string representation. \"\"\" raise NotImplementedError ( \"Pretty printing should be implemented in a subclass.\" ) execute_tick () Performs pre-tick operations, calls the Node's tick() method, and then performs post-tick operations. If logging is enabled, then this is where log functions are called. Returns: Type Description NodeStatus dendron.basic_types.NodeStatus : The status returned by the inner NodeStatus call to tick(). Source code in src/dendron/tree_node.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def execute_tick ( self ) -> NodeStatus : \"\"\" Performs pre-tick operations, calls the Node's tick() method, and then performs post-tick operations. If logging is enabled, then this is where log functions are called. Returns: `dendron.basic_types.NodeStatus`: The status returned by the inner call to tick(). \"\"\" if self . logger is not None : log_fn = getattr ( self . logger , self . _get_level_str ( self . log_level )) log_fn ( f \" { self . name } - pre_tick\" ) if self . pre_tick_fn is not None : self . pre_tick_fn () self . status = self . tick () if self . post_tick_fn is not None : self . post_tick_fn () if self . logger is not None : log_fn = getattr ( self . logger , self . _get_level_str ( self . log_level )) log_fn ( f \" { self . name } - post_tick { self . status } \" ) return self . status get_node_by_name ( name ) Search for a node by its name. Parameters: Name Type Description Default name `str` The name of the node we are looking for. required Returns: Type Description Optional[TreeNode] : Either a node with the given name, or None. Source code in src/dendron/tree_node.py 177 178 179 180 181 182 183 184 185 186 187 188 189 def get_node_by_name ( self , name : str ): \"\"\" Search for a node by its name. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" raise NotImplementedError ( \"get_node_by_name should be implemented in a subclass.\" ) get_status () Get the current status of this node. Returns: Type Description NodeStatus dendron.basic_types.NodeStatus : The node status. Source code in src/dendron/tree_node.py 142 143 144 145 146 147 148 149 def get_status ( self ) -> NodeStatus : \"\"\" Get the current status of this node. Returns: `dendron.basic_types.NodeStatus`: The node status. \"\"\" return self . status is_halted () Query whether this node is in a halted state. Returns: Type Description bool bool : True iff the status is IDLE. Source code in src/dendron/tree_node.py 133 134 135 136 137 138 139 140 def is_halted ( self ) -> bool : \"\"\" Query whether this node is in a halted state. Returns: `bool`: True iff the status is IDLE. \"\"\" return self . status == NodeStatus . IDLE name () Get this node's human-readable name. Returns: Type Description str str : The given name of this node. Source code in src/dendron/tree_node.py 161 162 163 164 165 166 167 168 def name ( self ) -> str : \"\"\" Get this node's human-readable name. Returns: `str`: The given name of this node. \"\"\" return self . name pretty_repr ( depth = 0 ) Return a string representation of this node at the given depth. Parameters: Name Type Description Default depth `int` The depth of this node in a surrounding tree. 0 Returns: Type Description str str : The indented string representation. Source code in src/dendron/tree_node.py 222 223 224 225 226 227 228 229 230 231 232 233 def pretty_repr ( self , depth = 0 ) -> str : \"\"\" Return a string representation of this node at the given depth. Args: depth (`int`): The depth of this node in a surrounding tree. Returns: `str`: The indented string representation. \"\"\" raise NotImplementedError ( \"Pretty printing should be implemented in a subclass.\" ) reset () Set the status of this node to IDLE. Source code in src/dendron/tree_node.py 216 217 218 219 220 def reset ( self ) -> None : \"\"\" Set the status of this node to IDLE. \"\"\" self . status = NodeStatus . IDLE set_blackboard ( bb ) Set the blackboard to be used by this TreeNode. Parameters: Name Type Description Default bb `dendron.blackboard.Blackboard` The new blackboard. required Source code in src/dendron/tree_node.py 113 114 115 116 117 118 119 120 121 def set_blackboard ( self , bb : Blackboard ) -> None : \"\"\" Set the blackboard to be used by this TreeNode. Args: bb (`dendron.blackboard.Blackboard`): The new blackboard. \"\"\" self . blackboard = bb set_description ( desc ) A textual description intended to help with automated policy construction. Parameters: Name Type Description Default desc `str` The textual description of this node's functionality. required Source code in src/dendron/tree_node.py 99 100 101 102 103 104 105 106 107 108 def set_description ( self , desc ) -> None : \"\"\" A textual description intended to help with automated policy construction. Args: desc (`str`): The textual description of this node's functionality. \"\"\" self . description = desc set_post_tick ( f ) Specify a function-like object to be called after the tick() function. Parameters: Name Type Description Default f `Callable` The function to call after tick() . required Source code in src/dendron/tree_node.py 202 203 204 205 206 207 208 209 210 211 def set_post_tick ( self , f : Callable ) -> None : \"\"\" Specify a function-like object to be called after the `tick()` function. Args: f (`Callable`): The function to call after `tick()`. \"\"\" self . post_tick_fn = types . MethodType ( f , self ) set_pre_tick ( f ) Specify a function-like object to be called before the tick() function. Parameters: Name Type Description Default f `Callable` The function to call before tick() . required Source code in src/dendron/tree_node.py 191 192 193 194 195 196 197 198 199 200 def set_pre_tick ( self , f : Callable ) -> None : \"\"\" Specify a function-like object to be called before the `tick()` function. Args: f (`Callable`): The function to call before `tick()`. \"\"\" self . pre_tick_fn = types . MethodType ( f , self ) set_status ( new_status ) Set the node status to a new value. Parameters: Name Type Description Default new_status `dendron.basic_types.NodeStatus` The new NodeStatus. required Source code in src/dendron/tree_node.py 151 152 153 154 155 156 157 158 159 def set_status ( self , new_status : NodeStatus ) -> None : \"\"\" Set the node status to a new value. Args: new_status (`dendron.basic_types.NodeStatus`): The new NodeStatus. \"\"\" self . status = new_status set_tree ( tree ) Set the tree that contains this node. Parameters: Name Type Description Default tree `dendron.behavior_tree.BehaviorTree` The new tree this node is a part of. required Source code in src/dendron/tree_node.py 39 40 41 42 43 44 45 46 47 def set_tree ( self , tree : BehaviorTree ) -> None : \"\"\" Set the tree that contains this node. Args: tree (`dendron.behavior_tree.BehaviorTree`): The new tree this node is a part of. \"\"\" self . tree = tree","title":"TreeNode"},{"location":"api/tree_node/#treenode","text":"Base class for a node in a behavior tree. Parameters: Name Type Description Default name `str` The name to give to this node. required Source code in src/dendron/tree_node.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 class TreeNode : \"\"\" Base class for a node in a behavior tree. Args: name (`str`): The name to give to this node. \"\"\" def __init__ ( self , name : str ) -> None : self . name = name self . blackboard = None self . status = NodeStatus . IDLE self . pre_tick_fn = None self . post_tick_fn = None self . logger = None self . log_level = None self . tree = None def set_tree ( self , tree : BehaviorTree ) -> None : \"\"\" Set the tree that contains this node. Args: tree (`dendron.behavior_tree.BehaviorTree`): The new tree this node is a part of. \"\"\" self . tree = tree def set_logger ( self , new_logger ) -> None : raise NotImplementedError ( \"set_logger should be defined in subclass.\" ) def set_log_level ( self , new_level ) -> None : raise NotImplementedError ( \"set_log_level should be defined in subclass.\" ) def _get_level_str ( self , new_level ) -> str : if self . logger is not None : level_str = \"None\" match self . logger . level : case logging . DEBUG : level_str = \"debug\" case logging . INFO : level_str = \"info\" case logging . WARNING : level_str = \"warning\" case logging . ERROR : level_str = \"error\" case logging . CRITICAL : level_str = \"critical\" return level_str def execute_tick ( self ) -> NodeStatus : \"\"\" Performs pre-tick operations, calls the Node's tick() method, and then performs post-tick operations. If logging is enabled, then this is where log functions are called. Returns: `dendron.basic_types.NodeStatus`: The status returned by the inner call to tick(). \"\"\" if self . logger is not None : log_fn = getattr ( self . logger , self . _get_level_str ( self . log_level )) log_fn ( f \" { self . name } - pre_tick\" ) if self . pre_tick_fn is not None : self . pre_tick_fn () self . status = self . tick () if self . post_tick_fn is not None : self . post_tick_fn () if self . logger is not None : log_fn = getattr ( self . logger , self . _get_level_str ( self . log_level )) log_fn ( f \" { self . name } - post_tick { self . status } \" ) return self . status def set_description ( self , desc ) -> None : \"\"\" A textual description intended to help with automated policy construction. Args: desc (`str`): The textual description of this node's functionality. \"\"\" self . description = desc def halt_node ( self ) -> None : raise NotImplementedError ( \"Halt behavior is specified in subclass.\" ) def set_blackboard ( self , bb : Blackboard ) -> None : \"\"\" Set the blackboard to be used by this TreeNode. Args: bb (`dendron.blackboard.Blackboard`): The new blackboard. \"\"\" self . blackboard = bb # TODO consider deprecating def blackboard_set ( self , key , value ) -> None : full_key = self . name + '/' + key self . blackboard [ full_key ] = value # TODO consider deprecating def blackboard_get ( self , key ) -> Any : full_key = self . name + '/' + key return self . blackboard [ full_key ] def is_halted ( self ) -> bool : \"\"\" Query whether this node is in a halted state. Returns: `bool`: True iff the status is IDLE. \"\"\" return self . status == NodeStatus . IDLE def get_status ( self ) -> NodeStatus : \"\"\" Get the current status of this node. Returns: `dendron.basic_types.NodeStatus`: The node status. \"\"\" return self . status def set_status ( self , new_status : NodeStatus ) -> None : \"\"\" Set the node status to a new value. Args: new_status (`dendron.basic_types.NodeStatus`): The new NodeStatus. \"\"\" self . status = new_status def name ( self ) -> str : \"\"\" Get this node's human-readable name. Returns: `str`: The given name of this node. \"\"\" return self . name def node_type ( self ) -> NodeType : raise NotImplementedError ( \"Type is specified in subclass.\" ) # the problem with this is that Self is only supported in 3.11+, which # doesn't work with some libraries and packages. #def get_node_by_name(self, name : str) -> Optional[Self]: def get_node_by_name ( self , name : str ): \"\"\" Search for a node by its name. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" raise NotImplementedError ( \"get_node_by_name should be implemented in a subclass.\" ) def set_pre_tick ( self , f : Callable ) -> None : \"\"\" Specify a function-like object to be called before the `tick()` function. Args: f (`Callable`): The function to call before `tick()`. \"\"\" self . pre_tick_fn = types . MethodType ( f , self ) def set_post_tick ( self , f : Callable ) -> None : \"\"\" Specify a function-like object to be called after the `tick()` function. Args: f (`Callable`): The function to call after `tick()`. \"\"\" self . post_tick_fn = types . MethodType ( f , self ) def tick ( self ) -> NodeStatus : raise NotImplementedError ( \"Tick should be implemented in a subclass.\" ) def reset ( self ) -> None : \"\"\" Set the status of this node to IDLE. \"\"\" self . status = NodeStatus . IDLE def pretty_repr ( self , depth = 0 ) -> str : \"\"\" Return a string representation of this node at the given depth. Args: depth (`int`): The depth of this node in a surrounding tree. Returns: `str`: The indented string representation. \"\"\" raise NotImplementedError ( \"Pretty printing should be implemented in a subclass.\" )","title":"TreeNode"},{"location":"api/tree_node/#dendron.tree_node.TreeNode.execute_tick","text":"Performs pre-tick operations, calls the Node's tick() method, and then performs post-tick operations. If logging is enabled, then this is where log functions are called. Returns: Type Description NodeStatus dendron.basic_types.NodeStatus : The status returned by the inner NodeStatus call to tick(). Source code in src/dendron/tree_node.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def execute_tick ( self ) -> NodeStatus : \"\"\" Performs pre-tick operations, calls the Node's tick() method, and then performs post-tick operations. If logging is enabled, then this is where log functions are called. Returns: `dendron.basic_types.NodeStatus`: The status returned by the inner call to tick(). \"\"\" if self . logger is not None : log_fn = getattr ( self . logger , self . _get_level_str ( self . log_level )) log_fn ( f \" { self . name } - pre_tick\" ) if self . pre_tick_fn is not None : self . pre_tick_fn () self . status = self . tick () if self . post_tick_fn is not None : self . post_tick_fn () if self . logger is not None : log_fn = getattr ( self . logger , self . _get_level_str ( self . log_level )) log_fn ( f \" { self . name } - post_tick { self . status } \" ) return self . status","title":"execute_tick"},{"location":"api/tree_node/#dendron.tree_node.TreeNode.get_node_by_name","text":"Search for a node by its name. Parameters: Name Type Description Default name `str` The name of the node we are looking for. required Returns: Type Description Optional[TreeNode] : Either a node with the given name, or None. Source code in src/dendron/tree_node.py 177 178 179 180 181 182 183 184 185 186 187 188 189 def get_node_by_name ( self , name : str ): \"\"\" Search for a node by its name. Args: name (`str`): The name of the node we are looking for. Returns: `Optional[TreeNode]`: Either a node with the given name, or None. \"\"\" raise NotImplementedError ( \"get_node_by_name should be implemented in a subclass.\" )","title":"get_node_by_name"},{"location":"api/tree_node/#dendron.tree_node.TreeNode.get_status","text":"Get the current status of this node. Returns: Type Description NodeStatus dendron.basic_types.NodeStatus : The node status. Source code in src/dendron/tree_node.py 142 143 144 145 146 147 148 149 def get_status ( self ) -> NodeStatus : \"\"\" Get the current status of this node. Returns: `dendron.basic_types.NodeStatus`: The node status. \"\"\" return self . status","title":"get_status"},{"location":"api/tree_node/#dendron.tree_node.TreeNode.is_halted","text":"Query whether this node is in a halted state. Returns: Type Description bool bool : True iff the status is IDLE. Source code in src/dendron/tree_node.py 133 134 135 136 137 138 139 140 def is_halted ( self ) -> bool : \"\"\" Query whether this node is in a halted state. Returns: `bool`: True iff the status is IDLE. \"\"\" return self . status == NodeStatus . IDLE","title":"is_halted"},{"location":"api/tree_node/#dendron.tree_node.TreeNode.name","text":"Get this node's human-readable name. Returns: Type Description str str : The given name of this node. Source code in src/dendron/tree_node.py 161 162 163 164 165 166 167 168 def name ( self ) -> str : \"\"\" Get this node's human-readable name. Returns: `str`: The given name of this node. \"\"\" return self . name","title":"name"},{"location":"api/tree_node/#dendron.tree_node.TreeNode.pretty_repr","text":"Return a string representation of this node at the given depth. Parameters: Name Type Description Default depth `int` The depth of this node in a surrounding tree. 0 Returns: Type Description str str : The indented string representation. Source code in src/dendron/tree_node.py 222 223 224 225 226 227 228 229 230 231 232 233 def pretty_repr ( self , depth = 0 ) -> str : \"\"\" Return a string representation of this node at the given depth. Args: depth (`int`): The depth of this node in a surrounding tree. Returns: `str`: The indented string representation. \"\"\" raise NotImplementedError ( \"Pretty printing should be implemented in a subclass.\" )","title":"pretty_repr"},{"location":"api/tree_node/#dendron.tree_node.TreeNode.reset","text":"Set the status of this node to IDLE. Source code in src/dendron/tree_node.py 216 217 218 219 220 def reset ( self ) -> None : \"\"\" Set the status of this node to IDLE. \"\"\" self . status = NodeStatus . IDLE","title":"reset"},{"location":"api/tree_node/#dendron.tree_node.TreeNode.set_blackboard","text":"Set the blackboard to be used by this TreeNode. Parameters: Name Type Description Default bb `dendron.blackboard.Blackboard` The new blackboard. required Source code in src/dendron/tree_node.py 113 114 115 116 117 118 119 120 121 def set_blackboard ( self , bb : Blackboard ) -> None : \"\"\" Set the blackboard to be used by this TreeNode. Args: bb (`dendron.blackboard.Blackboard`): The new blackboard. \"\"\" self . blackboard = bb","title":"set_blackboard"},{"location":"api/tree_node/#dendron.tree_node.TreeNode.set_description","text":"A textual description intended to help with automated policy construction. Parameters: Name Type Description Default desc `str` The textual description of this node's functionality. required Source code in src/dendron/tree_node.py 99 100 101 102 103 104 105 106 107 108 def set_description ( self , desc ) -> None : \"\"\" A textual description intended to help with automated policy construction. Args: desc (`str`): The textual description of this node's functionality. \"\"\" self . description = desc","title":"set_description"},{"location":"api/tree_node/#dendron.tree_node.TreeNode.set_post_tick","text":"Specify a function-like object to be called after the tick() function. Parameters: Name Type Description Default f `Callable` The function to call after tick() . required Source code in src/dendron/tree_node.py 202 203 204 205 206 207 208 209 210 211 def set_post_tick ( self , f : Callable ) -> None : \"\"\" Specify a function-like object to be called after the `tick()` function. Args: f (`Callable`): The function to call after `tick()`. \"\"\" self . post_tick_fn = types . MethodType ( f , self )","title":"set_post_tick"},{"location":"api/tree_node/#dendron.tree_node.TreeNode.set_pre_tick","text":"Specify a function-like object to be called before the tick() function. Parameters: Name Type Description Default f `Callable` The function to call before tick() . required Source code in src/dendron/tree_node.py 191 192 193 194 195 196 197 198 199 200 def set_pre_tick ( self , f : Callable ) -> None : \"\"\" Specify a function-like object to be called before the `tick()` function. Args: f (`Callable`): The function to call before `tick()`. \"\"\" self . pre_tick_fn = types . MethodType ( f , self )","title":"set_pre_tick"},{"location":"api/tree_node/#dendron.tree_node.TreeNode.set_status","text":"Set the node status to a new value. Parameters: Name Type Description Default new_status `dendron.basic_types.NodeStatus` The new NodeStatus. required Source code in src/dendron/tree_node.py 151 152 153 154 155 156 157 158 159 def set_status ( self , new_status : NodeStatus ) -> None : \"\"\" Set the node status to a new value. Args: new_status (`dendron.basic_types.NodeStatus`): The new NodeStatus. \"\"\" self . status = new_status","title":"set_status"},{"location":"api/tree_node/#dendron.tree_node.TreeNode.set_tree","text":"Set the tree that contains this node. Parameters: Name Type Description Default tree `dendron.behavior_tree.BehaviorTree` The new tree this node is a part of. required Source code in src/dendron/tree_node.py 39 40 41 42 43 44 45 46 47 def set_tree ( self , tree : BehaviorTree ) -> None : \"\"\" Set the tree that contains this node. Args: tree (`dendron.behavior_tree.BehaviorTree`): The new tree this node is a part of. \"\"\" self . tree = tree","title":"set_tree"},{"location":"api/actions/always_failure/","text":"AlwaysFailure Bases: ActionNode An action node that always returns FAILURE . Parameters: Name Type Description Default name `str` The given name of this node. required Source code in src/dendron/actions/always_failure.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class AlwaysFailure ( ActionNode ): \"\"\" An action node that always returns `FAILURE`. Args: name (`str`): The given name of this node. \"\"\" def __init__ ( self , name : str ) -> None : super () . __init__ ( name ) def tick ( self ) -> NodeStatus : \"\"\" Always return `FAILURE`. \"\"\" return NodeStatus . FAILURE tick () Always return FAILURE . Source code in src/dendron/actions/always_failure.py 15 16 17 18 19 def tick ( self ) -> NodeStatus : \"\"\" Always return `FAILURE`. \"\"\" return NodeStatus . FAILURE","title":"AlwaysFailure"},{"location":"api/actions/always_failure/#alwaysfailure","text":"Bases: ActionNode An action node that always returns FAILURE . Parameters: Name Type Description Default name `str` The given name of this node. required Source code in src/dendron/actions/always_failure.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class AlwaysFailure ( ActionNode ): \"\"\" An action node that always returns `FAILURE`. Args: name (`str`): The given name of this node. \"\"\" def __init__ ( self , name : str ) -> None : super () . __init__ ( name ) def tick ( self ) -> NodeStatus : \"\"\" Always return `FAILURE`. \"\"\" return NodeStatus . FAILURE","title":"AlwaysFailure"},{"location":"api/actions/always_failure/#dendron.actions.always_failure.AlwaysFailure.tick","text":"Always return FAILURE . Source code in src/dendron/actions/always_failure.py 15 16 17 18 19 def tick ( self ) -> NodeStatus : \"\"\" Always return `FAILURE`. \"\"\" return NodeStatus . FAILURE","title":"tick"},{"location":"api/actions/always_success/","text":"AlwaysSuccess Bases: ActionNode An action node that always returns SUCCESS . Parameters: Name Type Description Default name `str` The given name of this node. required Source code in src/dendron/actions/always_success.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class AlwaysSuccess ( ActionNode ): \"\"\" An action node that always returns `SUCCESS`. Args: name (`str`): The given name of this node. \"\"\" def __init__ ( self , name : str ) -> None : super () . __init__ ( name ) def tick ( self ) -> NodeStatus : \"\"\" Always return `SUCCESS`. \"\"\" return NodeStatus . SUCCESS tick () Always return SUCCESS . Source code in src/dendron/actions/always_success.py 16 17 18 19 20 def tick ( self ) -> NodeStatus : \"\"\" Always return `SUCCESS`. \"\"\" return NodeStatus . SUCCESS","title":"AlwaysSuccess"},{"location":"api/actions/always_success/#alwayssuccess","text":"Bases: ActionNode An action node that always returns SUCCESS . Parameters: Name Type Description Default name `str` The given name of this node. required Source code in src/dendron/actions/always_success.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class AlwaysSuccess ( ActionNode ): \"\"\" An action node that always returns `SUCCESS`. Args: name (`str`): The given name of this node. \"\"\" def __init__ ( self , name : str ) -> None : super () . __init__ ( name ) def tick ( self ) -> NodeStatus : \"\"\" Always return `SUCCESS`. \"\"\" return NodeStatus . SUCCESS","title":"AlwaysSuccess"},{"location":"api/actions/always_success/#dendron.actions.always_success.AlwaysSuccess.tick","text":"Always return SUCCESS . Source code in src/dendron/actions/always_success.py 16 17 18 19 20 def tick ( self ) -> NodeStatus : \"\"\" Always return `SUCCESS`. \"\"\" return NodeStatus . SUCCESS","title":"tick"},{"location":"api/actions/async_action/","text":"AsyncAction Bases: ActionNode An action node that operates asynchronously. Once ticked, the node enters a RUNNING state, which it remains in until the node's Callable returns with a status. That status is what gets returned by the tick function the next time it is called. Internally, this node maintains a future to store the eventual result of the asynchronous computation. Asynchronous execution is handled by the node's tree's executor, which means this node cannot run without an enclosing tree. Parameters: Name Type Description Default name `str` The given name of this node. required cb `Callable` The callable object that will be executed asynchronously. required Source code in src/dendron/actions/async_action.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class AsyncAction ( ActionNode ): \"\"\" An action node that operates asynchronously. Once ticked, the node enters a `RUNNING` state, which it remains in until the node's `Callable` returns with a status. That status is what gets returned by the tick function the next time it is called. Internally, this node maintains a future to store the eventual result of the asynchronous computation. Asynchronous execution is handled by the node's tree's executor, which means this node cannot run without an enclosing tree. Args: name (`str`): The given name of this node. cb (`Callable`): The callable object that will be executed asynchronously. \"\"\" def __init__ ( self , name : str , cb : Callable ) -> None : super () . __init__ ( name ) self . cb = cb self . fut = None def reset ( self ) -> None : \"\"\" Set the status of this node to `IDLE`, and clear out the node's future. \"\"\" self . status = NodeStatus . IDLE self . fut = None def tick ( self ) -> NodeStatus : \"\"\" Asynchronously execute this node's callback. Returns: `NodeStatus`: The status contained in the node's future, or `RUNNING` if the node is not yet done. \"\"\" if self . fut is None : self . fut = self . tree . executor . submit ( self . cb ) self . fut . add_done_callback ( lambda f : self . set_status ( f . result ())) if self . fut . done (): old_status = self . status self . reset () return old_status else : return NodeStatus . RUNNING reset () Set the status of this node to IDLE , and clear out the node's future. Source code in src/dendron/actions/async_action.py 36 37 38 39 40 41 42 def reset ( self ) -> None : \"\"\" Set the status of this node to `IDLE`, and clear out the node's future. \"\"\" self . status = NodeStatus . IDLE self . fut = None tick () Asynchronously execute this node's callback. Returns: Type Description NodeStatus NodeStatus : The status contained in the node's future, or NodeStatus RUNNING if the node is not yet done. Source code in src/dendron/actions/async_action.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def tick ( self ) -> NodeStatus : \"\"\" Asynchronously execute this node's callback. Returns: `NodeStatus`: The status contained in the node's future, or `RUNNING` if the node is not yet done. \"\"\" if self . fut is None : self . fut = self . tree . executor . submit ( self . cb ) self . fut . add_done_callback ( lambda f : self . set_status ( f . result ())) if self . fut . done (): old_status = self . status self . reset () return old_status else : return NodeStatus . RUNNING","title":"AsyncAction"},{"location":"api/actions/async_action/#asyncaction","text":"Bases: ActionNode An action node that operates asynchronously. Once ticked, the node enters a RUNNING state, which it remains in until the node's Callable returns with a status. That status is what gets returned by the tick function the next time it is called. Internally, this node maintains a future to store the eventual result of the asynchronous computation. Asynchronous execution is handled by the node's tree's executor, which means this node cannot run without an enclosing tree. Parameters: Name Type Description Default name `str` The given name of this node. required cb `Callable` The callable object that will be executed asynchronously. required Source code in src/dendron/actions/async_action.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class AsyncAction ( ActionNode ): \"\"\" An action node that operates asynchronously. Once ticked, the node enters a `RUNNING` state, which it remains in until the node's `Callable` returns with a status. That status is what gets returned by the tick function the next time it is called. Internally, this node maintains a future to store the eventual result of the asynchronous computation. Asynchronous execution is handled by the node's tree's executor, which means this node cannot run without an enclosing tree. Args: name (`str`): The given name of this node. cb (`Callable`): The callable object that will be executed asynchronously. \"\"\" def __init__ ( self , name : str , cb : Callable ) -> None : super () . __init__ ( name ) self . cb = cb self . fut = None def reset ( self ) -> None : \"\"\" Set the status of this node to `IDLE`, and clear out the node's future. \"\"\" self . status = NodeStatus . IDLE self . fut = None def tick ( self ) -> NodeStatus : \"\"\" Asynchronously execute this node's callback. Returns: `NodeStatus`: The status contained in the node's future, or `RUNNING` if the node is not yet done. \"\"\" if self . fut is None : self . fut = self . tree . executor . submit ( self . cb ) self . fut . add_done_callback ( lambda f : self . set_status ( f . result ())) if self . fut . done (): old_status = self . status self . reset () return old_status else : return NodeStatus . RUNNING","title":"AsyncAction"},{"location":"api/actions/async_action/#dendron.actions.async_action.AsyncAction.reset","text":"Set the status of this node to IDLE , and clear out the node's future. Source code in src/dendron/actions/async_action.py 36 37 38 39 40 41 42 def reset ( self ) -> None : \"\"\" Set the status of this node to `IDLE`, and clear out the node's future. \"\"\" self . status = NodeStatus . IDLE self . fut = None","title":"reset"},{"location":"api/actions/async_action/#dendron.actions.async_action.AsyncAction.tick","text":"Asynchronously execute this node's callback. Returns: Type Description NodeStatus NodeStatus : The status contained in the node's future, or NodeStatus RUNNING if the node is not yet done. Source code in src/dendron/actions/async_action.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def tick ( self ) -> NodeStatus : \"\"\" Asynchronously execute this node's callback. Returns: `NodeStatus`: The status contained in the node's future, or `RUNNING` if the node is not yet done. \"\"\" if self . fut is None : self . fut = self . tree . executor . submit ( self . cb ) self . fut . add_done_callback ( lambda f : self . set_status ( f . result ())) if self . fut . done (): old_status = self . status self . reset () return old_status else : return NodeStatus . RUNNING","title":"tick"},{"location":"api/actions/causal_lm_action/","text":"CausalLMAction Configuration Configuration for a CausalLMAction. The options in this object control what Hugging Face model is used, how the node interacts with the blackboard, and what decoding strategy is used. If you want a refresher on decoding strategies, check out this blog post: https://huggingface.co/blog/how-to-generate. Parameters: Name Type Description Default model_name `str` The name of the model to use. This should be a valid name corresponding to a Hugging Face model name (including the user name). required auto_load `Optional[bool]` An optional boolean indicating whether or not to automatically load model either from disk or the Hugging Face hub. If False , the user is responsible for ensuring that a model is loaded before the first tick() is triggered. Defaults to True . field (default=True) input_key `Optional[str]` The blackboard key to use for writing and reading the prompt that this node will consume. Defaults to \"in\". field (default='in') output_key `Optional[str]` The blackboard key to use for writing and reading the text generated by this node. Defaults to \"out\". field (default='out') device `Optional[str]` The device that should be used with the model. Examples include \"cpu\", \"cuda\", and \"auto\". Defaults to \"auto\". field (default='auto') load_in_8bit `Optional[bool]` Optional boolean indicating whether or not to use eight-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. Defaults to False . field (default=False) load_in_4bit `Optional[bool]` Optional boolean indicating whether or not to use four-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. If you observe degraded performance, try eight-bit quanitization instead. Defaults to False . field (default=False) max_new_tokens `Optional[int]` A limit on the number of new tokens to generate. You will usually want to set this yourself based on your application. Defaults to 16. field (default=16) do_sample `Optional[bool]` Optional boolean to control decoding strategy. If set to true, allows use of non-default generation strategy. Defaults to False . field (default=False) top_p `Optional[float]` Optional float to control use of nucleus sampling. If the value is strictly between 0 and 1, nucleus sampling is activated. field (default=1.0) torch_dtype `torch.dtype` The dtype to use for torch tensors. Defaults to torch.float16 . You may need to change this depending on your quantization choices. field (default= float16 ) use_flash_attn_2 `Optional[bool]` Optional bool controlling whether or not to use Flash Attention 2. Defaults to False in case you haven't installed flash attention. Substantially speeds up inference. field (default=False) Source code in src/dendron/actions/causal_lm_action.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 @dataclass class CausalLMActionConfig : \"\"\" Configuration for a CausalLMAction. The options in this object control what Hugging Face model is used, how the node interacts with the blackboard, and what decoding strategy is used. If you want a refresher on decoding strategies, check out this blog post: https://huggingface.co/blog/how-to-generate. Args: model_name (`str`): The name of the model to use. This should be a valid name corresponding to a Hugging Face model name (including the user name). auto_load (`Optional[bool]`): An optional boolean indicating whether or not to automatically load model either from disk or the Hugging Face hub. If `False`, the user is responsible for ensuring that a model is loaded before the first `tick()` is triggered. Defaults to `True`. input_key (`Optional[str]`): The blackboard key to use for writing and reading the prompt that this node will consume. Defaults to \"in\". output_key (`Optional[str]`): The blackboard key to use for writing and reading the text generated by this node. Defaults to \"out\". device (`Optional[str]`): The device that should be used with the model. Examples include \"cpu\", \"cuda\", and \"auto\". Defaults to \"auto\". load_in_8bit (`Optional[bool]`): Optional boolean indicating whether or not to use eight-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. Defaults to `False`. load_in_4bit (`Optional[bool]`): Optional boolean indicating whether or not to use four-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. If you observe degraded performance, try eight-bit quanitization instead. Defaults to `False`. max_new_tokens (`Optional[int]`): A limit on the number of new tokens to generate. You will usually want to set this yourself based on your application. Defaults to 16. do_sample (`Optional[bool]`): Optional boolean to control decoding strategy. If set to true, allows use of non-default generation strategy. Defaults to `False`. top_p (`Optional[float]`): Optional float to control use of nucleus sampling. If the value is strictly between 0 and 1, nucleus sampling is activated. torch_dtype (`torch.dtype`): The dtype to use for torch tensors. Defaults to `torch.float16`. You may need to change this depending on your quantization choices. use_flash_attn_2 (`Optional[bool]`): Optional bool controlling whether or not to use Flash Attention 2. Defaults to `False` in case you haven't installed flash attention. Substantially speeds up inference. \"\"\" model_name : str auto_load : Optional [ bool ] = field ( default = True ) input_key : Optional [ str ] = field ( default = \"in\" ) output_key : Optional [ str ] = field ( default = \"out\" ) device : Optional [ str ] = field ( default = \"auto\" ) load_in_8bit : Optional [ bool ] = field ( default = False ) load_in_4bit : Optional [ bool ] = field ( default = False ) max_new_tokens : Optional [ int ] = field ( default = 16 ) do_sample : Optional [ bool ] = field ( default = False ) top_p : Optional [ float ] = field ( default = 1.0 ) torch_dtype : Optional [ torch . dtype ] = field ( default = torch . float16 ) use_flash_attn_2 : Optional [ bool ] = field ( default = False ) CausalLMAction Bases: ActionNode An action node that uses a causal language model to generate some text based on a prompt contained in the node's blackboard. This node is based on the Hugging Face transformers library, and will download the model that you specify by name. This can take a long time and/or use a lot of storage, depending on the model you name. There are enough configuration options for this type of node that the options have all been placed in a dataclass config object. See the documentation for that object to learn about the many options available to you. Parameters: Name Type Description Default name `str` The given name of this node. required cfg `CausalLMActionConfig` The configuration object for this model. required Source code in src/dendron/actions/causal_lm_action.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 class CausalLMAction ( ActionNode ): \"\"\" An action node that uses a causal language model to generate some text based on a prompt contained in the node's blackboard. This node is based on the Hugging Face transformers library, and will download the model that you specify by name. This can take a long time and/or use a lot of storage, depending on the model you name. There are enough configuration options for this type of node that the options have all been placed in a dataclass config object. See the documentation for that object to learn about the many options available to you. Args: name (`str`): The given name of this node. cfg (`CausalLMActionConfig`): The configuration object for this model. \"\"\" def __init__ ( self , name : str , cfg : CausalLMActionConfig ) -> None : super () . __init__ ( name ) self . input_key = cfg . input_key self . output_key = cfg . output_key self . device = cfg . device self . max_new_tokens = cfg . max_new_tokens self . do_sample = cfg . do_sample self . top_p = cfg . top_p self . torch_dtype = cfg . torch_dtype match cfg . load_in_4bit , cfg . load_in_8bit : case True , True : self . quantization = Quantization . FourBit case True , False : self . quantization = Quantization . FourBit case False , True : self . quantization = Quantization . EightBit case False , False : self . quantization = Quantization . NoQuantization if cfg . use_flash_attn_2 : self . attn_implementation = \"flash_attention_2\" else : self . attn_implementation = \"sdpa\" if cfg . auto_load : match self . quantization : case Quantization . NoQuantization : self . model = AutoModelForCausalLM . from_pretrained ( cfg . model_name , torch_dtype = self . torch_dtype , low_cpu_mem_usage = True , attn_implementation = self . attn_implementation ) case Quantization . FourBit : self . model = AutoModelForCausalLM . from_pretrained ( cfg . model_name , load_in_4bit = True , torch_dtype = self . torch_dtype , low_cpu_mem_usage = True , attn_implementation = self . attn_implementation , bnb_4bit_compute_dtype = cfg . torch_dtype ) case Quantization . EightBit : self . model = AutoModelForCausalLM . from_pretrained ( cfg . model_name , load_in_8bit = True , torch_dtype = self . torch_dtype , low_cpu_mem_usage = True , attn_implementation = self . attn_implementation ) self . model . eval () self . tokenizer = AutoTokenizer . from_pretrained ( cfg . model_name ) if self . tokenizer . pad_token is None : self . tokenizer . pad_token = self . tokenizer . eos_token else : self . model = None self . tokenizer = None self . input_processor = None self . output_processor = None def set_model ( self , new_model ) -> None : \"\"\" Set a new model to use for generating text. \"\"\" self . model = new_model self . model . eval () self . tokenizer = AutoTokenizer . from_pretrained ( new_model . name_or_path ) def set_input_processor ( self , f : Callable ) -> None : \"\"\" Set the input processor to use during `tick()`s. An input processor is applied to the prompt text stored in the blackboard, and can be used to preprocess the prompt. The processor function should be a map from `str` to `str`. During a `tick()`, the output of this function will be what is tokenized and sent to the model for generation. Args: f (`Callable`): The input processor function to use. Should be a callable object that maps (self, Any) to str. \"\"\" self . input_processor = types . MethodType ( f , self ) def set_output_processor ( self , f : Callable ) -> None : \"\"\" Set the output processor to use during `tick()`s. An output processor is applied to the text generated by the model, before that text is written to the output slot of the blackboard. The function should be a map from `str` to `str`. A typical example of an output processor would be a function that removes the prompt from the text returned by a model, so that only the newly generated text is written to the blackboard. Args: f (`Callable`): The output processor function. Should be a callable object that maps from (self, str) to Any. \"\"\" self . output_processor = types . MethodType ( f , self ) def tick ( self ) -> NodeStatus : \"\"\" Execute a tick, consisting of the following steps: - Retrieve a prompt from the node's blackboard, using the input_key. - Apply the input processor, if one exists. - Tokenize the prompt text. - Generate new tokens based on the prompt. - Decode the model output into a text string. - Apply the output processor, if one exists, - Write the result back to the blackboard, using the output_key. If any of the above fail, the exception text is printed and the node returns a status of `FAILURE`. Otherwise the node returns `SUCCESS`. If you want to use a language model to make decisions, consider looking at the `CompletionConditionNode`. \"\"\" try : input_text = self . blackboard [ self . input_key ] if self . input_processor : input_text = self . input_processor ( input_text ) input_ids = self . tokenizer ( input_text , return_tensors = \"pt\" ) . to ( self . model . device ) generated_ids = self . model . generate ( ** input_ids , max_new_tokens = self . max_new_tokens , pad_token_id = self . tokenizer . pad_token_id , do_sample = self . do_sample , top_p = self . top_p ) output_text = self . tokenizer . batch_decode ( generated_ids , skip_special_tokens = True , clean_up_tokenization_spaces = False )[ 0 ] if self . output_processor : output_text = self . output_processor ( output_text ) self . blackboard [ self . output_key ] = output_text return NodeStatus . SUCCESS except Exception as ex : print ( f \"Exception in node { self . name } :\" ) print ( traceback . format_exc ()) return NodeStatus . FAILURE set_model ( new_model ) Set a new model to use for generating text. Source code in src/dendron/actions/causal_lm_action.py 192 193 194 195 196 197 198 def set_model ( self , new_model ) -> None : \"\"\" Set a new model to use for generating text. \"\"\" self . model = new_model self . model . eval () self . tokenizer = AutoTokenizer . from_pretrained ( new_model . name_or_path ) set_input_processor ( f ) Set the input processor to use during tick() s. An input processor is applied to the prompt text stored in the blackboard, and can be used to preprocess the prompt. The processor function should be a map from str to str . During a tick() , the output of this function will be what is tokenized and sent to the model for generation. Parameters: Name Type Description Default f `Callable` The input processor function to use. Should be a callable object that maps (self, Any) to str. required Source code in src/dendron/actions/causal_lm_action.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def set_input_processor ( self , f : Callable ) -> None : \"\"\" Set the input processor to use during `tick()`s. An input processor is applied to the prompt text stored in the blackboard, and can be used to preprocess the prompt. The processor function should be a map from `str` to `str`. During a `tick()`, the output of this function will be what is tokenized and sent to the model for generation. Args: f (`Callable`): The input processor function to use. Should be a callable object that maps (self, Any) to str. \"\"\" self . input_processor = types . MethodType ( f , self ) set_output_processor ( f ) Set the output processor to use during tick() s. An output processor is applied to the text generated by the model, before that text is written to the output slot of the blackboard. The function should be a map from str to str . A typical example of an output processor would be a function that removes the prompt from the text returned by a model, so that only the newly generated text is written to the blackboard. Parameters: Name Type Description Default f `Callable` The output processor function. Should be a callable object that maps from (self, str) to Any. required Source code in src/dendron/actions/causal_lm_action.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def set_output_processor ( self , f : Callable ) -> None : \"\"\" Set the output processor to use during `tick()`s. An output processor is applied to the text generated by the model, before that text is written to the output slot of the blackboard. The function should be a map from `str` to `str`. A typical example of an output processor would be a function that removes the prompt from the text returned by a model, so that only the newly generated text is written to the blackboard. Args: f (`Callable`): The output processor function. Should be a callable object that maps from (self, str) to Any. \"\"\" self . output_processor = types . MethodType ( f , self ) tick () Execute a tick, consisting of the following steps: Retrieve a prompt from the node's blackboard, using the input_key. Apply the input processor, if one exists. Tokenize the prompt text. Generate new tokens based on the prompt. Decode the model output into a text string. Apply the output processor, if one exists, Write the result back to the blackboard, using the output_key. If any of the above fail, the exception text is printed and the node returns a status of FAILURE . Otherwise the node returns SUCCESS . If you want to use a language model to make decisions, consider looking at the CompletionConditionNode . Source code in src/dendron/actions/causal_lm_action.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 def tick ( self ) -> NodeStatus : \"\"\" Execute a tick, consisting of the following steps: - Retrieve a prompt from the node's blackboard, using the input_key. - Apply the input processor, if one exists. - Tokenize the prompt text. - Generate new tokens based on the prompt. - Decode the model output into a text string. - Apply the output processor, if one exists, - Write the result back to the blackboard, using the output_key. If any of the above fail, the exception text is printed and the node returns a status of `FAILURE`. Otherwise the node returns `SUCCESS`. If you want to use a language model to make decisions, consider looking at the `CompletionConditionNode`. \"\"\" try : input_text = self . blackboard [ self . input_key ] if self . input_processor : input_text = self . input_processor ( input_text ) input_ids = self . tokenizer ( input_text , return_tensors = \"pt\" ) . to ( self . model . device ) generated_ids = self . model . generate ( ** input_ids , max_new_tokens = self . max_new_tokens , pad_token_id = self . tokenizer . pad_token_id , do_sample = self . do_sample , top_p = self . top_p ) output_text = self . tokenizer . batch_decode ( generated_ids , skip_special_tokens = True , clean_up_tokenization_spaces = False )[ 0 ] if self . output_processor : output_text = self . output_processor ( output_text ) self . blackboard [ self . output_key ] = output_text return NodeStatus . SUCCESS except Exception as ex : print ( f \"Exception in node { self . name } :\" ) print ( traceback . format_exc ()) return NodeStatus . FAILURE","title":"CausalLMAction"},{"location":"api/actions/causal_lm_action/#causallmaction","text":"","title":"CausalLMAction"},{"location":"api/actions/causal_lm_action/#configuration","text":"Configuration for a CausalLMAction. The options in this object control what Hugging Face model is used, how the node interacts with the blackboard, and what decoding strategy is used. If you want a refresher on decoding strategies, check out this blog post: https://huggingface.co/blog/how-to-generate. Parameters: Name Type Description Default model_name `str` The name of the model to use. This should be a valid name corresponding to a Hugging Face model name (including the user name). required auto_load `Optional[bool]` An optional boolean indicating whether or not to automatically load model either from disk or the Hugging Face hub. If False , the user is responsible for ensuring that a model is loaded before the first tick() is triggered. Defaults to True . field (default=True) input_key `Optional[str]` The blackboard key to use for writing and reading the prompt that this node will consume. Defaults to \"in\". field (default='in') output_key `Optional[str]` The blackboard key to use for writing and reading the text generated by this node. Defaults to \"out\". field (default='out') device `Optional[str]` The device that should be used with the model. Examples include \"cpu\", \"cuda\", and \"auto\". Defaults to \"auto\". field (default='auto') load_in_8bit `Optional[bool]` Optional boolean indicating whether or not to use eight-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. Defaults to False . field (default=False) load_in_4bit `Optional[bool]` Optional boolean indicating whether or not to use four-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. If you observe degraded performance, try eight-bit quanitization instead. Defaults to False . field (default=False) max_new_tokens `Optional[int]` A limit on the number of new tokens to generate. You will usually want to set this yourself based on your application. Defaults to 16. field (default=16) do_sample `Optional[bool]` Optional boolean to control decoding strategy. If set to true, allows use of non-default generation strategy. Defaults to False . field (default=False) top_p `Optional[float]` Optional float to control use of nucleus sampling. If the value is strictly between 0 and 1, nucleus sampling is activated. field (default=1.0) torch_dtype `torch.dtype` The dtype to use for torch tensors. Defaults to torch.float16 . You may need to change this depending on your quantization choices. field (default= float16 ) use_flash_attn_2 `Optional[bool]` Optional bool controlling whether or not to use Flash Attention 2. Defaults to False in case you haven't installed flash attention. Substantially speeds up inference. field (default=False) Source code in src/dendron/actions/causal_lm_action.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 @dataclass class CausalLMActionConfig : \"\"\" Configuration for a CausalLMAction. The options in this object control what Hugging Face model is used, how the node interacts with the blackboard, and what decoding strategy is used. If you want a refresher on decoding strategies, check out this blog post: https://huggingface.co/blog/how-to-generate. Args: model_name (`str`): The name of the model to use. This should be a valid name corresponding to a Hugging Face model name (including the user name). auto_load (`Optional[bool]`): An optional boolean indicating whether or not to automatically load model either from disk or the Hugging Face hub. If `False`, the user is responsible for ensuring that a model is loaded before the first `tick()` is triggered. Defaults to `True`. input_key (`Optional[str]`): The blackboard key to use for writing and reading the prompt that this node will consume. Defaults to \"in\". output_key (`Optional[str]`): The blackboard key to use for writing and reading the text generated by this node. Defaults to \"out\". device (`Optional[str]`): The device that should be used with the model. Examples include \"cpu\", \"cuda\", and \"auto\". Defaults to \"auto\". load_in_8bit (`Optional[bool]`): Optional boolean indicating whether or not to use eight-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. Defaults to `False`. load_in_4bit (`Optional[bool]`): Optional boolean indicating whether or not to use four-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. If you observe degraded performance, try eight-bit quanitization instead. Defaults to `False`. max_new_tokens (`Optional[int]`): A limit on the number of new tokens to generate. You will usually want to set this yourself based on your application. Defaults to 16. do_sample (`Optional[bool]`): Optional boolean to control decoding strategy. If set to true, allows use of non-default generation strategy. Defaults to `False`. top_p (`Optional[float]`): Optional float to control use of nucleus sampling. If the value is strictly between 0 and 1, nucleus sampling is activated. torch_dtype (`torch.dtype`): The dtype to use for torch tensors. Defaults to `torch.float16`. You may need to change this depending on your quantization choices. use_flash_attn_2 (`Optional[bool]`): Optional bool controlling whether or not to use Flash Attention 2. Defaults to `False` in case you haven't installed flash attention. Substantially speeds up inference. \"\"\" model_name : str auto_load : Optional [ bool ] = field ( default = True ) input_key : Optional [ str ] = field ( default = \"in\" ) output_key : Optional [ str ] = field ( default = \"out\" ) device : Optional [ str ] = field ( default = \"auto\" ) load_in_8bit : Optional [ bool ] = field ( default = False ) load_in_4bit : Optional [ bool ] = field ( default = False ) max_new_tokens : Optional [ int ] = field ( default = 16 ) do_sample : Optional [ bool ] = field ( default = False ) top_p : Optional [ float ] = field ( default = 1.0 ) torch_dtype : Optional [ torch . dtype ] = field ( default = torch . float16 ) use_flash_attn_2 : Optional [ bool ] = field ( default = False )","title":"Configuration"},{"location":"api/actions/causal_lm_action/#causallmaction_1","text":"Bases: ActionNode An action node that uses a causal language model to generate some text based on a prompt contained in the node's blackboard. This node is based on the Hugging Face transformers library, and will download the model that you specify by name. This can take a long time and/or use a lot of storage, depending on the model you name. There are enough configuration options for this type of node that the options have all been placed in a dataclass config object. See the documentation for that object to learn about the many options available to you. Parameters: Name Type Description Default name `str` The given name of this node. required cfg `CausalLMActionConfig` The configuration object for this model. required Source code in src/dendron/actions/causal_lm_action.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 class CausalLMAction ( ActionNode ): \"\"\" An action node that uses a causal language model to generate some text based on a prompt contained in the node's blackboard. This node is based on the Hugging Face transformers library, and will download the model that you specify by name. This can take a long time and/or use a lot of storage, depending on the model you name. There are enough configuration options for this type of node that the options have all been placed in a dataclass config object. See the documentation for that object to learn about the many options available to you. Args: name (`str`): The given name of this node. cfg (`CausalLMActionConfig`): The configuration object for this model. \"\"\" def __init__ ( self , name : str , cfg : CausalLMActionConfig ) -> None : super () . __init__ ( name ) self . input_key = cfg . input_key self . output_key = cfg . output_key self . device = cfg . device self . max_new_tokens = cfg . max_new_tokens self . do_sample = cfg . do_sample self . top_p = cfg . top_p self . torch_dtype = cfg . torch_dtype match cfg . load_in_4bit , cfg . load_in_8bit : case True , True : self . quantization = Quantization . FourBit case True , False : self . quantization = Quantization . FourBit case False , True : self . quantization = Quantization . EightBit case False , False : self . quantization = Quantization . NoQuantization if cfg . use_flash_attn_2 : self . attn_implementation = \"flash_attention_2\" else : self . attn_implementation = \"sdpa\" if cfg . auto_load : match self . quantization : case Quantization . NoQuantization : self . model = AutoModelForCausalLM . from_pretrained ( cfg . model_name , torch_dtype = self . torch_dtype , low_cpu_mem_usage = True , attn_implementation = self . attn_implementation ) case Quantization . FourBit : self . model = AutoModelForCausalLM . from_pretrained ( cfg . model_name , load_in_4bit = True , torch_dtype = self . torch_dtype , low_cpu_mem_usage = True , attn_implementation = self . attn_implementation , bnb_4bit_compute_dtype = cfg . torch_dtype ) case Quantization . EightBit : self . model = AutoModelForCausalLM . from_pretrained ( cfg . model_name , load_in_8bit = True , torch_dtype = self . torch_dtype , low_cpu_mem_usage = True , attn_implementation = self . attn_implementation ) self . model . eval () self . tokenizer = AutoTokenizer . from_pretrained ( cfg . model_name ) if self . tokenizer . pad_token is None : self . tokenizer . pad_token = self . tokenizer . eos_token else : self . model = None self . tokenizer = None self . input_processor = None self . output_processor = None def set_model ( self , new_model ) -> None : \"\"\" Set a new model to use for generating text. \"\"\" self . model = new_model self . model . eval () self . tokenizer = AutoTokenizer . from_pretrained ( new_model . name_or_path ) def set_input_processor ( self , f : Callable ) -> None : \"\"\" Set the input processor to use during `tick()`s. An input processor is applied to the prompt text stored in the blackboard, and can be used to preprocess the prompt. The processor function should be a map from `str` to `str`. During a `tick()`, the output of this function will be what is tokenized and sent to the model for generation. Args: f (`Callable`): The input processor function to use. Should be a callable object that maps (self, Any) to str. \"\"\" self . input_processor = types . MethodType ( f , self ) def set_output_processor ( self , f : Callable ) -> None : \"\"\" Set the output processor to use during `tick()`s. An output processor is applied to the text generated by the model, before that text is written to the output slot of the blackboard. The function should be a map from `str` to `str`. A typical example of an output processor would be a function that removes the prompt from the text returned by a model, so that only the newly generated text is written to the blackboard. Args: f (`Callable`): The output processor function. Should be a callable object that maps from (self, str) to Any. \"\"\" self . output_processor = types . MethodType ( f , self ) def tick ( self ) -> NodeStatus : \"\"\" Execute a tick, consisting of the following steps: - Retrieve a prompt from the node's blackboard, using the input_key. - Apply the input processor, if one exists. - Tokenize the prompt text. - Generate new tokens based on the prompt. - Decode the model output into a text string. - Apply the output processor, if one exists, - Write the result back to the blackboard, using the output_key. If any of the above fail, the exception text is printed and the node returns a status of `FAILURE`. Otherwise the node returns `SUCCESS`. If you want to use a language model to make decisions, consider looking at the `CompletionConditionNode`. \"\"\" try : input_text = self . blackboard [ self . input_key ] if self . input_processor : input_text = self . input_processor ( input_text ) input_ids = self . tokenizer ( input_text , return_tensors = \"pt\" ) . to ( self . model . device ) generated_ids = self . model . generate ( ** input_ids , max_new_tokens = self . max_new_tokens , pad_token_id = self . tokenizer . pad_token_id , do_sample = self . do_sample , top_p = self . top_p ) output_text = self . tokenizer . batch_decode ( generated_ids , skip_special_tokens = True , clean_up_tokenization_spaces = False )[ 0 ] if self . output_processor : output_text = self . output_processor ( output_text ) self . blackboard [ self . output_key ] = output_text return NodeStatus . SUCCESS except Exception as ex : print ( f \"Exception in node { self . name } :\" ) print ( traceback . format_exc ()) return NodeStatus . FAILURE","title":"CausalLMAction"},{"location":"api/actions/causal_lm_action/#dendron.actions.causal_lm_action.CausalLMAction.set_model","text":"Set a new model to use for generating text. Source code in src/dendron/actions/causal_lm_action.py 192 193 194 195 196 197 198 def set_model ( self , new_model ) -> None : \"\"\" Set a new model to use for generating text. \"\"\" self . model = new_model self . model . eval () self . tokenizer = AutoTokenizer . from_pretrained ( new_model . name_or_path )","title":"set_model"},{"location":"api/actions/causal_lm_action/#dendron.actions.causal_lm_action.CausalLMAction.set_input_processor","text":"Set the input processor to use during tick() s. An input processor is applied to the prompt text stored in the blackboard, and can be used to preprocess the prompt. The processor function should be a map from str to str . During a tick() , the output of this function will be what is tokenized and sent to the model for generation. Parameters: Name Type Description Default f `Callable` The input processor function to use. Should be a callable object that maps (self, Any) to str. required Source code in src/dendron/actions/causal_lm_action.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def set_input_processor ( self , f : Callable ) -> None : \"\"\" Set the input processor to use during `tick()`s. An input processor is applied to the prompt text stored in the blackboard, and can be used to preprocess the prompt. The processor function should be a map from `str` to `str`. During a `tick()`, the output of this function will be what is tokenized and sent to the model for generation. Args: f (`Callable`): The input processor function to use. Should be a callable object that maps (self, Any) to str. \"\"\" self . input_processor = types . MethodType ( f , self )","title":"set_input_processor"},{"location":"api/actions/causal_lm_action/#dendron.actions.causal_lm_action.CausalLMAction.set_output_processor","text":"Set the output processor to use during tick() s. An output processor is applied to the text generated by the model, before that text is written to the output slot of the blackboard. The function should be a map from str to str . A typical example of an output processor would be a function that removes the prompt from the text returned by a model, so that only the newly generated text is written to the blackboard. Parameters: Name Type Description Default f `Callable` The output processor function. Should be a callable object that maps from (self, str) to Any. required Source code in src/dendron/actions/causal_lm_action.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def set_output_processor ( self , f : Callable ) -> None : \"\"\" Set the output processor to use during `tick()`s. An output processor is applied to the text generated by the model, before that text is written to the output slot of the blackboard. The function should be a map from `str` to `str`. A typical example of an output processor would be a function that removes the prompt from the text returned by a model, so that only the newly generated text is written to the blackboard. Args: f (`Callable`): The output processor function. Should be a callable object that maps from (self, str) to Any. \"\"\" self . output_processor = types . MethodType ( f , self )","title":"set_output_processor"},{"location":"api/actions/causal_lm_action/#dendron.actions.causal_lm_action.CausalLMAction.tick","text":"Execute a tick, consisting of the following steps: Retrieve a prompt from the node's blackboard, using the input_key. Apply the input processor, if one exists. Tokenize the prompt text. Generate new tokens based on the prompt. Decode the model output into a text string. Apply the output processor, if one exists, Write the result back to the blackboard, using the output_key. If any of the above fail, the exception text is printed and the node returns a status of FAILURE . Otherwise the node returns SUCCESS . If you want to use a language model to make decisions, consider looking at the CompletionConditionNode . Source code in src/dendron/actions/causal_lm_action.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 def tick ( self ) -> NodeStatus : \"\"\" Execute a tick, consisting of the following steps: - Retrieve a prompt from the node's blackboard, using the input_key. - Apply the input processor, if one exists. - Tokenize the prompt text. - Generate new tokens based on the prompt. - Decode the model output into a text string. - Apply the output processor, if one exists, - Write the result back to the blackboard, using the output_key. If any of the above fail, the exception text is printed and the node returns a status of `FAILURE`. Otherwise the node returns `SUCCESS`. If you want to use a language model to make decisions, consider looking at the `CompletionConditionNode`. \"\"\" try : input_text = self . blackboard [ self . input_key ] if self . input_processor : input_text = self . input_processor ( input_text ) input_ids = self . tokenizer ( input_text , return_tensors = \"pt\" ) . to ( self . model . device ) generated_ids = self . model . generate ( ** input_ids , max_new_tokens = self . max_new_tokens , pad_token_id = self . tokenizer . pad_token_id , do_sample = self . do_sample , top_p = self . top_p ) output_text = self . tokenizer . batch_decode ( generated_ids , skip_special_tokens = True , clean_up_tokenization_spaces = False )[ 0 ] if self . output_processor : output_text = self . output_processor ( output_text ) self . blackboard [ self . output_key ] = output_text return NodeStatus . SUCCESS except Exception as ex : print ( f \"Exception in node { self . name } :\" ) print ( traceback . format_exc ()) return NodeStatus . FAILURE","title":"tick"},{"location":"api/actions/image_lm_action/","text":"ImageLMAction Configuration Configuration for an ImageLMAction. The options in this object control what Hugging Face model is used, how the node interacts with the blackboard, and what decoding strategy is used. If you want a refresher on decoding strategies, check out this blog post: https://huggingface.co/blog/how-to-generate. Parameters: Name Type Description Default model_name `str` The name of the model to use. This should be a valid name corresponding to a Hugging Face model name (including the user name). required auto_load `Optional[bool]` An optional boolean indicating whether or not to automatically load model either from disk or the Hugging Face hub. If False , the user is responsible for ensuring that a model is loaded before the first tick() is triggered. Defaults to True . field (default=True) text_input_key `Optional[str]` The blackboard key to use for writing and reading the text prompt that this node will consume. Defaults to \"text_in\". field (default='text_in') image_input_key `Optional[str]` The blackboard key to use for writing and reading the image prompt that this node will consume. Defaults to \"image_in\". field (default='image_in') output_key `Optional[str]` The blackboard key to use for writing and reading the text generated by this node. Defaults to \"out\". field (default='out') device `Optional[str]` The device that should be used with the model. Examples include \"cpu\", \"cuda\", and \"auto\". Defaults to \"auto\". field (default='auto') load_in_8bit `Optional[bool]` Optional boolean indicating whether or not to use eight-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. Defaults to False . field (default=False) load_in_4bit `Optional[bool]` Optional boolean indicating whether or not to use four-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. If you observe degraded performance, try eight-bit quanitization instead. Defaults to False . field (default=False) max_new_tokens `Optional[int]` A limit on the number of new tokens to generate. You will usually want to set this yourself based on your application. Defaults to 16. field (default=16) do_sample `Optional[bool]` Optional boolean to control decoding strategy. If set to true, allows use of non-default generation strategy. Defaults to False . field (default=False) top_p `Optional[float]` Optional float to control use of nucleus sampling. If the value is strictly between 0 and 1, nucleus sampling is activated. field (default=1.0) torch_dtype `torch.dtype` The dtype to use for torch tensors. Defaults to torch.float16 . You may need to change this depending on your quantization choices. field (default= float16 ) use_flash_attn_2 `Optional[bool]` Optional bool controlling whether or not to use Flash Attention 2. Defaults to False in case you haven't installed flash attention. Substantially speeds up inference. field (default=False) Source code in src/dendron/actions/image_lm_action.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 @dataclass class ImageLMActionConfig : \"\"\" Configuration for an ImageLMAction. The options in this object control what Hugging Face model is used, how the node interacts with the blackboard, and what decoding strategy is used. If you want a refresher on decoding strategies, check out this blog post: https://huggingface.co/blog/how-to-generate. Args: model_name (`str`): The name of the model to use. This should be a valid name corresponding to a Hugging Face model name (including the user name). auto_load (`Optional[bool]`): An optional boolean indicating whether or not to automatically load model either from disk or the Hugging Face hub. If `False`, the user is responsible for ensuring that a model is loaded before the first `tick()` is triggered. Defaults to `True`. text_input_key (`Optional[str]`): The blackboard key to use for writing and reading the text prompt that this node will consume. Defaults to \"text_in\". image_input_key (`Optional[str]`): The blackboard key to use for writing and reading the image prompt that this node will consume. Defaults to \"image_in\". output_key (`Optional[str]`): The blackboard key to use for writing and reading the text generated by this node. Defaults to \"out\". device (`Optional[str]`): The device that should be used with the model. Examples include \"cpu\", \"cuda\", and \"auto\". Defaults to \"auto\". load_in_8bit (`Optional[bool]`): Optional boolean indicating whether or not to use eight-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. Defaults to `False`. load_in_4bit (`Optional[bool]`): Optional boolean indicating whether or not to use four-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. If you observe degraded performance, try eight-bit quanitization instead. Defaults to `False`. max_new_tokens (`Optional[int]`): A limit on the number of new tokens to generate. You will usually want to set this yourself based on your application. Defaults to 16. do_sample (`Optional[bool]`): Optional boolean to control decoding strategy. If set to true, allows use of non-default generation strategy. Defaults to `False`. top_p (`Optional[float]`): Optional float to control use of nucleus sampling. If the value is strictly between 0 and 1, nucleus sampling is activated. torch_dtype (`torch.dtype`): The dtype to use for torch tensors. Defaults to `torch.float16`. You may need to change this depending on your quantization choices. use_flash_attn_2 (`Optional[bool]`): Optional bool controlling whether or not to use Flash Attention 2. Defaults to `False` in case you haven't installed flash attention. Substantially speeds up inference. \"\"\" model_name : str auto_load : Optional [ bool ] = field ( default = True ) text_input_key : Optional [ str ] = field ( default = \"text_in\" ) image_input_key : Optional [ str ] = field ( default = \"image_in\" ) output_key : Optional [ str ] = field ( default = \"out\" ) device : Optional [ str ] = field ( default = \"auto\" ) load_in_8bit : Optional [ bool ] = field ( default = False ) load_in_4bit : Optional [ bool ] = field ( default = False ) max_new_tokens : Optional [ int ] = field ( default = 16 ) do_sample : Optional [ bool ] = field ( default = False ) top_p : Optional [ float ] = field ( default = 1.0 ) torch_dtype : Optional [ torch . dtype ] = field ( default = torch . float16 ) use_flash_attn_2 : Optional [ bool ] = field ( default = False ) ImageLMAction Bases: ActionNode An action node that uses a vision-language model to generate some text based on an image prompt and a text prompt contained in the model's blackboard. This node is based on the Hugging Face transformers library, and will download the model that you specify by name. This can take a long time and/or use a lot of storage, depending on the model you name. There are enough configuration options for this type of node that the options have all been placed in a dataclass config object. See the documentation for that object to learn about the many options available to you. Parameters: Name Type Description Default cfg `ImageLMActionConfig` The configuration object for this model. required Source code in src/dendron/actions/image_lm_action.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 class ImageLMAction ( ActionNode ): \"\"\" An action node that uses a vision-language model to generate some text based on an image prompt and a text prompt contained in the model's blackboard. This node is based on the Hugging Face transformers library, and will download the model that you specify by name. This can take a long time and/or use a lot of storage, depending on the model you name. There are enough configuration options for this type of node that the options have all been placed in a dataclass config object. See the documentation for that object to learn about the many options available to you. Args: cfg (`ImageLMActionConfig`): The configuration object for this model. \"\"\" def __init__ ( self , name : str , cfg : ImageLMActionConfig ) -> None : super () . __init__ ( name ) self . text_input_key = cfg . text_input_key self . image_input_key = cfg . image_input_key self . output_key = cfg . output_key self . device = cfg . device self . max_new_tokens = cfg . max_new_tokens self . do_sample = cfg . do_sample self . top_p = cfg . top_p self . torch_dtype = cfg . torch_dtype match cfg . load_in_4bit , cfg . load_in_8bit : case True , True : self . quantization = Quantization . FourBit case True , False : self . quantization = Quantization . FourBit case False , True : self . quantization = Quantization . EightBit case False , False : self . quantization = Quantization . NoQuantization if cfg . use_flash_attn_2 : self . attn_implementation = \"flash_attention_2\" else : self . attn_implementation = \"sdpa\" if cfg . auto_load : match self . quantization : case Quantization . NoQuantization : self . model = LlavaForConditionalGeneration . from_pretrained ( cfg . model_name , torch_dtype = cfg . torch_dtype , low_cpu_mem_usage = True , attn_implementation = self . attn_implementation ) . to ( self . device ) case Quantization . FourBit : self . model = LlavaForConditionalGeneration . from_pretrained ( cfg . model_name , load_in_4bit = True , torch_dtype = cfg . torch_dtype , low_cpu_mem_usage = True , attn_implementation = self . attn_implementation , bnb_4bit_compute_dtype = cfg . torch_dtype ) case Quantization . EightBit : self . model = LlavaForConditionalGeneration . from_pretrained ( cfg . model_name , load_in_8bit = True , torch_dtype = cfg . torch_dtype , low_cpu_mem_usage = True , attn_implementation = self . attn_implementation ) self . model . eval () self . processor = AutoProcessor . from_pretrained ( cfg . model_name ) else : self . model = None self . processor = None self . input_processor = None self . output_processor = None def set_model ( self , new_model ) -> None : \"\"\" Set a new model to use for generating text. \"\"\" self . model = new_model self . model . eval () self . processor = AutoProcessor . from_pretrained ( new_model . name_or_path ) def set_input_processor ( self , f : Callable ) -> None : \"\"\" Set the input processor to use during `tick()`s. An input processor is applied to the prompt image and the prompt text stored in the blackboard, and can be used to preprocess the prompt. The processor function should be a map from `str` to `str`. During a `tick()`, the output of this function will be what is tokenized and sent to the model for generation. Args: f (`Callable`): The input processor function to use. Should be a callable object that maps (image,string) pairs to (image,string) pairs. \"\"\" self . input_processor = types . MethodType ( f , self ) def set_output_processor ( self , f : Callable ) -> None : \"\"\" Set the output processor to use during `tick()`s. An output processor is applied to the text generated by the model, before that text is written to the output slot of the blackboard. The function should be a map from `str` to `str`. A typical example of an output processor would be a function that removes the prompt from the text returned by a model, so that only the newly generated text is written to the blackboard. Args: f (`Callable`): The output processor function. Should be a callable object that maps strings to strings. \"\"\" self . output_processor = types . MethodType ( f , self ) def tick ( self ) -> NodeStatus : \"\"\" Execute a tick, consisting of the following steps: - Retrieve the text prompt and image prompt for the node's blackboard. - Apply the input processor, if one exists, - Process the input text and image into ids for the model. - Generate new tokens based on the processed prompt. - Decode the model output into a text string. - Apply the output processor, if one exists. - Write the output text to the blackboard. If any of the above fail, the exception text is printed and the node returns a status of `FAILURE`. Otherwise the node returns `SUCCESS`. \"\"\" try : input_text = self . blackboard [ self . text_input_key ] input_image = self . blackboard [ self . image_input_key ] if self . input_processor : input_text , input_image = self . input_processor ( input_text , input_image ) input_ids = self . processor ( text = input_text , images = input_image , return_tensors = \"pt\" ) . to ( self . model . device , self . torch_dtype ) generated_ids = self . model . generate ( ** input_ids , max_new_tokens = self . max_new_tokens , do_sample = self . do_sample , top_p = self . top_p ) output_text = self . processor . batch_decode ( generated_ids , skip_special_tokens = True , clean_up_tokenization_spaces = False )[ 0 ] if self . output_processor : output_text = self . output_processor ( output_text ) self . blackboard [ self . output_key ] = output_text return NodeStatus . SUCCESS except Exception as ex : print ( f \"Exception in node { self . name } :\" ) print ( traceback . format_exc ()) return NodeStatus . FAILURE set_model ( new_model ) Set a new model to use for generating text. Source code in src/dendron/actions/image_lm_action.py 195 196 197 198 199 200 201 def set_model ( self , new_model ) -> None : \"\"\" Set a new model to use for generating text. \"\"\" self . model = new_model self . model . eval () self . processor = AutoProcessor . from_pretrained ( new_model . name_or_path ) set_input_processor ( f ) Set the input processor to use during tick() s. An input processor is applied to the prompt image and the prompt text stored in the blackboard, and can be used to preprocess the prompt. The processor function should be a map from str to str . During a tick() , the output of this function will be what is tokenized and sent to the model for generation. Parameters: Name Type Description Default f `Callable` The input processor function to use. Should be a callable object that maps (image,string) pairs to (image,string) pairs. required Source code in src/dendron/actions/image_lm_action.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def set_input_processor ( self , f : Callable ) -> None : \"\"\" Set the input processor to use during `tick()`s. An input processor is applied to the prompt image and the prompt text stored in the blackboard, and can be used to preprocess the prompt. The processor function should be a map from `str` to `str`. During a `tick()`, the output of this function will be what is tokenized and sent to the model for generation. Args: f (`Callable`): The input processor function to use. Should be a callable object that maps (image,string) pairs to (image,string) pairs. \"\"\" self . input_processor = types . MethodType ( f , self ) set_output_processor ( f ) Set the output processor to use during tick() s. An output processor is applied to the text generated by the model, before that text is written to the output slot of the blackboard. The function should be a map from str to str . A typical example of an output processor would be a function that removes the prompt from the text returned by a model, so that only the newly generated text is written to the blackboard. Parameters: Name Type Description Default f `Callable` The output processor function. Should be a callable object that maps strings to strings. required Source code in src/dendron/actions/image_lm_action.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def set_output_processor ( self , f : Callable ) -> None : \"\"\" Set the output processor to use during `tick()`s. An output processor is applied to the text generated by the model, before that text is written to the output slot of the blackboard. The function should be a map from `str` to `str`. A typical example of an output processor would be a function that removes the prompt from the text returned by a model, so that only the newly generated text is written to the blackboard. Args: f (`Callable`): The output processor function. Should be a callable object that maps strings to strings. \"\"\" self . output_processor = types . MethodType ( f , self ) tick () Execute a tick, consisting of the following steps: Retrieve the text prompt and image prompt for the node's blackboard. Apply the input processor, if one exists, Process the input text and image into ids for the model. Generate new tokens based on the processed prompt. Decode the model output into a text string. Apply the output processor, if one exists. Write the output text to the blackboard. If any of the above fail, the exception text is printed and the node returns a status of FAILURE . Otherwise the node returns SUCCESS . Source code in src/dendron/actions/image_lm_action.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def tick ( self ) -> NodeStatus : \"\"\" Execute a tick, consisting of the following steps: - Retrieve the text prompt and image prompt for the node's blackboard. - Apply the input processor, if one exists, - Process the input text and image into ids for the model. - Generate new tokens based on the processed prompt. - Decode the model output into a text string. - Apply the output processor, if one exists. - Write the output text to the blackboard. If any of the above fail, the exception text is printed and the node returns a status of `FAILURE`. Otherwise the node returns `SUCCESS`. \"\"\" try : input_text = self . blackboard [ self . text_input_key ] input_image = self . blackboard [ self . image_input_key ] if self . input_processor : input_text , input_image = self . input_processor ( input_text , input_image ) input_ids = self . processor ( text = input_text , images = input_image , return_tensors = \"pt\" ) . to ( self . model . device , self . torch_dtype ) generated_ids = self . model . generate ( ** input_ids , max_new_tokens = self . max_new_tokens , do_sample = self . do_sample , top_p = self . top_p ) output_text = self . processor . batch_decode ( generated_ids , skip_special_tokens = True , clean_up_tokenization_spaces = False )[ 0 ] if self . output_processor : output_text = self . output_processor ( output_text ) self . blackboard [ self . output_key ] = output_text return NodeStatus . SUCCESS except Exception as ex : print ( f \"Exception in node { self . name } :\" ) print ( traceback . format_exc ()) return NodeStatus . FAILURE","title":"ImageLMAction"},{"location":"api/actions/image_lm_action/#imagelmaction","text":"","title":"ImageLMAction"},{"location":"api/actions/image_lm_action/#configuration","text":"Configuration for an ImageLMAction. The options in this object control what Hugging Face model is used, how the node interacts with the blackboard, and what decoding strategy is used. If you want a refresher on decoding strategies, check out this blog post: https://huggingface.co/blog/how-to-generate. Parameters: Name Type Description Default model_name `str` The name of the model to use. This should be a valid name corresponding to a Hugging Face model name (including the user name). required auto_load `Optional[bool]` An optional boolean indicating whether or not to automatically load model either from disk or the Hugging Face hub. If False , the user is responsible for ensuring that a model is loaded before the first tick() is triggered. Defaults to True . field (default=True) text_input_key `Optional[str]` The blackboard key to use for writing and reading the text prompt that this node will consume. Defaults to \"text_in\". field (default='text_in') image_input_key `Optional[str]` The blackboard key to use for writing and reading the image prompt that this node will consume. Defaults to \"image_in\". field (default='image_in') output_key `Optional[str]` The blackboard key to use for writing and reading the text generated by this node. Defaults to \"out\". field (default='out') device `Optional[str]` The device that should be used with the model. Examples include \"cpu\", \"cuda\", and \"auto\". Defaults to \"auto\". field (default='auto') load_in_8bit `Optional[bool]` Optional boolean indicating whether or not to use eight-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. Defaults to False . field (default=False) load_in_4bit `Optional[bool]` Optional boolean indicating whether or not to use four-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. If you observe degraded performance, try eight-bit quanitization instead. Defaults to False . field (default=False) max_new_tokens `Optional[int]` A limit on the number of new tokens to generate. You will usually want to set this yourself based on your application. Defaults to 16. field (default=16) do_sample `Optional[bool]` Optional boolean to control decoding strategy. If set to true, allows use of non-default generation strategy. Defaults to False . field (default=False) top_p `Optional[float]` Optional float to control use of nucleus sampling. If the value is strictly between 0 and 1, nucleus sampling is activated. field (default=1.0) torch_dtype `torch.dtype` The dtype to use for torch tensors. Defaults to torch.float16 . You may need to change this depending on your quantization choices. field (default= float16 ) use_flash_attn_2 `Optional[bool]` Optional bool controlling whether or not to use Flash Attention 2. Defaults to False in case you haven't installed flash attention. Substantially speeds up inference. field (default=False) Source code in src/dendron/actions/image_lm_action.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 @dataclass class ImageLMActionConfig : \"\"\" Configuration for an ImageLMAction. The options in this object control what Hugging Face model is used, how the node interacts with the blackboard, and what decoding strategy is used. If you want a refresher on decoding strategies, check out this blog post: https://huggingface.co/blog/how-to-generate. Args: model_name (`str`): The name of the model to use. This should be a valid name corresponding to a Hugging Face model name (including the user name). auto_load (`Optional[bool]`): An optional boolean indicating whether or not to automatically load model either from disk or the Hugging Face hub. If `False`, the user is responsible for ensuring that a model is loaded before the first `tick()` is triggered. Defaults to `True`. text_input_key (`Optional[str]`): The blackboard key to use for writing and reading the text prompt that this node will consume. Defaults to \"text_in\". image_input_key (`Optional[str]`): The blackboard key to use for writing and reading the image prompt that this node will consume. Defaults to \"image_in\". output_key (`Optional[str]`): The blackboard key to use for writing and reading the text generated by this node. Defaults to \"out\". device (`Optional[str]`): The device that should be used with the model. Examples include \"cpu\", \"cuda\", and \"auto\". Defaults to \"auto\". load_in_8bit (`Optional[bool]`): Optional boolean indicating whether or not to use eight-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. Defaults to `False`. load_in_4bit (`Optional[bool]`): Optional boolean indicating whether or not to use four-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. If you observe degraded performance, try eight-bit quanitization instead. Defaults to `False`. max_new_tokens (`Optional[int]`): A limit on the number of new tokens to generate. You will usually want to set this yourself based on your application. Defaults to 16. do_sample (`Optional[bool]`): Optional boolean to control decoding strategy. If set to true, allows use of non-default generation strategy. Defaults to `False`. top_p (`Optional[float]`): Optional float to control use of nucleus sampling. If the value is strictly between 0 and 1, nucleus sampling is activated. torch_dtype (`torch.dtype`): The dtype to use for torch tensors. Defaults to `torch.float16`. You may need to change this depending on your quantization choices. use_flash_attn_2 (`Optional[bool]`): Optional bool controlling whether or not to use Flash Attention 2. Defaults to `False` in case you haven't installed flash attention. Substantially speeds up inference. \"\"\" model_name : str auto_load : Optional [ bool ] = field ( default = True ) text_input_key : Optional [ str ] = field ( default = \"text_in\" ) image_input_key : Optional [ str ] = field ( default = \"image_in\" ) output_key : Optional [ str ] = field ( default = \"out\" ) device : Optional [ str ] = field ( default = \"auto\" ) load_in_8bit : Optional [ bool ] = field ( default = False ) load_in_4bit : Optional [ bool ] = field ( default = False ) max_new_tokens : Optional [ int ] = field ( default = 16 ) do_sample : Optional [ bool ] = field ( default = False ) top_p : Optional [ float ] = field ( default = 1.0 ) torch_dtype : Optional [ torch . dtype ] = field ( default = torch . float16 ) use_flash_attn_2 : Optional [ bool ] = field ( default = False )","title":"Configuration"},{"location":"api/actions/image_lm_action/#imagelmaction_1","text":"Bases: ActionNode An action node that uses a vision-language model to generate some text based on an image prompt and a text prompt contained in the model's blackboard. This node is based on the Hugging Face transformers library, and will download the model that you specify by name. This can take a long time and/or use a lot of storage, depending on the model you name. There are enough configuration options for this type of node that the options have all been placed in a dataclass config object. See the documentation for that object to learn about the many options available to you. Parameters: Name Type Description Default cfg `ImageLMActionConfig` The configuration object for this model. required Source code in src/dendron/actions/image_lm_action.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 class ImageLMAction ( ActionNode ): \"\"\" An action node that uses a vision-language model to generate some text based on an image prompt and a text prompt contained in the model's blackboard. This node is based on the Hugging Face transformers library, and will download the model that you specify by name. This can take a long time and/or use a lot of storage, depending on the model you name. There are enough configuration options for this type of node that the options have all been placed in a dataclass config object. See the documentation for that object to learn about the many options available to you. Args: cfg (`ImageLMActionConfig`): The configuration object for this model. \"\"\" def __init__ ( self , name : str , cfg : ImageLMActionConfig ) -> None : super () . __init__ ( name ) self . text_input_key = cfg . text_input_key self . image_input_key = cfg . image_input_key self . output_key = cfg . output_key self . device = cfg . device self . max_new_tokens = cfg . max_new_tokens self . do_sample = cfg . do_sample self . top_p = cfg . top_p self . torch_dtype = cfg . torch_dtype match cfg . load_in_4bit , cfg . load_in_8bit : case True , True : self . quantization = Quantization . FourBit case True , False : self . quantization = Quantization . FourBit case False , True : self . quantization = Quantization . EightBit case False , False : self . quantization = Quantization . NoQuantization if cfg . use_flash_attn_2 : self . attn_implementation = \"flash_attention_2\" else : self . attn_implementation = \"sdpa\" if cfg . auto_load : match self . quantization : case Quantization . NoQuantization : self . model = LlavaForConditionalGeneration . from_pretrained ( cfg . model_name , torch_dtype = cfg . torch_dtype , low_cpu_mem_usage = True , attn_implementation = self . attn_implementation ) . to ( self . device ) case Quantization . FourBit : self . model = LlavaForConditionalGeneration . from_pretrained ( cfg . model_name , load_in_4bit = True , torch_dtype = cfg . torch_dtype , low_cpu_mem_usage = True , attn_implementation = self . attn_implementation , bnb_4bit_compute_dtype = cfg . torch_dtype ) case Quantization . EightBit : self . model = LlavaForConditionalGeneration . from_pretrained ( cfg . model_name , load_in_8bit = True , torch_dtype = cfg . torch_dtype , low_cpu_mem_usage = True , attn_implementation = self . attn_implementation ) self . model . eval () self . processor = AutoProcessor . from_pretrained ( cfg . model_name ) else : self . model = None self . processor = None self . input_processor = None self . output_processor = None def set_model ( self , new_model ) -> None : \"\"\" Set a new model to use for generating text. \"\"\" self . model = new_model self . model . eval () self . processor = AutoProcessor . from_pretrained ( new_model . name_or_path ) def set_input_processor ( self , f : Callable ) -> None : \"\"\" Set the input processor to use during `tick()`s. An input processor is applied to the prompt image and the prompt text stored in the blackboard, and can be used to preprocess the prompt. The processor function should be a map from `str` to `str`. During a `tick()`, the output of this function will be what is tokenized and sent to the model for generation. Args: f (`Callable`): The input processor function to use. Should be a callable object that maps (image,string) pairs to (image,string) pairs. \"\"\" self . input_processor = types . MethodType ( f , self ) def set_output_processor ( self , f : Callable ) -> None : \"\"\" Set the output processor to use during `tick()`s. An output processor is applied to the text generated by the model, before that text is written to the output slot of the blackboard. The function should be a map from `str` to `str`. A typical example of an output processor would be a function that removes the prompt from the text returned by a model, so that only the newly generated text is written to the blackboard. Args: f (`Callable`): The output processor function. Should be a callable object that maps strings to strings. \"\"\" self . output_processor = types . MethodType ( f , self ) def tick ( self ) -> NodeStatus : \"\"\" Execute a tick, consisting of the following steps: - Retrieve the text prompt and image prompt for the node's blackboard. - Apply the input processor, if one exists, - Process the input text and image into ids for the model. - Generate new tokens based on the processed prompt. - Decode the model output into a text string. - Apply the output processor, if one exists. - Write the output text to the blackboard. If any of the above fail, the exception text is printed and the node returns a status of `FAILURE`. Otherwise the node returns `SUCCESS`. \"\"\" try : input_text = self . blackboard [ self . text_input_key ] input_image = self . blackboard [ self . image_input_key ] if self . input_processor : input_text , input_image = self . input_processor ( input_text , input_image ) input_ids = self . processor ( text = input_text , images = input_image , return_tensors = \"pt\" ) . to ( self . model . device , self . torch_dtype ) generated_ids = self . model . generate ( ** input_ids , max_new_tokens = self . max_new_tokens , do_sample = self . do_sample , top_p = self . top_p ) output_text = self . processor . batch_decode ( generated_ids , skip_special_tokens = True , clean_up_tokenization_spaces = False )[ 0 ] if self . output_processor : output_text = self . output_processor ( output_text ) self . blackboard [ self . output_key ] = output_text return NodeStatus . SUCCESS except Exception as ex : print ( f \"Exception in node { self . name } :\" ) print ( traceback . format_exc ()) return NodeStatus . FAILURE","title":"ImageLMAction"},{"location":"api/actions/image_lm_action/#dendron.actions.image_lm_action.ImageLMAction.set_model","text":"Set a new model to use for generating text. Source code in src/dendron/actions/image_lm_action.py 195 196 197 198 199 200 201 def set_model ( self , new_model ) -> None : \"\"\" Set a new model to use for generating text. \"\"\" self . model = new_model self . model . eval () self . processor = AutoProcessor . from_pretrained ( new_model . name_or_path )","title":"set_model"},{"location":"api/actions/image_lm_action/#dendron.actions.image_lm_action.ImageLMAction.set_input_processor","text":"Set the input processor to use during tick() s. An input processor is applied to the prompt image and the prompt text stored in the blackboard, and can be used to preprocess the prompt. The processor function should be a map from str to str . During a tick() , the output of this function will be what is tokenized and sent to the model for generation. Parameters: Name Type Description Default f `Callable` The input processor function to use. Should be a callable object that maps (image,string) pairs to (image,string) pairs. required Source code in src/dendron/actions/image_lm_action.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def set_input_processor ( self , f : Callable ) -> None : \"\"\" Set the input processor to use during `tick()`s. An input processor is applied to the prompt image and the prompt text stored in the blackboard, and can be used to preprocess the prompt. The processor function should be a map from `str` to `str`. During a `tick()`, the output of this function will be what is tokenized and sent to the model for generation. Args: f (`Callable`): The input processor function to use. Should be a callable object that maps (image,string) pairs to (image,string) pairs. \"\"\" self . input_processor = types . MethodType ( f , self )","title":"set_input_processor"},{"location":"api/actions/image_lm_action/#dendron.actions.image_lm_action.ImageLMAction.set_output_processor","text":"Set the output processor to use during tick() s. An output processor is applied to the text generated by the model, before that text is written to the output slot of the blackboard. The function should be a map from str to str . A typical example of an output processor would be a function that removes the prompt from the text returned by a model, so that only the newly generated text is written to the blackboard. Parameters: Name Type Description Default f `Callable` The output processor function. Should be a callable object that maps strings to strings. required Source code in src/dendron/actions/image_lm_action.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def set_output_processor ( self , f : Callable ) -> None : \"\"\" Set the output processor to use during `tick()`s. An output processor is applied to the text generated by the model, before that text is written to the output slot of the blackboard. The function should be a map from `str` to `str`. A typical example of an output processor would be a function that removes the prompt from the text returned by a model, so that only the newly generated text is written to the blackboard. Args: f (`Callable`): The output processor function. Should be a callable object that maps strings to strings. \"\"\" self . output_processor = types . MethodType ( f , self )","title":"set_output_processor"},{"location":"api/actions/image_lm_action/#dendron.actions.image_lm_action.ImageLMAction.tick","text":"Execute a tick, consisting of the following steps: Retrieve the text prompt and image prompt for the node's blackboard. Apply the input processor, if one exists, Process the input text and image into ids for the model. Generate new tokens based on the processed prompt. Decode the model output into a text string. Apply the output processor, if one exists. Write the output text to the blackboard. If any of the above fail, the exception text is printed and the node returns a status of FAILURE . Otherwise the node returns SUCCESS . Source code in src/dendron/actions/image_lm_action.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def tick ( self ) -> NodeStatus : \"\"\" Execute a tick, consisting of the following steps: - Retrieve the text prompt and image prompt for the node's blackboard. - Apply the input processor, if one exists, - Process the input text and image into ids for the model. - Generate new tokens based on the processed prompt. - Decode the model output into a text string. - Apply the output processor, if one exists. - Write the output text to the blackboard. If any of the above fail, the exception text is printed and the node returns a status of `FAILURE`. Otherwise the node returns `SUCCESS`. \"\"\" try : input_text = self . blackboard [ self . text_input_key ] input_image = self . blackboard [ self . image_input_key ] if self . input_processor : input_text , input_image = self . input_processor ( input_text , input_image ) input_ids = self . processor ( text = input_text , images = input_image , return_tensors = \"pt\" ) . to ( self . model . device , self . torch_dtype ) generated_ids = self . model . generate ( ** input_ids , max_new_tokens = self . max_new_tokens , do_sample = self . do_sample , top_p = self . top_p ) output_text = self . processor . batch_decode ( generated_ids , skip_special_tokens = True , clean_up_tokenization_spaces = False )[ 0 ] if self . output_processor : output_text = self . output_processor ( output_text ) self . blackboard [ self . output_key ] = output_text return NodeStatus . SUCCESS except Exception as ex : print ( f \"Exception in node { self . name } :\" ) print ( traceback . format_exc ()) return NodeStatus . FAILURE","title":"tick"},{"location":"api/actions/pipeline_action/","text":"PipelineAction Configuration Configuration for a PipelineAction. The options in this object control what Hugging Face task and model are used and how the node interacts with the blackboard. Parameters: Name Type Description Default task_name `str` The name of the Hugging Facetask to use. This should be a valid HF task name. For an overview of the tasks that HF supports, see https://huggingface.co/tasks. required model `Optional[str]` Optional name of a model to use. This should be a valid name corresponding to a Hugging Face model name (including the user name). Defaults to None, in which case the default model for the pipeline task will be used. field (default=None) input_key `Optional[str]` The blackboard key to use for writing and reading the prompt that this node will consume. Defaults to \"in\". field (default='in') output_key `Optional[str]` The blackboard key to use for writing and reading the text generated by this node. Defaults to \"out\". field (default='out') device `Optional[str]` The device that should be used with the model. Examples include \"cpu\", \"cuda\", and \"auto\". Defaults to \"auto\". field (default='auto') Source code in src/dendron/actions/pipeline_action.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @dataclass class PipelineActionConfig : \"\"\" Configuration for a PipelineAction. The options in this object control what Hugging Face task and model are used and how the node interacts with the blackboard. Args: task_name (`str`): The name of the Hugging Facetask to use. This should be a valid HF task name. For an overview of the tasks that HF supports, see https://huggingface.co/tasks. model (`Optional[str]`): Optional name of a model to use. This should be a valid name corresponding to a Hugging Face model name (including the user name). Defaults to None, in which case the default model for the pipeline task will be used. input_key (`Optional[str]`): The blackboard key to use for writing and reading the prompt that this node will consume. Defaults to \"in\". output_key (`Optional[str]`): The blackboard key to use for writing and reading the text generated by this node. Defaults to \"out\". device (`Optional[str]`): The device that should be used with the model. Examples include \"cpu\", \"cuda\", and \"auto\". Defaults to \"auto\". \"\"\" task_name : str model : Optional [ str ] = field ( default = None ) input_key : Optional [ str ] = field ( default = \"in\" ) output_key : Optional [ str ] = field ( default = \"out\" ) device : Optional [ str ] = field ( default = \"auto\" ) ImageLMAction Bases: ActionNode An action node that uses a Hugging Face transformers pipeline object to execute a behavior. This enables easy access to functionality such as sentiment classification that is wrapped in a Pipeline. This is also useful for quick prototyping with HF defaults. This node is based on the Hugging Face transformers library, and will download the model that you specify by name. This can take a long time and/or use a lot of storage, depending on the model you name. There are enough configuration options for this type of node that the options have all been placed in a dataclass config object. See the documentation for that object to learn about the many options available to you. Parameters: Name Type Description Default name `str` The given name of this node. required cfg `PipelineActionConfig` The configuration object for this model. required Source code in src/dendron/actions/pipeline_action.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 class PipelineAction ( ActionNode ): \"\"\" An action node that uses a Hugging Face transformers pipeline object to execute a behavior. This enables easy access to functionality such as sentiment classification that is wrapped in a Pipeline. This is also useful for quick prototyping with HF defaults. This node is based on the Hugging Face transformers library, and will download the model that you specify by name. This can take a long time and/or use a lot of storage, depending on the model you name. There are enough configuration options for this type of node that the options have all been placed in a dataclass config object. See the documentation for that object to learn about the many options available to you. Args: name (`str`): The given name of this node. cfg (`PipelineActionConfig`): The configuration object for this model. \"\"\" def __init__ ( self , name : str , cfg : PipelineActionConfig ) -> None : super () . __init__ ( name ) self . task_name = cfg . task_name self . input_key = cfg . input_key self . output_key = cfg . output_key self . device = cfg . device if cfg . model : self . pipeline = pipeline ( cfg . task_name , model = cfg . model , device_map = self . device ) else : self . pipeline = pipeline ( cfg . task_name , device_map = self . device ) def tick ( self ) -> NodeStatus : \"\"\" Execute a tick, consisting of the following steps: - Retrieve a prompt from the node's blackboard. - Apply the pipeline object to the input text. - Write the output to the blackboard. If any of the above fail, then the node returns a status of `FAILURE`. Otherwise the node returns a status of `SUCCESS`. \"\"\" try : input_text = self . blackboard [ self . input_key ] output = self . pipeline ( input_text ) self . blackboard [ self . output_key ] = output return NodeStatus . SUCCESS except : return NodeStatus . FAILURE tick () Execute a tick, consisting of the following steps: Retrieve a prompt from the node's blackboard. Apply the pipeline object to the input text. Write the output to the blackboard. If any of the above fail, then the node returns a status of FAILURE . Otherwise the node returns a status of SUCCESS . Source code in src/dendron/actions/pipeline_action.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def tick ( self ) -> NodeStatus : \"\"\" Execute a tick, consisting of the following steps: - Retrieve a prompt from the node's blackboard. - Apply the pipeline object to the input text. - Write the output to the blackboard. If any of the above fail, then the node returns a status of `FAILURE`. Otherwise the node returns a status of `SUCCESS`. \"\"\" try : input_text = self . blackboard [ self . input_key ] output = self . pipeline ( input_text ) self . blackboard [ self . output_key ] = output return NodeStatus . SUCCESS except : return NodeStatus . FAILURE","title":"PipelineAction"},{"location":"api/actions/pipeline_action/#pipelineaction","text":"","title":"PipelineAction"},{"location":"api/actions/pipeline_action/#configuration","text":"Configuration for a PipelineAction. The options in this object control what Hugging Face task and model are used and how the node interacts with the blackboard. Parameters: Name Type Description Default task_name `str` The name of the Hugging Facetask to use. This should be a valid HF task name. For an overview of the tasks that HF supports, see https://huggingface.co/tasks. required model `Optional[str]` Optional name of a model to use. This should be a valid name corresponding to a Hugging Face model name (including the user name). Defaults to None, in which case the default model for the pipeline task will be used. field (default=None) input_key `Optional[str]` The blackboard key to use for writing and reading the prompt that this node will consume. Defaults to \"in\". field (default='in') output_key `Optional[str]` The blackboard key to use for writing and reading the text generated by this node. Defaults to \"out\". field (default='out') device `Optional[str]` The device that should be used with the model. Examples include \"cpu\", \"cuda\", and \"auto\". Defaults to \"auto\". field (default='auto') Source code in src/dendron/actions/pipeline_action.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @dataclass class PipelineActionConfig : \"\"\" Configuration for a PipelineAction. The options in this object control what Hugging Face task and model are used and how the node interacts with the blackboard. Args: task_name (`str`): The name of the Hugging Facetask to use. This should be a valid HF task name. For an overview of the tasks that HF supports, see https://huggingface.co/tasks. model (`Optional[str]`): Optional name of a model to use. This should be a valid name corresponding to a Hugging Face model name (including the user name). Defaults to None, in which case the default model for the pipeline task will be used. input_key (`Optional[str]`): The blackboard key to use for writing and reading the prompt that this node will consume. Defaults to \"in\". output_key (`Optional[str]`): The blackboard key to use for writing and reading the text generated by this node. Defaults to \"out\". device (`Optional[str]`): The device that should be used with the model. Examples include \"cpu\", \"cuda\", and \"auto\". Defaults to \"auto\". \"\"\" task_name : str model : Optional [ str ] = field ( default = None ) input_key : Optional [ str ] = field ( default = \"in\" ) output_key : Optional [ str ] = field ( default = \"out\" ) device : Optional [ str ] = field ( default = \"auto\" )","title":"Configuration"},{"location":"api/actions/pipeline_action/#imagelmaction","text":"Bases: ActionNode An action node that uses a Hugging Face transformers pipeline object to execute a behavior. This enables easy access to functionality such as sentiment classification that is wrapped in a Pipeline. This is also useful for quick prototyping with HF defaults. This node is based on the Hugging Face transformers library, and will download the model that you specify by name. This can take a long time and/or use a lot of storage, depending on the model you name. There are enough configuration options for this type of node that the options have all been placed in a dataclass config object. See the documentation for that object to learn about the many options available to you. Parameters: Name Type Description Default name `str` The given name of this node. required cfg `PipelineActionConfig` The configuration object for this model. required Source code in src/dendron/actions/pipeline_action.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 class PipelineAction ( ActionNode ): \"\"\" An action node that uses a Hugging Face transformers pipeline object to execute a behavior. This enables easy access to functionality such as sentiment classification that is wrapped in a Pipeline. This is also useful for quick prototyping with HF defaults. This node is based on the Hugging Face transformers library, and will download the model that you specify by name. This can take a long time and/or use a lot of storage, depending on the model you name. There are enough configuration options for this type of node that the options have all been placed in a dataclass config object. See the documentation for that object to learn about the many options available to you. Args: name (`str`): The given name of this node. cfg (`PipelineActionConfig`): The configuration object for this model. \"\"\" def __init__ ( self , name : str , cfg : PipelineActionConfig ) -> None : super () . __init__ ( name ) self . task_name = cfg . task_name self . input_key = cfg . input_key self . output_key = cfg . output_key self . device = cfg . device if cfg . model : self . pipeline = pipeline ( cfg . task_name , model = cfg . model , device_map = self . device ) else : self . pipeline = pipeline ( cfg . task_name , device_map = self . device ) def tick ( self ) -> NodeStatus : \"\"\" Execute a tick, consisting of the following steps: - Retrieve a prompt from the node's blackboard. - Apply the pipeline object to the input text. - Write the output to the blackboard. If any of the above fail, then the node returns a status of `FAILURE`. Otherwise the node returns a status of `SUCCESS`. \"\"\" try : input_text = self . blackboard [ self . input_key ] output = self . pipeline ( input_text ) self . blackboard [ self . output_key ] = output return NodeStatus . SUCCESS except : return NodeStatus . FAILURE","title":"ImageLMAction"},{"location":"api/actions/pipeline_action/#dendron.actions.pipeline_action.PipelineAction.tick","text":"Execute a tick, consisting of the following steps: Retrieve a prompt from the node's blackboard. Apply the pipeline object to the input text. Write the output to the blackboard. If any of the above fail, then the node returns a status of FAILURE . Otherwise the node returns a status of SUCCESS . Source code in src/dendron/actions/pipeline_action.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def tick ( self ) -> NodeStatus : \"\"\" Execute a tick, consisting of the following steps: - Retrieve a prompt from the node's blackboard. - Apply the pipeline object to the input text. - Write the output to the blackboard. If any of the above fail, then the node returns a status of `FAILURE`. Otherwise the node returns a status of `SUCCESS`. \"\"\" try : input_text = self . blackboard [ self . input_key ] output = self . pipeline ( input_text ) self . blackboard [ self . output_key ] = output return NodeStatus . SUCCESS except : return NodeStatus . FAILURE","title":"tick"},{"location":"api/actions/simple_action/","text":"SimpleAction Bases: ActionNode A simple action node is initialized with a callback that is called every time this node tick() s. The callback should be a function that that returns a NodeStatus . Parameters: Name Type Description Default name `str` The given name of this node. required callback `Callable` The callback to be executed upon every tick() . required Source code in src/dendron/actions/simple_action.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class SimpleAction ( ActionNode ): \"\"\" A simple action node is initialized with a callback that is called every time this node `tick()`s. The callback should be a function that that returns a `NodeStatus`. Args: name (`str`): The given name of this node. callback (`Callable`): The callback to be executed upon every `tick()`. \"\"\" def __init__ ( self , name : str , callback : Callable ) -> None : super () . __init__ ( name ) self . callback = callback def tick ( self ) -> NodeStatus : \"\"\" Call the callback function and return its status as the node status. \"\"\" return self . callback () tick () Call the callback function and return its status as the node status. Source code in src/dendron/actions/simple_action.py 22 23 24 25 26 27 def tick ( self ) -> NodeStatus : \"\"\" Call the callback function and return its status as the node status. \"\"\" return self . callback ()","title":"SimpleAction"},{"location":"api/actions/simple_action/#simpleaction","text":"Bases: ActionNode A simple action node is initialized with a callback that is called every time this node tick() s. The callback should be a function that that returns a NodeStatus . Parameters: Name Type Description Default name `str` The given name of this node. required callback `Callable` The callback to be executed upon every tick() . required Source code in src/dendron/actions/simple_action.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class SimpleAction ( ActionNode ): \"\"\" A simple action node is initialized with a callback that is called every time this node `tick()`s. The callback should be a function that that returns a `NodeStatus`. Args: name (`str`): The given name of this node. callback (`Callable`): The callback to be executed upon every `tick()`. \"\"\" def __init__ ( self , name : str , callback : Callable ) -> None : super () . __init__ ( name ) self . callback = callback def tick ( self ) -> NodeStatus : \"\"\" Call the callback function and return its status as the node status. \"\"\" return self . callback ()","title":"SimpleAction"},{"location":"api/actions/simple_action/#dendron.actions.simple_action.SimpleAction.tick","text":"Call the callback function and return its status as the node status. Source code in src/dendron/actions/simple_action.py 22 23 24 25 26 27 def tick ( self ) -> NodeStatus : \"\"\" Call the callback function and return its status as the node status. \"\"\" return self . callback ()","title":"tick"},{"location":"api/conditions/completion_condition/","text":"CompletionCondition CompletionConditionConfig Configuration for a CompletionConditionNode. The options in this object control what Hugging Face model is used and how the node interacts with the blackboard. Parameters: Name Type Description Default model_name `str` The name of the model to use. This should be a valid name corresponding to a Hugging Face model name (including the user name). required completions_key `Optional[str]` The blackboard key to read and write the completions to evaluate upon a tick() call. The value stored here should be a list of strings, each string representing one completion. Defaults to \"completions_in\". field (default='completions_in') success_fn_key `Optional[str]` The blackboard key to read and write the success predicate that determines the status that is ultimately returned upon a tick() call. The predicate should accept a completion string as input and return a NodeStatus . Defaults to \"success_fn\". field (default='success_fn') auto_load `Optional[bool]` An optional boolean indicating whether or not to automatically load model either from disk or the Hugging Face hub. If False , the user is responsible for ensuring that a model is loaded before the first tick() is triggered. Defaults to True . field (default=True) input_key `Optional[str]` The blackboard key to use for writing and reading the prefix that this node will consume. Defaults to \"in\". field (default='in') device `Optional[str]` The device that should be used with the model. Examples include \"cpu\", \"cuda\", and \"auto\". Defaults to \"auto\". field (default='auto') load_in_8bit `Optional[bool]` Optional boolean indicating whether or not to use eight-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. Defaults to False . field (default=False) load_in_4bit `Optional[bool]` Optional boolean indicating whether or not to use four-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. If you observe degraded performance, try eight-bit quanitization instead. Defaults to False . field (default=False) torch_dtype `torch.dtype` The dtype to use for torch tensors. Defaults to torch.float16 . You may need to change this depending on your quantization choices. field (default= float16 ) use_flash_attn_2 `Optional[bool]` Optional bool controlling whether or not to use Flash Attention 2. Defaults to False in case you haven't installed flash attention. Substantially speeds up inference. field (default=False) Source code in src/dendron/conditions/completion_condition.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 @dataclass class CompletionConditionConfig : \"\"\" Configuration for a CompletionConditionNode. The options in this object control what Hugging Face model is used and how the node interacts with the blackboard. Args: model_name (`str`): The name of the model to use. This should be a valid name corresponding to a Hugging Face model name (including the user name). completions_key (`Optional[str]`): The blackboard key to read and write the completions to evaluate upon a `tick()` call. The value stored here should be a list of strings, each string representing one completion. Defaults to \"completions_in\". success_fn_key (`Optional[str]`): The blackboard key to read and write the success predicate that determines the status that is ultimately returned upon a `tick()` call. The predicate should accept a completion string as input and return a `NodeStatus`. Defaults to \"success_fn\". auto_load (`Optional[bool]`): An optional boolean indicating whether or not to automatically load model either from disk or the Hugging Face hub. If `False`, the user is responsible for ensuring that a model is loaded before the first `tick()` is triggered. Defaults to `True`. input_key (`Optional[str]`): The blackboard key to use for writing and reading the prefix that this node will consume. Defaults to \"in\". device (`Optional[str]`): The device that should be used with the model. Examples include \"cpu\", \"cuda\", and \"auto\". Defaults to \"auto\". load_in_8bit (`Optional[bool]`): Optional boolean indicating whether or not to use eight-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. Defaults to `False`. load_in_4bit (`Optional[bool]`): Optional boolean indicating whether or not to use four-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. If you observe degraded performance, try eight-bit quanitization instead. Defaults to `False`. torch_dtype (`torch.dtype`): The dtype to use for torch tensors. Defaults to `torch.float16`. You may need to change this depending on your quantization choices. use_flash_attn_2 (`Optional[bool]`): Optional bool controlling whether or not to use Flash Attention 2. Defaults to `False` in case you haven't installed flash attention. Substantially speeds up inference. \"\"\" model_name : str completions_key : Optional [ str ] = field ( default = \"completions_in\" ) success_fn_key : Optional [ str ] = field ( default = \"success_fn\" ) auto_load : Optional [ bool ] = field ( default = True ) input_key : Optional [ str ] = field ( default = \"in\" ) device : Optional [ str ] = field ( default = \"auto\" ) load_in_8bit : Optional [ bool ] = field ( default = False ) load_in_4bit : Optional [ bool ] = field ( default = False ) torch_dtype : Optional [ torch . dtype ] = field ( default = torch . float16 ) use_flash_attn_2 : Optional [ bool ] = field ( default = False ) CompletionCondition Bases: ConditionNode A completion condition node uses a causal language model to evaluate the relative likelihood of several different completions of a prompt, returning SUCCESS or FAILURE using a user-provided function that selects a status based on the most likely completion. This node tends to run quickly and gives useful answers, but if you use this node you should be aware of the perils of \"surface form competition\", documented in the paper by Holtzman et al. (see https://arxiv.org/abs/2104.08315). This node is based on the Hugging Face transformers library, and will download the model that you specify by name. This can take a long time and/or use a lot of storage, depending on the model you name. There are enough configuration options for this type of node that the options have all been placed in a dataclass config object. See the documentation for that object to learn about the many options available to you. Parameters: Name Type Description Default name `str` The given name of this node. required cfg `CompletionConditionNodeConfig` The configuration object for this model. required Source code in src/dendron/conditions/completion_condition.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 class CompletionCondition ( ConditionNode ): \"\"\" A completion condition node uses a causal language model to evaluate the relative likelihood of several different completions of a prompt, returning `SUCCESS` or `FAILURE` using a user-provided function that selects a status based on the most likely completion. This node tends to run quickly and gives useful answers, but if you use this node you should be aware of the perils of \"surface form competition\", documented in the paper by Holtzman et al. (see https://arxiv.org/abs/2104.08315). This node is based on the Hugging Face transformers library, and will download the model that you specify by name. This can take a long time and/or use a lot of storage, depending on the model you name. There are enough configuration options for this type of node that the options have all been placed in a dataclass config object. See the documentation for that object to learn about the many options available to you. Args: name (`str`): The given name of this node. cfg (`CompletionConditionNodeConfig`): The configuration object for this model. \"\"\" def __init__ ( self , name : str , cfg : CompletionConditionConfig ) -> None : super () . __init__ ( name ) self . input_key = cfg . input_key self . device = cfg . device self . torch_dtype = cfg . torch_dtype self . completions_key = cfg . completions_key self . success_fn_key = cfg . success_fn_key match cfg . load_in_4bit , cfg . load_in_8bit : case True , True : self . quantization = Quantization . FourBit case True , False : self . quantization = Quantization . FourBit case False , True : self . quantization = Quantization . EightBit case False , False : self . quantization = Quantization . NoQuantization if cfg . use_flash_attn_2 : self . attn_implementation = \"flash_attention_2\" else : self . attn_implementation = \"sdpa\" if cfg . auto_load : match self . quantization : case Quantization . NoQuantization : self . model = AutoModelForCausalLM . from_pretrained ( cfg . model_name , torch_dtype = self . torch_dtype , low_cpu_mem_usage = True , attn_implementation = self . attn_implementation ) case Quantization . FourBit : self . model = AutoModelForCausalLM . from_pretrained ( cfg . model_name , load_in_4bit = True , torch_dtype = self . torch_dtype , low_cpu_mem_usage = True , attn_implementation = self . attn_implementation , bnb_4bit_compute_dtype = cfg . torch_dtype ) case Quantization . EightBit : self . model = AutoModelForCausalLM . from_pretrained ( cfg . model_name , load_in_8bit = True , torch_dtype = self . torch_dtype , low_cpu_mem_usage = True , attn_implementation = self . attn_implementation ) self . model . eval () self . tokenizer = AutoTokenizer . from_pretrained ( cfg . model_name ) if self . tokenizer . pad_token is None : self . tokenizer . pad_token = self . tokenizer . eos_token else : self . model = None self . tokenizer = None self . completions = [] def set_model ( self , new_model ) -> None : \"\"\" Set a new model to use for generating text. \"\"\" self . model = new_model self . model . eval () self . tokenizer = AutoTokenizer . from_pretrained ( new_model . name_or_path ) def tick ( self ) -> NodeStatus : \"\"\" Execute a tick, consisting of the following steps: - Retrieve the input prefix from the blackboard. - Retrieve the list of completion options from the blackboard. - Retrieve the success predicate from the blackboard. - Tokenize all of the possible completions, padding as needed. - Evaluate the model on the tokenized batch of completions. - Compute the \"log probabilities\" of each completion. - Apply the success predicate to the completion with the highest log probability. - Return the status computed by the success predicate. If any of the above fail, the exception text is printed and the node returns a status of `FAILURE`. Otherwise the node returns `SUCCESS`. \"\"\" try : input_prefix = self . blackboard [ self . input_key ] completions = self . blackboard [ self . completions_key ] success_fn = self . blackboard [ self . success_fn_key ] log_probs = np . zeros ( len ( completions )) texts = [ input_prefix + s for s in completions ] # Based on discussion/code at: https://discuss.huggingface.co/t/announcement-generation-get-probabilities-for-generated-output/30075/17 input_ids = self . tokenizer ( texts , padding = True , return_tensors = \"pt\" ) . input_ids outputs = self . model ( input_ids ) probs = torch . log_softmax ( outputs . logits , dim =- 1 ) . detach () probs = probs [:, : - 1 , :] input_ids = input_ids [:, 1 :] gen_probs = torch . gather ( probs , 2 , input_ids [:, :, None ]) . squeeze ( - 1 ) for i , ( input_sentence , input_probs ) in enumerate ( zip ( input_ids , gen_probs )): for token , p in zip ( input_sentence , input_probs ): if token not in self . tokenizer . all_special_ids : log_probs [ i ] += p . item () best_completion = completions [ log_probs . argmax ()] return success_fn ( best_completion ) except Exception as ex : print ( f \"Exception in node { self . name } :\" ) print ( traceback . format_exc ()) return NodeStatus . FAILURE set_model ( new_model ) Set a new model to use for generating text. Source code in src/dendron/conditions/completion_condition.py 183 184 185 186 187 188 189 def set_model ( self , new_model ) -> None : \"\"\" Set a new model to use for generating text. \"\"\" self . model = new_model self . model . eval () self . tokenizer = AutoTokenizer . from_pretrained ( new_model . name_or_path ) tick () Execute a tick, consisting of the following steps: Retrieve the input prefix from the blackboard. Retrieve the list of completion options from the blackboard. Retrieve the success predicate from the blackboard. Tokenize all of the possible completions, padding as needed. Evaluate the model on the tokenized batch of completions. Compute the \"log probabilities\" of each completion. Apply the success predicate to the completion with the highest log probability. Return the status computed by the success predicate. If any of the above fail, the exception text is printed and the node returns a status of FAILURE . Otherwise the node returns SUCCESS . Source code in src/dendron/conditions/completion_condition.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def tick ( self ) -> NodeStatus : \"\"\" Execute a tick, consisting of the following steps: - Retrieve the input prefix from the blackboard. - Retrieve the list of completion options from the blackboard. - Retrieve the success predicate from the blackboard. - Tokenize all of the possible completions, padding as needed. - Evaluate the model on the tokenized batch of completions. - Compute the \"log probabilities\" of each completion. - Apply the success predicate to the completion with the highest log probability. - Return the status computed by the success predicate. If any of the above fail, the exception text is printed and the node returns a status of `FAILURE`. Otherwise the node returns `SUCCESS`. \"\"\" try : input_prefix = self . blackboard [ self . input_key ] completions = self . blackboard [ self . completions_key ] success_fn = self . blackboard [ self . success_fn_key ] log_probs = np . zeros ( len ( completions )) texts = [ input_prefix + s for s in completions ] # Based on discussion/code at: https://discuss.huggingface.co/t/announcement-generation-get-probabilities-for-generated-output/30075/17 input_ids = self . tokenizer ( texts , padding = True , return_tensors = \"pt\" ) . input_ids outputs = self . model ( input_ids ) probs = torch . log_softmax ( outputs . logits , dim =- 1 ) . detach () probs = probs [:, : - 1 , :] input_ids = input_ids [:, 1 :] gen_probs = torch . gather ( probs , 2 , input_ids [:, :, None ]) . squeeze ( - 1 ) for i , ( input_sentence , input_probs ) in enumerate ( zip ( input_ids , gen_probs )): for token , p in zip ( input_sentence , input_probs ): if token not in self . tokenizer . all_special_ids : log_probs [ i ] += p . item () best_completion = completions [ log_probs . argmax ()] return success_fn ( best_completion ) except Exception as ex : print ( f \"Exception in node { self . name } :\" ) print ( traceback . format_exc ()) return NodeStatus . FAILURE","title":"CompletionCondition"},{"location":"api/conditions/completion_condition/#completioncondition","text":"","title":"CompletionCondition"},{"location":"api/conditions/completion_condition/#completionconditionconfig","text":"Configuration for a CompletionConditionNode. The options in this object control what Hugging Face model is used and how the node interacts with the blackboard. Parameters: Name Type Description Default model_name `str` The name of the model to use. This should be a valid name corresponding to a Hugging Face model name (including the user name). required completions_key `Optional[str]` The blackboard key to read and write the completions to evaluate upon a tick() call. The value stored here should be a list of strings, each string representing one completion. Defaults to \"completions_in\". field (default='completions_in') success_fn_key `Optional[str]` The blackboard key to read and write the success predicate that determines the status that is ultimately returned upon a tick() call. The predicate should accept a completion string as input and return a NodeStatus . Defaults to \"success_fn\". field (default='success_fn') auto_load `Optional[bool]` An optional boolean indicating whether or not to automatically load model either from disk or the Hugging Face hub. If False , the user is responsible for ensuring that a model is loaded before the first tick() is triggered. Defaults to True . field (default=True) input_key `Optional[str]` The blackboard key to use for writing and reading the prefix that this node will consume. Defaults to \"in\". field (default='in') device `Optional[str]` The device that should be used with the model. Examples include \"cpu\", \"cuda\", and \"auto\". Defaults to \"auto\". field (default='auto') load_in_8bit `Optional[bool]` Optional boolean indicating whether or not to use eight-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. Defaults to False . field (default=False) load_in_4bit `Optional[bool]` Optional boolean indicating whether or not to use four-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. If you observe degraded performance, try eight-bit quanitization instead. Defaults to False . field (default=False) torch_dtype `torch.dtype` The dtype to use for torch tensors. Defaults to torch.float16 . You may need to change this depending on your quantization choices. field (default= float16 ) use_flash_attn_2 `Optional[bool]` Optional bool controlling whether or not to use Flash Attention 2. Defaults to False in case you haven't installed flash attention. Substantially speeds up inference. field (default=False) Source code in src/dendron/conditions/completion_condition.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 @dataclass class CompletionConditionConfig : \"\"\" Configuration for a CompletionConditionNode. The options in this object control what Hugging Face model is used and how the node interacts with the blackboard. Args: model_name (`str`): The name of the model to use. This should be a valid name corresponding to a Hugging Face model name (including the user name). completions_key (`Optional[str]`): The blackboard key to read and write the completions to evaluate upon a `tick()` call. The value stored here should be a list of strings, each string representing one completion. Defaults to \"completions_in\". success_fn_key (`Optional[str]`): The blackboard key to read and write the success predicate that determines the status that is ultimately returned upon a `tick()` call. The predicate should accept a completion string as input and return a `NodeStatus`. Defaults to \"success_fn\". auto_load (`Optional[bool]`): An optional boolean indicating whether or not to automatically load model either from disk or the Hugging Face hub. If `False`, the user is responsible for ensuring that a model is loaded before the first `tick()` is triggered. Defaults to `True`. input_key (`Optional[str]`): The blackboard key to use for writing and reading the prefix that this node will consume. Defaults to \"in\". device (`Optional[str]`): The device that should be used with the model. Examples include \"cpu\", \"cuda\", and \"auto\". Defaults to \"auto\". load_in_8bit (`Optional[bool]`): Optional boolean indicating whether or not to use eight-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. Defaults to `False`. load_in_4bit (`Optional[bool]`): Optional boolean indicating whether or not to use four-bit quantization from bitsandbytes. When available, will typically decrease memory usage and increase inference speed. If you observe degraded performance, try eight-bit quanitization instead. Defaults to `False`. torch_dtype (`torch.dtype`): The dtype to use for torch tensors. Defaults to `torch.float16`. You may need to change this depending on your quantization choices. use_flash_attn_2 (`Optional[bool]`): Optional bool controlling whether or not to use Flash Attention 2. Defaults to `False` in case you haven't installed flash attention. Substantially speeds up inference. \"\"\" model_name : str completions_key : Optional [ str ] = field ( default = \"completions_in\" ) success_fn_key : Optional [ str ] = field ( default = \"success_fn\" ) auto_load : Optional [ bool ] = field ( default = True ) input_key : Optional [ str ] = field ( default = \"in\" ) device : Optional [ str ] = field ( default = \"auto\" ) load_in_8bit : Optional [ bool ] = field ( default = False ) load_in_4bit : Optional [ bool ] = field ( default = False ) torch_dtype : Optional [ torch . dtype ] = field ( default = torch . float16 ) use_flash_attn_2 : Optional [ bool ] = field ( default = False )","title":"CompletionConditionConfig"},{"location":"api/conditions/completion_condition/#completioncondition_1","text":"Bases: ConditionNode A completion condition node uses a causal language model to evaluate the relative likelihood of several different completions of a prompt, returning SUCCESS or FAILURE using a user-provided function that selects a status based on the most likely completion. This node tends to run quickly and gives useful answers, but if you use this node you should be aware of the perils of \"surface form competition\", documented in the paper by Holtzman et al. (see https://arxiv.org/abs/2104.08315). This node is based on the Hugging Face transformers library, and will download the model that you specify by name. This can take a long time and/or use a lot of storage, depending on the model you name. There are enough configuration options for this type of node that the options have all been placed in a dataclass config object. See the documentation for that object to learn about the many options available to you. Parameters: Name Type Description Default name `str` The given name of this node. required cfg `CompletionConditionNodeConfig` The configuration object for this model. required Source code in src/dendron/conditions/completion_condition.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 class CompletionCondition ( ConditionNode ): \"\"\" A completion condition node uses a causal language model to evaluate the relative likelihood of several different completions of a prompt, returning `SUCCESS` or `FAILURE` using a user-provided function that selects a status based on the most likely completion. This node tends to run quickly and gives useful answers, but if you use this node you should be aware of the perils of \"surface form competition\", documented in the paper by Holtzman et al. (see https://arxiv.org/abs/2104.08315). This node is based on the Hugging Face transformers library, and will download the model that you specify by name. This can take a long time and/or use a lot of storage, depending on the model you name. There are enough configuration options for this type of node that the options have all been placed in a dataclass config object. See the documentation for that object to learn about the many options available to you. Args: name (`str`): The given name of this node. cfg (`CompletionConditionNodeConfig`): The configuration object for this model. \"\"\" def __init__ ( self , name : str , cfg : CompletionConditionConfig ) -> None : super () . __init__ ( name ) self . input_key = cfg . input_key self . device = cfg . device self . torch_dtype = cfg . torch_dtype self . completions_key = cfg . completions_key self . success_fn_key = cfg . success_fn_key match cfg . load_in_4bit , cfg . load_in_8bit : case True , True : self . quantization = Quantization . FourBit case True , False : self . quantization = Quantization . FourBit case False , True : self . quantization = Quantization . EightBit case False , False : self . quantization = Quantization . NoQuantization if cfg . use_flash_attn_2 : self . attn_implementation = \"flash_attention_2\" else : self . attn_implementation = \"sdpa\" if cfg . auto_load : match self . quantization : case Quantization . NoQuantization : self . model = AutoModelForCausalLM . from_pretrained ( cfg . model_name , torch_dtype = self . torch_dtype , low_cpu_mem_usage = True , attn_implementation = self . attn_implementation ) case Quantization . FourBit : self . model = AutoModelForCausalLM . from_pretrained ( cfg . model_name , load_in_4bit = True , torch_dtype = self . torch_dtype , low_cpu_mem_usage = True , attn_implementation = self . attn_implementation , bnb_4bit_compute_dtype = cfg . torch_dtype ) case Quantization . EightBit : self . model = AutoModelForCausalLM . from_pretrained ( cfg . model_name , load_in_8bit = True , torch_dtype = self . torch_dtype , low_cpu_mem_usage = True , attn_implementation = self . attn_implementation ) self . model . eval () self . tokenizer = AutoTokenizer . from_pretrained ( cfg . model_name ) if self . tokenizer . pad_token is None : self . tokenizer . pad_token = self . tokenizer . eos_token else : self . model = None self . tokenizer = None self . completions = [] def set_model ( self , new_model ) -> None : \"\"\" Set a new model to use for generating text. \"\"\" self . model = new_model self . model . eval () self . tokenizer = AutoTokenizer . from_pretrained ( new_model . name_or_path ) def tick ( self ) -> NodeStatus : \"\"\" Execute a tick, consisting of the following steps: - Retrieve the input prefix from the blackboard. - Retrieve the list of completion options from the blackboard. - Retrieve the success predicate from the blackboard. - Tokenize all of the possible completions, padding as needed. - Evaluate the model on the tokenized batch of completions. - Compute the \"log probabilities\" of each completion. - Apply the success predicate to the completion with the highest log probability. - Return the status computed by the success predicate. If any of the above fail, the exception text is printed and the node returns a status of `FAILURE`. Otherwise the node returns `SUCCESS`. \"\"\" try : input_prefix = self . blackboard [ self . input_key ] completions = self . blackboard [ self . completions_key ] success_fn = self . blackboard [ self . success_fn_key ] log_probs = np . zeros ( len ( completions )) texts = [ input_prefix + s for s in completions ] # Based on discussion/code at: https://discuss.huggingface.co/t/announcement-generation-get-probabilities-for-generated-output/30075/17 input_ids = self . tokenizer ( texts , padding = True , return_tensors = \"pt\" ) . input_ids outputs = self . model ( input_ids ) probs = torch . log_softmax ( outputs . logits , dim =- 1 ) . detach () probs = probs [:, : - 1 , :] input_ids = input_ids [:, 1 :] gen_probs = torch . gather ( probs , 2 , input_ids [:, :, None ]) . squeeze ( - 1 ) for i , ( input_sentence , input_probs ) in enumerate ( zip ( input_ids , gen_probs )): for token , p in zip ( input_sentence , input_probs ): if token not in self . tokenizer . all_special_ids : log_probs [ i ] += p . item () best_completion = completions [ log_probs . argmax ()] return success_fn ( best_completion ) except Exception as ex : print ( f \"Exception in node { self . name } :\" ) print ( traceback . format_exc ()) return NodeStatus . FAILURE","title":"CompletionCondition"},{"location":"api/conditions/completion_condition/#dendron.conditions.completion_condition.CompletionCondition.set_model","text":"Set a new model to use for generating text. Source code in src/dendron/conditions/completion_condition.py 183 184 185 186 187 188 189 def set_model ( self , new_model ) -> None : \"\"\" Set a new model to use for generating text. \"\"\" self . model = new_model self . model . eval () self . tokenizer = AutoTokenizer . from_pretrained ( new_model . name_or_path )","title":"set_model"},{"location":"api/conditions/completion_condition/#dendron.conditions.completion_condition.CompletionCondition.tick","text":"Execute a tick, consisting of the following steps: Retrieve the input prefix from the blackboard. Retrieve the list of completion options from the blackboard. Retrieve the success predicate from the blackboard. Tokenize all of the possible completions, padding as needed. Evaluate the model on the tokenized batch of completions. Compute the \"log probabilities\" of each completion. Apply the success predicate to the completion with the highest log probability. Return the status computed by the success predicate. If any of the above fail, the exception text is printed and the node returns a status of FAILURE . Otherwise the node returns SUCCESS . Source code in src/dendron/conditions/completion_condition.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def tick ( self ) -> NodeStatus : \"\"\" Execute a tick, consisting of the following steps: - Retrieve the input prefix from the blackboard. - Retrieve the list of completion options from the blackboard. - Retrieve the success predicate from the blackboard. - Tokenize all of the possible completions, padding as needed. - Evaluate the model on the tokenized batch of completions. - Compute the \"log probabilities\" of each completion. - Apply the success predicate to the completion with the highest log probability. - Return the status computed by the success predicate. If any of the above fail, the exception text is printed and the node returns a status of `FAILURE`. Otherwise the node returns `SUCCESS`. \"\"\" try : input_prefix = self . blackboard [ self . input_key ] completions = self . blackboard [ self . completions_key ] success_fn = self . blackboard [ self . success_fn_key ] log_probs = np . zeros ( len ( completions )) texts = [ input_prefix + s for s in completions ] # Based on discussion/code at: https://discuss.huggingface.co/t/announcement-generation-get-probabilities-for-generated-output/30075/17 input_ids = self . tokenizer ( texts , padding = True , return_tensors = \"pt\" ) . input_ids outputs = self . model ( input_ids ) probs = torch . log_softmax ( outputs . logits , dim =- 1 ) . detach () probs = probs [:, : - 1 , :] input_ids = input_ids [:, 1 :] gen_probs = torch . gather ( probs , 2 , input_ids [:, :, None ]) . squeeze ( - 1 ) for i , ( input_sentence , input_probs ) in enumerate ( zip ( input_ids , gen_probs )): for token , p in zip ( input_sentence , input_probs ): if token not in self . tokenizer . all_special_ids : log_probs [ i ] += p . item () best_completion = completions [ log_probs . argmax ()] return success_fn ( best_completion ) except Exception as ex : print ( f \"Exception in node { self . name } :\" ) print ( traceback . format_exc ()) return NodeStatus . FAILURE","title":"tick"},{"location":"api/conditions/simple_condition/","text":"SimpleCondition Bases: ConditionNode A simple condition node is initialized with a callback that is called every time this node tick() s. The callback should be a function that returns a NodeStatus . Additionally, as a condition node the callback should never return a status of RUNNING . It is up to the caller to ensure that this invariant holds. Parameters: Name Type Description Default name `str` The given name of this node. required callback `Callable` The callback to be executed upon every tick() . required Source code in src/dendron/conditions/simple_condition.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class SimpleCondition ( ConditionNode ): \"\"\" A simple condition node is initialized with a callback that is called every time this node `tick()`s. The callback should be a function that returns a `NodeStatus`. Additionally, as a condition node the callback should never return a status of `RUNNING`. It is up to the caller to ensure that this invariant holds. Args: name (`str`): The given name of this node. callback (`Callable`): The callback to be executed upon every `tick()`. \"\"\" def __init__ ( self , name : str , callback : Callable ) -> None : super () . __init__ ( name ) self . callback = callback def tick ( self ) -> NodeStatus : \"\"\" Call the callback function and return its status as the node status. \"\"\" return self . callback () tick () Call the callback function and return its status as the node status. Source code in src/dendron/conditions/simple_condition.py 25 26 27 28 29 30 def tick ( self ) -> NodeStatus : \"\"\" Call the callback function and return its status as the node status. \"\"\" return self . callback ()","title":"SimpleCondition"},{"location":"api/conditions/simple_condition/#simplecondition","text":"Bases: ConditionNode A simple condition node is initialized with a callback that is called every time this node tick() s. The callback should be a function that returns a NodeStatus . Additionally, as a condition node the callback should never return a status of RUNNING . It is up to the caller to ensure that this invariant holds. Parameters: Name Type Description Default name `str` The given name of this node. required callback `Callable` The callback to be executed upon every tick() . required Source code in src/dendron/conditions/simple_condition.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class SimpleCondition ( ConditionNode ): \"\"\" A simple condition node is initialized with a callback that is called every time this node `tick()`s. The callback should be a function that returns a `NodeStatus`. Additionally, as a condition node the callback should never return a status of `RUNNING`. It is up to the caller to ensure that this invariant holds. Args: name (`str`): The given name of this node. callback (`Callable`): The callback to be executed upon every `tick()`. \"\"\" def __init__ ( self , name : str , callback : Callable ) -> None : super () . __init__ ( name ) self . callback = callback def tick ( self ) -> NodeStatus : \"\"\" Call the callback function and return its status as the node status. \"\"\" return self . callback ()","title":"SimpleCondition"},{"location":"api/conditions/simple_condition/#dendron.conditions.simple_condition.SimpleCondition.tick","text":"Call the callback function and return its status as the node status. Source code in src/dendron/conditions/simple_condition.py 25 26 27 28 29 30 def tick ( self ) -> NodeStatus : \"\"\" Call the callback function and return its status as the node status. \"\"\" return self . callback ()","title":"tick"},{"location":"api/controls/fallback/","text":"Fallback Bases: ControlNode A Fallback node is a control node that ticks its children in sequence, until a child returns SUCCESS , at which point it returns success. If all children return FAILURE , then the Fallback node returns FAILURE . The intuition is that the Fallback node is trying different options until it finds one that works. Parameters: Name Type Description Default name `str` The given name of this node. required children `List[TreeNode]` A list of TreeNode s to initialize the children of this node. Will be ticked in the order they are given. [] Source code in src/dendron/controls/fallback.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class Fallback ( ControlNode ): \"\"\" A Fallback node is a control node that ticks its children in sequence, until a child returns `SUCCESS`, at which point it returns success. If all children return `FAILURE`, then the Fallback node returns `FAILURE`. The intuition is that the Fallback node is trying different options until it finds one that works. Args: name (`str`): The given name of this node. children (`List[TreeNode]`): A list of `TreeNode`s to initialize the children of this node. Will be ticked in the order they are given. \"\"\" def __init__ ( self , name , children : List [ TreeNode ] = []) -> None : super () . __init__ ( name , children ) self . current_child_idx = 0 def reset ( self ) -> None : \"\"\" Set the current child index to 0 and instruct all children to reset. \"\"\" self . current_child_idx = 0 for child in self . children : child . reset () def halt_node ( self ) -> None : \"\"\" Set the current child index to 0 and instruct all children to halt via the parent class `halt()`. \"\"\" self . current_child_idx = 0 ControlNode . halt ( self ) def tick ( self ) -> NodeStatus : \"\"\" Successively `tick()` each child node until one returns a status of `SUCCESS`. If all children fail, return `FAILURE`. Returns: `NodeStatus`: `SUCCESS` if at least one child succeeds, `FAILURE` otherwise. May return `RUNNING` or `SKIPPED` depending on children's behavior. \"\"\" n_children = self . children_count () self . set_status ( NodeStatus . RUNNING ) while ( self . current_child_idx < n_children ): current_child = self . children [ self . current_child_idx ] child_status = current_child . execute_tick () match child_status : case NodeStatus . RUNNING : return NodeStatus . RUNNING case NodeStatus . FAILURE : self . current_child_idx += 1 case NodeStatus . SUCCESS : self . reset () self . current_child_idx = 0 return child_status case NodeStatus . SKIPPED : self . current_child_idx += 1 case NodeStatus . IDLE : raise RuntimeError ( \"Child can't return IDLE\" ) if self . current_child_idx == n_children : self . reset () return NodeStatus . FAILURE def pretty_repr ( self , depth = 0 ) -> str : \"\"\" Return a string representation of this node at the given depth. Args: depth (`int`): The depth of this node in a surrounding tree. Returns: `str`: The indented string representation. \"\"\" tabs = ' \\t ' * depth repr = f \" { tabs } Fallback { self . name } \" for child in self . children : child_repr = child . pretty_repr ( depth + 1 ) repr += f \" \\n { child_repr } \" repr += \" \\n \" return repr halt_node () Set the current child index to 0 and instruct all children to halt via the parent class halt() . Source code in src/dendron/controls/fallback.py 38 39 40 41 42 43 44 def halt_node ( self ) -> None : \"\"\" Set the current child index to 0 and instruct all children to halt via the parent class `halt()`. \"\"\" self . current_child_idx = 0 ControlNode . halt ( self ) pretty_repr ( depth = 0 ) Return a string representation of this node at the given depth. Parameters: Name Type Description Default depth `int` The depth of this node in a surrounding tree. 0 Returns: Type Description str str : The indented string representation. Source code in src/dendron/controls/fallback.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def pretty_repr ( self , depth = 0 ) -> str : \"\"\" Return a string representation of this node at the given depth. Args: depth (`int`): The depth of this node in a surrounding tree. Returns: `str`: The indented string representation. \"\"\" tabs = ' \\t ' * depth repr = f \" { tabs } Fallback { self . name } \" for child in self . children : child_repr = child . pretty_repr ( depth + 1 ) repr += f \" \\n { child_repr } \" repr += \" \\n \" return repr reset () Set the current child index to 0 and instruct all children to reset. Source code in src/dendron/controls/fallback.py 29 30 31 32 33 34 35 36 def reset ( self ) -> None : \"\"\" Set the current child index to 0 and instruct all children to reset. \"\"\" self . current_child_idx = 0 for child in self . children : child . reset () tick () Successively tick() each child node until one returns a status of SUCCESS . If all children fail, return FAILURE . Returns: Type Description NodeStatus NodeStatus : SUCCESS if at least one child succeeds, NodeStatus FAILURE otherwise. May return RUNNING or SKIPPED NodeStatus depending on children's behavior. Source code in src/dendron/controls/fallback.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def tick ( self ) -> NodeStatus : \"\"\" Successively `tick()` each child node until one returns a status of `SUCCESS`. If all children fail, return `FAILURE`. Returns: `NodeStatus`: `SUCCESS` if at least one child succeeds, `FAILURE` otherwise. May return `RUNNING` or `SKIPPED` depending on children's behavior. \"\"\" n_children = self . children_count () self . set_status ( NodeStatus . RUNNING ) while ( self . current_child_idx < n_children ): current_child = self . children [ self . current_child_idx ] child_status = current_child . execute_tick () match child_status : case NodeStatus . RUNNING : return NodeStatus . RUNNING case NodeStatus . FAILURE : self . current_child_idx += 1 case NodeStatus . SUCCESS : self . reset () self . current_child_idx = 0 return child_status case NodeStatus . SKIPPED : self . current_child_idx += 1 case NodeStatus . IDLE : raise RuntimeError ( \"Child can't return IDLE\" ) if self . current_child_idx == n_children : self . reset () return NodeStatus . FAILURE","title":"Fallback"},{"location":"api/controls/fallback/#fallback","text":"Bases: ControlNode A Fallback node is a control node that ticks its children in sequence, until a child returns SUCCESS , at which point it returns success. If all children return FAILURE , then the Fallback node returns FAILURE . The intuition is that the Fallback node is trying different options until it finds one that works. Parameters: Name Type Description Default name `str` The given name of this node. required children `List[TreeNode]` A list of TreeNode s to initialize the children of this node. Will be ticked in the order they are given. [] Source code in src/dendron/controls/fallback.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class Fallback ( ControlNode ): \"\"\" A Fallback node is a control node that ticks its children in sequence, until a child returns `SUCCESS`, at which point it returns success. If all children return `FAILURE`, then the Fallback node returns `FAILURE`. The intuition is that the Fallback node is trying different options until it finds one that works. Args: name (`str`): The given name of this node. children (`List[TreeNode]`): A list of `TreeNode`s to initialize the children of this node. Will be ticked in the order they are given. \"\"\" def __init__ ( self , name , children : List [ TreeNode ] = []) -> None : super () . __init__ ( name , children ) self . current_child_idx = 0 def reset ( self ) -> None : \"\"\" Set the current child index to 0 and instruct all children to reset. \"\"\" self . current_child_idx = 0 for child in self . children : child . reset () def halt_node ( self ) -> None : \"\"\" Set the current child index to 0 and instruct all children to halt via the parent class `halt()`. \"\"\" self . current_child_idx = 0 ControlNode . halt ( self ) def tick ( self ) -> NodeStatus : \"\"\" Successively `tick()` each child node until one returns a status of `SUCCESS`. If all children fail, return `FAILURE`. Returns: `NodeStatus`: `SUCCESS` if at least one child succeeds, `FAILURE` otherwise. May return `RUNNING` or `SKIPPED` depending on children's behavior. \"\"\" n_children = self . children_count () self . set_status ( NodeStatus . RUNNING ) while ( self . current_child_idx < n_children ): current_child = self . children [ self . current_child_idx ] child_status = current_child . execute_tick () match child_status : case NodeStatus . RUNNING : return NodeStatus . RUNNING case NodeStatus . FAILURE : self . current_child_idx += 1 case NodeStatus . SUCCESS : self . reset () self . current_child_idx = 0 return child_status case NodeStatus . SKIPPED : self . current_child_idx += 1 case NodeStatus . IDLE : raise RuntimeError ( \"Child can't return IDLE\" ) if self . current_child_idx == n_children : self . reset () return NodeStatus . FAILURE def pretty_repr ( self , depth = 0 ) -> str : \"\"\" Return a string representation of this node at the given depth. Args: depth (`int`): The depth of this node in a surrounding tree. Returns: `str`: The indented string representation. \"\"\" tabs = ' \\t ' * depth repr = f \" { tabs } Fallback { self . name } \" for child in self . children : child_repr = child . pretty_repr ( depth + 1 ) repr += f \" \\n { child_repr } \" repr += \" \\n \" return repr","title":"Fallback"},{"location":"api/controls/fallback/#dendron.controls.fallback.Fallback.halt_node","text":"Set the current child index to 0 and instruct all children to halt via the parent class halt() . Source code in src/dendron/controls/fallback.py 38 39 40 41 42 43 44 def halt_node ( self ) -> None : \"\"\" Set the current child index to 0 and instruct all children to halt via the parent class `halt()`. \"\"\" self . current_child_idx = 0 ControlNode . halt ( self )","title":"halt_node"},{"location":"api/controls/fallback/#dendron.controls.fallback.Fallback.pretty_repr","text":"Return a string representation of this node at the given depth. Parameters: Name Type Description Default depth `int` The depth of this node in a surrounding tree. 0 Returns: Type Description str str : The indented string representation. Source code in src/dendron/controls/fallback.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def pretty_repr ( self , depth = 0 ) -> str : \"\"\" Return a string representation of this node at the given depth. Args: depth (`int`): The depth of this node in a surrounding tree. Returns: `str`: The indented string representation. \"\"\" tabs = ' \\t ' * depth repr = f \" { tabs } Fallback { self . name } \" for child in self . children : child_repr = child . pretty_repr ( depth + 1 ) repr += f \" \\n { child_repr } \" repr += \" \\n \" return repr","title":"pretty_repr"},{"location":"api/controls/fallback/#dendron.controls.fallback.Fallback.reset","text":"Set the current child index to 0 and instruct all children to reset. Source code in src/dendron/controls/fallback.py 29 30 31 32 33 34 35 36 def reset ( self ) -> None : \"\"\" Set the current child index to 0 and instruct all children to reset. \"\"\" self . current_child_idx = 0 for child in self . children : child . reset ()","title":"reset"},{"location":"api/controls/fallback/#dendron.controls.fallback.Fallback.tick","text":"Successively tick() each child node until one returns a status of SUCCESS . If all children fail, return FAILURE . Returns: Type Description NodeStatus NodeStatus : SUCCESS if at least one child succeeds, NodeStatus FAILURE otherwise. May return RUNNING or SKIPPED NodeStatus depending on children's behavior. Source code in src/dendron/controls/fallback.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def tick ( self ) -> NodeStatus : \"\"\" Successively `tick()` each child node until one returns a status of `SUCCESS`. If all children fail, return `FAILURE`. Returns: `NodeStatus`: `SUCCESS` if at least one child succeeds, `FAILURE` otherwise. May return `RUNNING` or `SKIPPED` depending on children's behavior. \"\"\" n_children = self . children_count () self . set_status ( NodeStatus . RUNNING ) while ( self . current_child_idx < n_children ): current_child = self . children [ self . current_child_idx ] child_status = current_child . execute_tick () match child_status : case NodeStatus . RUNNING : return NodeStatus . RUNNING case NodeStatus . FAILURE : self . current_child_idx += 1 case NodeStatus . SUCCESS : self . reset () self . current_child_idx = 0 return child_status case NodeStatus . SKIPPED : self . current_child_idx += 1 case NodeStatus . IDLE : raise RuntimeError ( \"Child can't return IDLE\" ) if self . current_child_idx == n_children : self . reset () return NodeStatus . FAILURE","title":"tick"},{"location":"api/controls/sequence/","text":"Sequence Bases: ControlNode A Sequence node is a control node that ticks its children in sequence, until a child returns FAILURE , at which point it returns FAILURE . If all children succeed, then the Sequence node returns SUCCESS . Parameters: Name Type Description Default name `str` The given name of this node. required children `List[TreeNode]` A list of TreeNode s to initialize the children of this node. Will be ticked in the order they are given. [] Source code in src/dendron/controls/sequence.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class Sequence ( ControlNode ): \"\"\" A Sequence node is a control node that ticks its children in sequence, until a child returns `FAILURE`, at which point it returns `FAILURE`. If all children succeed, then the Sequence node returns `SUCCESS`. Args: name (`str`): The given name of this node. children (`List[TreeNode]`): A list of `TreeNode`s to initialize the children of this node. Will be ticked in the order they are given. \"\"\" def __init__ ( self , name , children : List [ TreeNode ] = []) -> None : super () . __init__ ( name , children ) self . current_child_idx = 0 def reset ( self ) -> None : \"\"\" Set the current child index to 0 and instruct all children to reset. \"\"\" self . current_child_idx = 0 for child in self . children : child . reset () def halt_node ( self ) -> None : \"\"\" Set the current child index to 0 and instruct all children to halt via the parent class `halt()`. \"\"\" self . current_child_idx = 0 ControlNode . halt ( self ) def tick ( self ) -> NodeStatus : \"\"\" Successively `tick()` each child node until one returns a status of `FAILURE`. If all children succeed, return `SUCCESS`. Returns: `NodeStatus`: `FAILURE` if at least one child fails, `SUCCESS` otherwise. May return `RUNNING` or `SKIPPED` depending on children's behavior. \"\"\" n_children = self . children_count () self . set_status ( NodeStatus . RUNNING ) while ( self . current_child_idx < n_children ): current_child = self . children [ self . current_child_idx ] child_status = current_child . execute_tick () match child_status : case NodeStatus . RUNNING : return NodeStatus . RUNNING case NodeStatus . FAILURE : self . reset () self . current_child_idx = 0 return child_status case NodeStatus . SUCCESS : self . current_child_idx += 1 case NodeStatus . SKIPPED : self . current_child_idx += 1 case NodeStatus . IDLE : raise RuntimeError ( \"Child can't return IDLE\" ) if self . current_child_idx == n_children : self . reset () return NodeStatus . SUCCESS def pretty_repr ( self , depth = 0 ) -> str : \"\"\" Return a string representation of this node at the given depth. Args: depth (`int`): The depth of this node in a surrounding tree. Returns: `str`: The indented string representation. \"\"\" tabs = ' \\t ' * depth repr = f \" { tabs } Sequence { self . name } \" for child in self . children : child_repr = child . pretty_repr ( depth + 1 ) repr += f \" \\n { child_repr } \" repr += \" \\n \" return repr halt_node () Set the current child index to 0 and instruct all children to halt via the parent class halt() . Source code in src/dendron/controls/sequence.py 36 37 38 39 40 41 42 def halt_node ( self ) -> None : \"\"\" Set the current child index to 0 and instruct all children to halt via the parent class `halt()`. \"\"\" self . current_child_idx = 0 ControlNode . halt ( self ) reset () Set the current child index to 0 and instruct all children to reset. Source code in src/dendron/controls/sequence.py 27 28 29 30 31 32 33 34 def reset ( self ) -> None : \"\"\" Set the current child index to 0 and instruct all children to reset. \"\"\" self . current_child_idx = 0 for child in self . children : child . reset () tick () Successively tick() each child node until one returns a status of FAILURE . If all children succeed, return SUCCESS . Returns: Type Description NodeStatus NodeStatus : FAILURE if at least one child fails, NodeStatus SUCCESS otherwise. May return RUNNING or SKIPPED NodeStatus depending on children's behavior. Source code in src/dendron/controls/sequence.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def tick ( self ) -> NodeStatus : \"\"\" Successively `tick()` each child node until one returns a status of `FAILURE`. If all children succeed, return `SUCCESS`. Returns: `NodeStatus`: `FAILURE` if at least one child fails, `SUCCESS` otherwise. May return `RUNNING` or `SKIPPED` depending on children's behavior. \"\"\" n_children = self . children_count () self . set_status ( NodeStatus . RUNNING ) while ( self . current_child_idx < n_children ): current_child = self . children [ self . current_child_idx ] child_status = current_child . execute_tick () match child_status : case NodeStatus . RUNNING : return NodeStatus . RUNNING case NodeStatus . FAILURE : self . reset () self . current_child_idx = 0 return child_status case NodeStatus . SUCCESS : self . current_child_idx += 1 case NodeStatus . SKIPPED : self . current_child_idx += 1 case NodeStatus . IDLE : raise RuntimeError ( \"Child can't return IDLE\" ) if self . current_child_idx == n_children : self . reset () return NodeStatus . SUCCESS","title":"Sequence"},{"location":"api/controls/sequence/#sequence","text":"Bases: ControlNode A Sequence node is a control node that ticks its children in sequence, until a child returns FAILURE , at which point it returns FAILURE . If all children succeed, then the Sequence node returns SUCCESS . Parameters: Name Type Description Default name `str` The given name of this node. required children `List[TreeNode]` A list of TreeNode s to initialize the children of this node. Will be ticked in the order they are given. [] Source code in src/dendron/controls/sequence.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class Sequence ( ControlNode ): \"\"\" A Sequence node is a control node that ticks its children in sequence, until a child returns `FAILURE`, at which point it returns `FAILURE`. If all children succeed, then the Sequence node returns `SUCCESS`. Args: name (`str`): The given name of this node. children (`List[TreeNode]`): A list of `TreeNode`s to initialize the children of this node. Will be ticked in the order they are given. \"\"\" def __init__ ( self , name , children : List [ TreeNode ] = []) -> None : super () . __init__ ( name , children ) self . current_child_idx = 0 def reset ( self ) -> None : \"\"\" Set the current child index to 0 and instruct all children to reset. \"\"\" self . current_child_idx = 0 for child in self . children : child . reset () def halt_node ( self ) -> None : \"\"\" Set the current child index to 0 and instruct all children to halt via the parent class `halt()`. \"\"\" self . current_child_idx = 0 ControlNode . halt ( self ) def tick ( self ) -> NodeStatus : \"\"\" Successively `tick()` each child node until one returns a status of `FAILURE`. If all children succeed, return `SUCCESS`. Returns: `NodeStatus`: `FAILURE` if at least one child fails, `SUCCESS` otherwise. May return `RUNNING` or `SKIPPED` depending on children's behavior. \"\"\" n_children = self . children_count () self . set_status ( NodeStatus . RUNNING ) while ( self . current_child_idx < n_children ): current_child = self . children [ self . current_child_idx ] child_status = current_child . execute_tick () match child_status : case NodeStatus . RUNNING : return NodeStatus . RUNNING case NodeStatus . FAILURE : self . reset () self . current_child_idx = 0 return child_status case NodeStatus . SUCCESS : self . current_child_idx += 1 case NodeStatus . SKIPPED : self . current_child_idx += 1 case NodeStatus . IDLE : raise RuntimeError ( \"Child can't return IDLE\" ) if self . current_child_idx == n_children : self . reset () return NodeStatus . SUCCESS def pretty_repr ( self , depth = 0 ) -> str : \"\"\" Return a string representation of this node at the given depth. Args: depth (`int`): The depth of this node in a surrounding tree. Returns: `str`: The indented string representation. \"\"\" tabs = ' \\t ' * depth repr = f \" { tabs } Sequence { self . name } \" for child in self . children : child_repr = child . pretty_repr ( depth + 1 ) repr += f \" \\n { child_repr } \" repr += \" \\n \" return repr","title":"Sequence"},{"location":"api/controls/sequence/#dendron.controls.sequence.Sequence.halt_node","text":"Set the current child index to 0 and instruct all children to halt via the parent class halt() . Source code in src/dendron/controls/sequence.py 36 37 38 39 40 41 42 def halt_node ( self ) -> None : \"\"\" Set the current child index to 0 and instruct all children to halt via the parent class `halt()`. \"\"\" self . current_child_idx = 0 ControlNode . halt ( self )","title":"halt_node"},{"location":"api/controls/sequence/#dendron.controls.sequence.Sequence.reset","text":"Set the current child index to 0 and instruct all children to reset. Source code in src/dendron/controls/sequence.py 27 28 29 30 31 32 33 34 def reset ( self ) -> None : \"\"\" Set the current child index to 0 and instruct all children to reset. \"\"\" self . current_child_idx = 0 for child in self . children : child . reset ()","title":"reset"},{"location":"api/controls/sequence/#dendron.controls.sequence.Sequence.tick","text":"Successively tick() each child node until one returns a status of FAILURE . If all children succeed, return SUCCESS . Returns: Type Description NodeStatus NodeStatus : FAILURE if at least one child fails, NodeStatus SUCCESS otherwise. May return RUNNING or SKIPPED NodeStatus depending on children's behavior. Source code in src/dendron/controls/sequence.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def tick ( self ) -> NodeStatus : \"\"\" Successively `tick()` each child node until one returns a status of `FAILURE`. If all children succeed, return `SUCCESS`. Returns: `NodeStatus`: `FAILURE` if at least one child fails, `SUCCESS` otherwise. May return `RUNNING` or `SKIPPED` depending on children's behavior. \"\"\" n_children = self . children_count () self . set_status ( NodeStatus . RUNNING ) while ( self . current_child_idx < n_children ): current_child = self . children [ self . current_child_idx ] child_status = current_child . execute_tick () match child_status : case NodeStatus . RUNNING : return NodeStatus . RUNNING case NodeStatus . FAILURE : self . reset () self . current_child_idx = 0 return child_status case NodeStatus . SUCCESS : self . current_child_idx += 1 case NodeStatus . SKIPPED : self . current_child_idx += 1 case NodeStatus . IDLE : raise RuntimeError ( \"Child can't return IDLE\" ) if self . current_child_idx == n_children : self . reset () return NodeStatus . SUCCESS","title":"tick"},{"location":"api/decorators/blackboard_history/","text":"BlackboardHistory Bases: DecoratorNode The Blackboard history node keeps track of a blackboard entry related to a child node. Every time this node is ticked, it examines the blackboard and records the value stored at the child_key before tick() ing the child. The history is itself stored in the blackboard, by default at the key \"{child_node.name}/{child_key}/history\". Parameters: Name Type Description Default name `str` The given name of this node. required child `dendron.tree_node.TreeNode` The child node whose blackboard history we want to track. required child_key `str` The blackboard key we want to record values for. 'in' Source code in src/dendron/decorators/blackboard_history.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class BlackboardHistory ( DecoratorNode ): \"\"\" The Blackboard history node keeps track of a blackboard entry related to a child node. Every time this node is ticked, it examines the blackboard and records the value stored at the `child_key` before `tick()`ing the child. The history is itself stored in the blackboard, by default at the key \"{child_node.name}/{child_key}/history\". Args: name (`str`): The given name of this node. child (`dendron.tree_node.TreeNode`): The child node whose blackboard history we want to track. child_key (`str`): The blackboard key we want to record values for. \"\"\" def __init__ ( self , name , child : TreeNode , child_key : str = \"in\" ) -> None : super () . __init__ ( name , child ) self . child_key = self . child_node . input_key self . history_key = f \" { self . child_node . name } / { child_key } /history\" if self . blackboard is not None : self . blackboard [ self . history_key ] = [] def set_blackboard ( self , bb : Blackboard ) -> None : \"\"\" Assign a new blackboard for history tracking. Args: bb (`dendron.blackboard.Blackboard`): The new blackboard to track. \"\"\" self . blackboard = bb self . blackboard [ self . history_key ] = [] self . child_node . set_blackboard ( bb ) def reset ( self ) -> None : \"\"\" Clear the history and instruct the child to reset. \"\"\" self . blackboard [ self . history_key ] = [] self . child_node . reset () def tick ( self ) -> NodeStatus : \"\"\" Record the value stored in the blackboard at `child_key` and then instruct the child node to execute its `tick()` function. \"\"\" latest = self . blackboard [ self . child_key ] self . blackboard [ self . history_key ] . append ( latest ) status = self . child_node . execute_tick () return status reset () Clear the history and instruct the child to reset. Source code in src/dendron/decorators/blackboard_history.py 45 46 47 48 49 50 def reset ( self ) -> None : \"\"\" Clear the history and instruct the child to reset. \"\"\" self . blackboard [ self . history_key ] = [] self . child_node . reset () set_blackboard ( bb ) Assign a new blackboard for history tracking. Parameters: Name Type Description Default bb `dendron.blackboard.Blackboard` The new blackboard to track. required Source code in src/dendron/decorators/blackboard_history.py 32 33 34 35 36 37 38 39 40 41 42 43 def set_blackboard ( self , bb : Blackboard ) -> None : \"\"\" Assign a new blackboard for history tracking. Args: bb (`dendron.blackboard.Blackboard`): The new blackboard to track. \"\"\" self . blackboard = bb self . blackboard [ self . history_key ] = [] self . child_node . set_blackboard ( bb ) tick () Record the value stored in the blackboard at child_key and then instruct the child node to execute its tick() function. Source code in src/dendron/decorators/blackboard_history.py 52 53 54 55 56 57 58 59 60 61 62 def tick ( self ) -> NodeStatus : \"\"\" Record the value stored in the blackboard at `child_key` and then instruct the child node to execute its `tick()` function. \"\"\" latest = self . blackboard [ self . child_key ] self . blackboard [ self . history_key ] . append ( latest ) status = self . child_node . execute_tick () return status","title":"BlackboardHistory"},{"location":"api/decorators/blackboard_history/#blackboardhistory","text":"Bases: DecoratorNode The Blackboard history node keeps track of a blackboard entry related to a child node. Every time this node is ticked, it examines the blackboard and records the value stored at the child_key before tick() ing the child. The history is itself stored in the blackboard, by default at the key \"{child_node.name}/{child_key}/history\". Parameters: Name Type Description Default name `str` The given name of this node. required child `dendron.tree_node.TreeNode` The child node whose blackboard history we want to track. required child_key `str` The blackboard key we want to record values for. 'in' Source code in src/dendron/decorators/blackboard_history.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class BlackboardHistory ( DecoratorNode ): \"\"\" The Blackboard history node keeps track of a blackboard entry related to a child node. Every time this node is ticked, it examines the blackboard and records the value stored at the `child_key` before `tick()`ing the child. The history is itself stored in the blackboard, by default at the key \"{child_node.name}/{child_key}/history\". Args: name (`str`): The given name of this node. child (`dendron.tree_node.TreeNode`): The child node whose blackboard history we want to track. child_key (`str`): The blackboard key we want to record values for. \"\"\" def __init__ ( self , name , child : TreeNode , child_key : str = \"in\" ) -> None : super () . __init__ ( name , child ) self . child_key = self . child_node . input_key self . history_key = f \" { self . child_node . name } / { child_key } /history\" if self . blackboard is not None : self . blackboard [ self . history_key ] = [] def set_blackboard ( self , bb : Blackboard ) -> None : \"\"\" Assign a new blackboard for history tracking. Args: bb (`dendron.blackboard.Blackboard`): The new blackboard to track. \"\"\" self . blackboard = bb self . blackboard [ self . history_key ] = [] self . child_node . set_blackboard ( bb ) def reset ( self ) -> None : \"\"\" Clear the history and instruct the child to reset. \"\"\" self . blackboard [ self . history_key ] = [] self . child_node . reset () def tick ( self ) -> NodeStatus : \"\"\" Record the value stored in the blackboard at `child_key` and then instruct the child node to execute its `tick()` function. \"\"\" latest = self . blackboard [ self . child_key ] self . blackboard [ self . history_key ] . append ( latest ) status = self . child_node . execute_tick () return status","title":"BlackboardHistory"},{"location":"api/decorators/blackboard_history/#dendron.decorators.blackboard_history.BlackboardHistory.reset","text":"Clear the history and instruct the child to reset. Source code in src/dendron/decorators/blackboard_history.py 45 46 47 48 49 50 def reset ( self ) -> None : \"\"\" Clear the history and instruct the child to reset. \"\"\" self . blackboard [ self . history_key ] = [] self . child_node . reset ()","title":"reset"},{"location":"api/decorators/blackboard_history/#dendron.decorators.blackboard_history.BlackboardHistory.set_blackboard","text":"Assign a new blackboard for history tracking. Parameters: Name Type Description Default bb `dendron.blackboard.Blackboard` The new blackboard to track. required Source code in src/dendron/decorators/blackboard_history.py 32 33 34 35 36 37 38 39 40 41 42 43 def set_blackboard ( self , bb : Blackboard ) -> None : \"\"\" Assign a new blackboard for history tracking. Args: bb (`dendron.blackboard.Blackboard`): The new blackboard to track. \"\"\" self . blackboard = bb self . blackboard [ self . history_key ] = [] self . child_node . set_blackboard ( bb )","title":"set_blackboard"},{"location":"api/decorators/blackboard_history/#dendron.decorators.blackboard_history.BlackboardHistory.tick","text":"Record the value stored in the blackboard at child_key and then instruct the child node to execute its tick() function. Source code in src/dendron/decorators/blackboard_history.py 52 53 54 55 56 57 58 59 60 61 62 def tick ( self ) -> NodeStatus : \"\"\" Record the value stored in the blackboard at `child_key` and then instruct the child node to execute its `tick()` function. \"\"\" latest = self . blackboard [ self . child_key ] self . blackboard [ self . history_key ] . append ( latest ) status = self . child_node . execute_tick () return status","title":"tick"},{"location":"api/decorators/force_failure/","text":"ForceFailure Bases: DecoratorNode A Force Failure decorator will tick its child, and regardless of the result will return failure. May be useful for debugging. Parameters: Name Type Description Default name `str` The given name of this node. required child `dendron.tree_node.TreeNode` An optional child node. If None , the caller is responsible for setting the child_node member variable before tick() is called. None Source code in src/dendron/decorators/force_failure.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class ForceFailure ( DecoratorNode ): \"\"\" A Force Failure decorator will tick its child, and regardless of the result will return failure. May be useful for debugging. Args: name (`str`): The given name of this node. child (`dendron.tree_node.TreeNode`): An optional child node. If `None`, the caller is responsible for setting the `child_node` member variable before `tick()` is called. \"\"\" def __init__ ( self , name : str , child : TreeNode = None ) -> None : super () . __init__ ( name ) self . name = name self . child_node = child def tick ( self ) -> NodeStatus : \"\"\" Call the `tick()` method of the child and then return a status of `FAILURE`. \"\"\" self . child_node . execute_tick () return NodeStatus . FAILURE tick () Call the tick() method of the child and then return a status of FAILURE . Source code in src/dendron/decorators/force_failure.py 25 26 27 28 29 30 31 def tick ( self ) -> NodeStatus : \"\"\" Call the `tick()` method of the child and then return a status of `FAILURE`. \"\"\" self . child_node . execute_tick () return NodeStatus . FAILURE","title":"ForceFailure"},{"location":"api/decorators/force_failure/#forcefailure","text":"Bases: DecoratorNode A Force Failure decorator will tick its child, and regardless of the result will return failure. May be useful for debugging. Parameters: Name Type Description Default name `str` The given name of this node. required child `dendron.tree_node.TreeNode` An optional child node. If None , the caller is responsible for setting the child_node member variable before tick() is called. None Source code in src/dendron/decorators/force_failure.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class ForceFailure ( DecoratorNode ): \"\"\" A Force Failure decorator will tick its child, and regardless of the result will return failure. May be useful for debugging. Args: name (`str`): The given name of this node. child (`dendron.tree_node.TreeNode`): An optional child node. If `None`, the caller is responsible for setting the `child_node` member variable before `tick()` is called. \"\"\" def __init__ ( self , name : str , child : TreeNode = None ) -> None : super () . __init__ ( name ) self . name = name self . child_node = child def tick ( self ) -> NodeStatus : \"\"\" Call the `tick()` method of the child and then return a status of `FAILURE`. \"\"\" self . child_node . execute_tick () return NodeStatus . FAILURE","title":"ForceFailure"},{"location":"api/decorators/force_failure/#dendron.decorators.force_failure.ForceFailure.tick","text":"Call the tick() method of the child and then return a status of FAILURE . Source code in src/dendron/decorators/force_failure.py 25 26 27 28 29 30 31 def tick ( self ) -> NodeStatus : \"\"\" Call the `tick()` method of the child and then return a status of `FAILURE`. \"\"\" self . child_node . execute_tick () return NodeStatus . FAILURE","title":"tick"},{"location":"api/decorators/force_success/","text":"ForceSuccess Bases: DecoratorNode A Force Success node calls the tick() method of its child, ignores the result, and always returns a status of SUCCESS . May be useful for debugging. Parameters: Name Type Description Default name `str` The given name of this node. required child `dendron.tree_node.TreeNode` An optional child node. If None , it is the responsibility of the caller to ensure that the child_node member variable is set prior to the first tick() call. None Source code in src/dendron/decorators/force_success.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class ForceSuccess ( DecoratorNode ): \"\"\" A Force Success node calls the `tick()` method of its child, ignores the result, and always returns a status of `SUCCESS`. May be useful for debugging. Args: name (`str`): The given name of this node. child (`dendron.tree_node.TreeNode`): An optional child node. If `None`, it is the responsibility of the caller to ensure that the `child_node` member variable is set prior to the first `tick()` call. \"\"\" def __init__ ( self , name : str , child : TreeNode = None ) -> None : super () . __init__ ( name , child ) def tick ( self ) -> NodeStatus : \"\"\" Instruct the child node to execute its `tick()` method, ignore the result, and return `SUCCESS`. \"\"\" self . child_node . execute_tick () return NodeStatus . SUCCESS tick () Instruct the child node to execute its tick() method, ignore the result, and return SUCCESS . Source code in src/dendron/decorators/force_success.py 23 24 25 26 27 28 29 def tick ( self ) -> NodeStatus : \"\"\" Instruct the child node to execute its `tick()` method, ignore the result, and return `SUCCESS`. \"\"\" self . child_node . execute_tick () return NodeStatus . SUCCESS","title":"ForceSuccess"},{"location":"api/decorators/force_success/#forcesuccess","text":"Bases: DecoratorNode A Force Success node calls the tick() method of its child, ignores the result, and always returns a status of SUCCESS . May be useful for debugging. Parameters: Name Type Description Default name `str` The given name of this node. required child `dendron.tree_node.TreeNode` An optional child node. If None , it is the responsibility of the caller to ensure that the child_node member variable is set prior to the first tick() call. None Source code in src/dendron/decorators/force_success.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class ForceSuccess ( DecoratorNode ): \"\"\" A Force Success node calls the `tick()` method of its child, ignores the result, and always returns a status of `SUCCESS`. May be useful for debugging. Args: name (`str`): The given name of this node. child (`dendron.tree_node.TreeNode`): An optional child node. If `None`, it is the responsibility of the caller to ensure that the `child_node` member variable is set prior to the first `tick()` call. \"\"\" def __init__ ( self , name : str , child : TreeNode = None ) -> None : super () . __init__ ( name , child ) def tick ( self ) -> NodeStatus : \"\"\" Instruct the child node to execute its `tick()` method, ignore the result, and return `SUCCESS`. \"\"\" self . child_node . execute_tick () return NodeStatus . SUCCESS","title":"ForceSuccess"},{"location":"api/decorators/force_success/#dendron.decorators.force_success.ForceSuccess.tick","text":"Instruct the child node to execute its tick() method, ignore the result, and return SUCCESS . Source code in src/dendron/decorators/force_success.py 23 24 25 26 27 28 29 def tick ( self ) -> NodeStatus : \"\"\" Instruct the child node to execute its `tick()` method, ignore the result, and return `SUCCESS`. \"\"\" self . child_node . execute_tick () return NodeStatus . SUCCESS","title":"tick"},{"location":"api/decorators/inverter/","text":"Inverter Bases: DecoratorNode An Inverter decorator instructs its child node to tick() and then returns the negation of the child's status as its own. Parameters: Name Type Description Default name `str` The given name of this node. required child `dendron.tree_node.TreeNode` Optional child node. If None , it is the responsibility of the caller to ensure that the child_node member variable is set before the first tick() call. None Source code in src/dendron/decorators/inverter.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Inverter ( DecoratorNode ): \"\"\" An Inverter decorator instructs its child node to `tick()` and then returns the negation of the child's status as its own. Args: name (`str`): The given name of this node. child (`dendron.tree_node.TreeNode`): Optional child node. If `None`, it is the responsibility of the caller to ensure that the `child_node` member variable is set before the first `tick()` call. \"\"\" def __init__ ( self , name , child : TreeNode = None ) -> None : super () . __init__ ( name ) self . name = name self . child_node = child def tick ( self ) -> NodeStatus : \"\"\" Instruct the child node to execute its `tick()` function, and then return `SUCCESS` if the child fails, and `FAILURE` if the child succeeds. Returns `RUNNING` if the child returns `RUNNING`. \"\"\" self . set_status ( NodeStatus . RUNNING ) child_status = self . child_node . execute_tick () match child_status : case NodeStatus . SUCCESS : self . reset () return NodeStatus . FAILURE case NodeStatus . FAILURE : self . reset () return NodeStatus . SUCCESS case NodeStatus . IDLE : raise RuntimeError ( \"Child can't return IDLE\" ) case _ : return child_status tick () Instruct the child node to execute its tick() function, and then return SUCCESS if the child fails, and FAILURE if the child succeeds. Returns RUNNING if the child returns RUNNING . Source code in src/dendron/decorators/inverter.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def tick ( self ) -> NodeStatus : \"\"\" Instruct the child node to execute its `tick()` function, and then return `SUCCESS` if the child fails, and `FAILURE` if the child succeeds. Returns `RUNNING` if the child returns `RUNNING`. \"\"\" self . set_status ( NodeStatus . RUNNING ) child_status = self . child_node . execute_tick () match child_status : case NodeStatus . SUCCESS : self . reset () return NodeStatus . FAILURE case NodeStatus . FAILURE : self . reset () return NodeStatus . SUCCESS case NodeStatus . IDLE : raise RuntimeError ( \"Child can't return IDLE\" ) case _ : return child_status","title":"Inverter"},{"location":"api/decorators/inverter/#inverter","text":"Bases: DecoratorNode An Inverter decorator instructs its child node to tick() and then returns the negation of the child's status as its own. Parameters: Name Type Description Default name `str` The given name of this node. required child `dendron.tree_node.TreeNode` Optional child node. If None , it is the responsibility of the caller to ensure that the child_node member variable is set before the first tick() call. None Source code in src/dendron/decorators/inverter.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Inverter ( DecoratorNode ): \"\"\" An Inverter decorator instructs its child node to `tick()` and then returns the negation of the child's status as its own. Args: name (`str`): The given name of this node. child (`dendron.tree_node.TreeNode`): Optional child node. If `None`, it is the responsibility of the caller to ensure that the `child_node` member variable is set before the first `tick()` call. \"\"\" def __init__ ( self , name , child : TreeNode = None ) -> None : super () . __init__ ( name ) self . name = name self . child_node = child def tick ( self ) -> NodeStatus : \"\"\" Instruct the child node to execute its `tick()` function, and then return `SUCCESS` if the child fails, and `FAILURE` if the child succeeds. Returns `RUNNING` if the child returns `RUNNING`. \"\"\" self . set_status ( NodeStatus . RUNNING ) child_status = self . child_node . execute_tick () match child_status : case NodeStatus . SUCCESS : self . reset () return NodeStatus . FAILURE case NodeStatus . FAILURE : self . reset () return NodeStatus . SUCCESS case NodeStatus . IDLE : raise RuntimeError ( \"Child can't return IDLE\" ) case _ : return child_status","title":"Inverter"},{"location":"api/decorators/inverter/#dendron.decorators.inverter.Inverter.tick","text":"Instruct the child node to execute its tick() function, and then return SUCCESS if the child fails, and FAILURE if the child succeeds. Returns RUNNING if the child returns RUNNING . Source code in src/dendron/decorators/inverter.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def tick ( self ) -> NodeStatus : \"\"\" Instruct the child node to execute its `tick()` function, and then return `SUCCESS` if the child fails, and `FAILURE` if the child succeeds. Returns `RUNNING` if the child returns `RUNNING`. \"\"\" self . set_status ( NodeStatus . RUNNING ) child_status = self . child_node . execute_tick () match child_status : case NodeStatus . SUCCESS : self . reset () return NodeStatus . FAILURE case NodeStatus . FAILURE : self . reset () return NodeStatus . SUCCESS case NodeStatus . IDLE : raise RuntimeError ( \"Child can't return IDLE\" ) case _ : return child_status","title":"tick"},{"location":"api/decorators/repeat/","text":"Repeat Bases: DecoratorNode A Repeat node ticks its child node repeatedly as long as the child continues to return SUCCESS . Parameters: Name Type Description Default name `str` The given name of this node. required child `dendron.tree_node.TreeNode` Optional child node. If None , it is the responsibility of the caller to ensure that the child_node member variable is set before the first tick() call. required n_times `int` Number of times to tick() the child node if it continues to return SUCCESS . required Source code in src/dendron/decorators/repeat.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Repeat ( DecoratorNode ): \"\"\" A Repeat node ticks its child node repeatedly as long as the child continues to return `SUCCESS`. Args: name (`str`): The given name of this node. child (`dendron.tree_node.TreeNode`): Optional child node. If `None`, it is the responsibility of the caller to ensure that the `child_node` member variable is set before the first `tick()` call. n_times (`int`): Number of times to `tick()` the child node if it continues to return `SUCCESS`. \"\"\" def __init__ ( self , name : str , child : TreeNode , n_times : int ) -> None : super () . __init__ ( name , child ) self . n_times = n_times self . repeat_ct = 0 def reset ( self ) -> None : \"\"\" Set the repeat counter to 0 and instruct the child node to reset. \"\"\" self . repeat_ct = 0 self . child_node . reset () def tick ( self ) -> NodeStatus : \"\"\" Tick the child node until either it returns `FAILURE` or the child is `tick()`ed `n_times`. \"\"\" should_repeat = True while should_repeat : child_status = self . child_node . execute_tick () match child_status : case NodeStatus . SUCCESS : self . repeat_ct += 1 should_repeat = self . repeat_ct < self . n_times case NodeStatus . FAILURE : self . repeat_ct = 0 self . reset_child () return NodeStatus . FAILURE case NodeStatus . RUNNING : return NodeStatus . RUNNING self . repeat_ct = 0 return NodeStatus . SUCCESS # TODO handle skips? reset () Set the repeat counter to 0 and instruct the child node to reset. Source code in src/dendron/decorators/repeat.py 26 27 28 29 30 31 def reset ( self ) -> None : \"\"\" Set the repeat counter to 0 and instruct the child node to reset. \"\"\" self . repeat_ct = 0 self . child_node . reset () tick () Tick the child node until either it returns FAILURE or the child is tick() ed n_times . Source code in src/dendron/decorators/repeat.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def tick ( self ) -> NodeStatus : \"\"\" Tick the child node until either it returns `FAILURE` or the child is `tick()`ed `n_times`. \"\"\" should_repeat = True while should_repeat : child_status = self . child_node . execute_tick () match child_status : case NodeStatus . SUCCESS : self . repeat_ct += 1 should_repeat = self . repeat_ct < self . n_times case NodeStatus . FAILURE : self . repeat_ct = 0 self . reset_child () return NodeStatus . FAILURE case NodeStatus . RUNNING : return NodeStatus . RUNNING self . repeat_ct = 0 return NodeStatus . SUCCESS # TODO handle skips?","title":"Repeat"},{"location":"api/decorators/repeat/#repeat","text":"Bases: DecoratorNode A Repeat node ticks its child node repeatedly as long as the child continues to return SUCCESS . Parameters: Name Type Description Default name `str` The given name of this node. required child `dendron.tree_node.TreeNode` Optional child node. If None , it is the responsibility of the caller to ensure that the child_node member variable is set before the first tick() call. required n_times `int` Number of times to tick() the child node if it continues to return SUCCESS . required Source code in src/dendron/decorators/repeat.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Repeat ( DecoratorNode ): \"\"\" A Repeat node ticks its child node repeatedly as long as the child continues to return `SUCCESS`. Args: name (`str`): The given name of this node. child (`dendron.tree_node.TreeNode`): Optional child node. If `None`, it is the responsibility of the caller to ensure that the `child_node` member variable is set before the first `tick()` call. n_times (`int`): Number of times to `tick()` the child node if it continues to return `SUCCESS`. \"\"\" def __init__ ( self , name : str , child : TreeNode , n_times : int ) -> None : super () . __init__ ( name , child ) self . n_times = n_times self . repeat_ct = 0 def reset ( self ) -> None : \"\"\" Set the repeat counter to 0 and instruct the child node to reset. \"\"\" self . repeat_ct = 0 self . child_node . reset () def tick ( self ) -> NodeStatus : \"\"\" Tick the child node until either it returns `FAILURE` or the child is `tick()`ed `n_times`. \"\"\" should_repeat = True while should_repeat : child_status = self . child_node . execute_tick () match child_status : case NodeStatus . SUCCESS : self . repeat_ct += 1 should_repeat = self . repeat_ct < self . n_times case NodeStatus . FAILURE : self . repeat_ct = 0 self . reset_child () return NodeStatus . FAILURE case NodeStatus . RUNNING : return NodeStatus . RUNNING self . repeat_ct = 0 return NodeStatus . SUCCESS # TODO handle skips?","title":"Repeat"},{"location":"api/decorators/repeat/#dendron.decorators.repeat.Repeat.reset","text":"Set the repeat counter to 0 and instruct the child node to reset. Source code in src/dendron/decorators/repeat.py 26 27 28 29 30 31 def reset ( self ) -> None : \"\"\" Set the repeat counter to 0 and instruct the child node to reset. \"\"\" self . repeat_ct = 0 self . child_node . reset ()","title":"reset"},{"location":"api/decorators/repeat/#dendron.decorators.repeat.Repeat.tick","text":"Tick the child node until either it returns FAILURE or the child is tick() ed n_times . Source code in src/dendron/decorators/repeat.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def tick ( self ) -> NodeStatus : \"\"\" Tick the child node until either it returns `FAILURE` or the child is `tick()`ed `n_times`. \"\"\" should_repeat = True while should_repeat : child_status = self . child_node . execute_tick () match child_status : case NodeStatus . SUCCESS : self . repeat_ct += 1 should_repeat = self . repeat_ct < self . n_times case NodeStatus . FAILURE : self . repeat_ct = 0 self . reset_child () return NodeStatus . FAILURE case NodeStatus . RUNNING : return NodeStatus . RUNNING self . repeat_ct = 0 return NodeStatus . SUCCESS # TODO handle skips?","title":"tick"},{"location":"api/decorators/retry/","text":"Retry Bases: DecoratorNode A Retry node ticks its child node repeatedly as long as the child continues to return FAILURE . Parameters: Name Type Description Default name `str` The given name of this node. required child `dendron.tree_node.TreeNode` Optional child node. If None , it is the responsibility of the caller to ensure that the child_node member variable is set before the first tick() call. required n_times `int` Number of times to tick() the child node if it continues to return FAILURE . required Source code in src/dendron/decorators/retry.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Retry ( DecoratorNode ): \"\"\" A Retry node ticks its child node repeatedly as long as the child continues to return `FAILURE`. Args: name (`str`): The given name of this node. child (`dendron.tree_node.TreeNode`): Optional child node. If `None`, it is the responsibility of the caller to ensure that the `child_node` member variable is set before the first `tick()` call. n_times (`int`): Number of times to `tick()` the child node if it continues to return `FAILURE`. \"\"\" def __init__ ( self , name : str , child : TreeNode , n_times : int ) -> None : super () . __init__ ( self , child ) self . n_times = n_times self . retry_ct = 0 def reset ( self ) -> None : \"\"\" Set the retry counter to 0 and instruct the child node to reset. \"\"\" self . retry_ct = 0 self . child_node . reset () def tick ( self ) -> NodeStatus : \"\"\" Tick the child node until either it returns `SUCCESS` or the child is `tick()`ed `n_times`. \"\"\" should_retry = True while should_retry : child_status = self . child_node . execute_tick () match child_status : case NodeStatus . SUCCESS : self . retry_ct = 0 self . reset_child () return NodeStatus . SUCCESS case NodeStatus . FAILURE : self . retry_ct += 1 should_retry = self . retry_ct < self . n_times case NodeStatus . RUNNING : return NodeStatus . RUNNING self . retry_ct = 0 return NodeStatus . FAILURE reset () Set the retry counter to 0 and instruct the child node to reset. Source code in src/dendron/decorators/retry.py 26 27 28 29 30 31 def reset ( self ) -> None : \"\"\" Set the retry counter to 0 and instruct the child node to reset. \"\"\" self . retry_ct = 0 self . child_node . reset () tick () Tick the child node until either it returns SUCCESS or the child is tick() ed n_times . Source code in src/dendron/decorators/retry.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def tick ( self ) -> NodeStatus : \"\"\" Tick the child node until either it returns `SUCCESS` or the child is `tick()`ed `n_times`. \"\"\" should_retry = True while should_retry : child_status = self . child_node . execute_tick () match child_status : case NodeStatus . SUCCESS : self . retry_ct = 0 self . reset_child () return NodeStatus . SUCCESS case NodeStatus . FAILURE : self . retry_ct += 1 should_retry = self . retry_ct < self . n_times case NodeStatus . RUNNING : return NodeStatus . RUNNING self . retry_ct = 0 return NodeStatus . FAILURE","title":"Retry"},{"location":"api/decorators/retry/#retry","text":"Bases: DecoratorNode A Retry node ticks its child node repeatedly as long as the child continues to return FAILURE . Parameters: Name Type Description Default name `str` The given name of this node. required child `dendron.tree_node.TreeNode` Optional child node. If None , it is the responsibility of the caller to ensure that the child_node member variable is set before the first tick() call. required n_times `int` Number of times to tick() the child node if it continues to return FAILURE . required Source code in src/dendron/decorators/retry.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Retry ( DecoratorNode ): \"\"\" A Retry node ticks its child node repeatedly as long as the child continues to return `FAILURE`. Args: name (`str`): The given name of this node. child (`dendron.tree_node.TreeNode`): Optional child node. If `None`, it is the responsibility of the caller to ensure that the `child_node` member variable is set before the first `tick()` call. n_times (`int`): Number of times to `tick()` the child node if it continues to return `FAILURE`. \"\"\" def __init__ ( self , name : str , child : TreeNode , n_times : int ) -> None : super () . __init__ ( self , child ) self . n_times = n_times self . retry_ct = 0 def reset ( self ) -> None : \"\"\" Set the retry counter to 0 and instruct the child node to reset. \"\"\" self . retry_ct = 0 self . child_node . reset () def tick ( self ) -> NodeStatus : \"\"\" Tick the child node until either it returns `SUCCESS` or the child is `tick()`ed `n_times`. \"\"\" should_retry = True while should_retry : child_status = self . child_node . execute_tick () match child_status : case NodeStatus . SUCCESS : self . retry_ct = 0 self . reset_child () return NodeStatus . SUCCESS case NodeStatus . FAILURE : self . retry_ct += 1 should_retry = self . retry_ct < self . n_times case NodeStatus . RUNNING : return NodeStatus . RUNNING self . retry_ct = 0 return NodeStatus . FAILURE","title":"Retry"},{"location":"api/decorators/retry/#dendron.decorators.retry.Retry.reset","text":"Set the retry counter to 0 and instruct the child node to reset. Source code in src/dendron/decorators/retry.py 26 27 28 29 30 31 def reset ( self ) -> None : \"\"\" Set the retry counter to 0 and instruct the child node to reset. \"\"\" self . retry_ct = 0 self . child_node . reset ()","title":"reset"},{"location":"api/decorators/retry/#dendron.decorators.retry.Retry.tick","text":"Tick the child node until either it returns SUCCESS or the child is tick() ed n_times . Source code in src/dendron/decorators/retry.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def tick ( self ) -> NodeStatus : \"\"\" Tick the child node until either it returns `SUCCESS` or the child is `tick()`ed `n_times`. \"\"\" should_retry = True while should_retry : child_status = self . child_node . execute_tick () match child_status : case NodeStatus . SUCCESS : self . retry_ct = 0 self . reset_child () return NodeStatus . SUCCESS case NodeStatus . FAILURE : self . retry_ct += 1 should_retry = self . retry_ct < self . n_times case NodeStatus . RUNNING : return NodeStatus . RUNNING self . retry_ct = 0 return NodeStatus . FAILURE","title":"tick"},{"location":"api/decorators/run_once/","text":"RunOnce Bases: DecoratorNode The RunOnce decorator tracks whether or not its child has been ticked. If it has, the next time it is ticked the decorator will return a status of SKIPPED . It will continue to return that status until it is explicitly reset. Parameters: Name Type Description Default name `str` The given name of this node. required child `dendron.tree_node.TreeNode` The child node. required Source code in src/dendron/decorators/run_once.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class RunOnce ( DecoratorNode ): \"\"\" The RunOnce decorator tracks whether or not its child has been ticked. If it has, the next time it is ticked the decorator will return a status of `SKIPPED`. It will continue to return that status until it is explicitly reset. Args: name (`str`): The given name of this node. child (`dendron.tree_node.TreeNode`): The child node. \"\"\" def __init__ ( self , name : str , child : TreeNode ) -> None : super () . __init__ ( name , child ) self . has_run = False def reset ( self ) -> None : \"\"\" Reset the `has_run` tracker so that the child node can be `tick()`ed again. \"\"\" self . has_run = False self . status = NodeStatus . IDLE self . child_node . reset_status () def tick ( self ) -> NodeStatus : \"\"\" If the child node has been `tick()`ed already, return a status of `SKIPPED` without `tick()`ing the child again. Otherwise `tick()` the child node and set `has_run` to `True` so that the node will not be `tick()`ed again. \"\"\" self . set_status ( NodeStatus . RUNNING ) if self . has_run : return NodeStatus . SKIPPED self . has_run = True child_status = self . child_node . execute_tick () return child_status reset () Reset the has_run tracker so that the child node can be tick() ed again. Source code in src/dendron/decorators/run_once.py 22 23 24 25 26 27 28 29 def reset ( self ) -> None : \"\"\" Reset the `has_run` tracker so that the child node can be `tick()`ed again. \"\"\" self . has_run = False self . status = NodeStatus . IDLE self . child_node . reset_status () tick () If the child node has been tick() ed already, return a status of SKIPPED without tick() ing the child again. Otherwise tick() the child node and set has_run to True so that the node will not be tick() ed again. Source code in src/dendron/decorators/run_once.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def tick ( self ) -> NodeStatus : \"\"\" If the child node has been `tick()`ed already, return a status of `SKIPPED` without `tick()`ing the child again. Otherwise `tick()` the child node and set `has_run` to `True` so that the node will not be `tick()`ed again. \"\"\" self . set_status ( NodeStatus . RUNNING ) if self . has_run : return NodeStatus . SKIPPED self . has_run = True child_status = self . child_node . execute_tick () return child_status","title":"RunOnce"},{"location":"api/decorators/run_once/#runonce","text":"Bases: DecoratorNode The RunOnce decorator tracks whether or not its child has been ticked. If it has, the next time it is ticked the decorator will return a status of SKIPPED . It will continue to return that status until it is explicitly reset. Parameters: Name Type Description Default name `str` The given name of this node. required child `dendron.tree_node.TreeNode` The child node. required Source code in src/dendron/decorators/run_once.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class RunOnce ( DecoratorNode ): \"\"\" The RunOnce decorator tracks whether or not its child has been ticked. If it has, the next time it is ticked the decorator will return a status of `SKIPPED`. It will continue to return that status until it is explicitly reset. Args: name (`str`): The given name of this node. child (`dendron.tree_node.TreeNode`): The child node. \"\"\" def __init__ ( self , name : str , child : TreeNode ) -> None : super () . __init__ ( name , child ) self . has_run = False def reset ( self ) -> None : \"\"\" Reset the `has_run` tracker so that the child node can be `tick()`ed again. \"\"\" self . has_run = False self . status = NodeStatus . IDLE self . child_node . reset_status () def tick ( self ) -> NodeStatus : \"\"\" If the child node has been `tick()`ed already, return a status of `SKIPPED` without `tick()`ing the child again. Otherwise `tick()` the child node and set `has_run` to `True` so that the node will not be `tick()`ed again. \"\"\" self . set_status ( NodeStatus . RUNNING ) if self . has_run : return NodeStatus . SKIPPED self . has_run = True child_status = self . child_node . execute_tick () return child_status","title":"RunOnce"},{"location":"api/decorators/run_once/#dendron.decorators.run_once.RunOnce.reset","text":"Reset the has_run tracker so that the child node can be tick() ed again. Source code in src/dendron/decorators/run_once.py 22 23 24 25 26 27 28 29 def reset ( self ) -> None : \"\"\" Reset the `has_run` tracker so that the child node can be `tick()`ed again. \"\"\" self . has_run = False self . status = NodeStatus . IDLE self . child_node . reset_status ()","title":"reset"},{"location":"api/decorators/run_once/#dendron.decorators.run_once.RunOnce.tick","text":"If the child node has been tick() ed already, return a status of SKIPPED without tick() ing the child again. Otherwise tick() the child node and set has_run to True so that the node will not be tick() ed again. Source code in src/dendron/decorators/run_once.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def tick ( self ) -> NodeStatus : \"\"\" If the child node has been `tick()`ed already, return a status of `SKIPPED` without `tick()`ing the child again. Otherwise `tick()` the child node and set `has_run` to `True` so that the node will not be `tick()`ed again. \"\"\" self . set_status ( NodeStatus . RUNNING ) if self . has_run : return NodeStatus . SKIPPED self . has_run = True child_status = self . child_node . execute_tick () return child_status","title":"tick"},{"location":"api/decorators/timeout/","text":"Timeout Bases: DecoratorNode The timeout decorator ticks its child and starts a timer. The next time it receives a tick it will check its timer against the time limit. If the elapsed time exceeds the limit, this node returns FAILURE . This is primarily useful for nodes that are executing asynchronously. Parameters: Name Type Description Default name `str` The given name of this node. required child `dendron.tree_node.TreeNode` The child of this node. required timelimit `int` The integer number of milliseconds to wait before returning failure. required Source code in src/dendron/decorators/timeout.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Timeout ( DecoratorNode ): \"\"\" The timeout decorator ticks its child and starts a timer. The next time it receives a tick it will check its timer against the time limit. If the elapsed time exceeds the limit, this node returns `FAILURE`. This is primarily useful for nodes that are executing asynchronously. Args: name (`str`): The given name of this node. child (`dendron.tree_node.TreeNode`): The child of this node. timelimit (`int`): The integer number of *milliseconds* to wait before returning failure. \"\"\" def __init__ ( self , name : str , child : TreeNode , timelimit : int ) -> None : super () . __init__ ( name , child ) self . timelimit = timelimit self . timer_started = False self . start_time = 0 # this is an int in millis. def reset ( self ) -> None : \"\"\" Reset the timer and instruct the child node to reset. \"\"\" self . timer_started = False self . start_time = 0 self . reset_child () def tick ( self ) -> NodeStatus : \"\"\" Tick the child node, but with a time limit. If the time limit is exceeded, return `FAILURE`. \"\"\" if not self . timer_started : self . timer_started = True self . set_status ( NodeStatus . RUNNING ) self . start_time = time . time_ns () child_status = self . child_node . execute_tick () elapsed_ms = ( time . time_ns () - self . start_time ) / 1e6 if elapsed_ms > self . timelimit : return NodeStatus . FAILURE else : return child_status reset () Reset the timer and instruct the child node to reset. Source code in src/dendron/decorators/timeout.py 30 31 32 33 34 35 36 def reset ( self ) -> None : \"\"\" Reset the timer and instruct the child node to reset. \"\"\" self . timer_started = False self . start_time = 0 self . reset_child () tick () Tick the child node, but with a time limit. If the time limit is exceeded, return FAILURE . Source code in src/dendron/decorators/timeout.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def tick ( self ) -> NodeStatus : \"\"\" Tick the child node, but with a time limit. If the time limit is exceeded, return `FAILURE`. \"\"\" if not self . timer_started : self . timer_started = True self . set_status ( NodeStatus . RUNNING ) self . start_time = time . time_ns () child_status = self . child_node . execute_tick () elapsed_ms = ( time . time_ns () - self . start_time ) / 1e6 if elapsed_ms > self . timelimit : return NodeStatus . FAILURE else : return child_status","title":"Timeout"},{"location":"api/decorators/timeout/#timeout","text":"Bases: DecoratorNode The timeout decorator ticks its child and starts a timer. The next time it receives a tick it will check its timer against the time limit. If the elapsed time exceeds the limit, this node returns FAILURE . This is primarily useful for nodes that are executing asynchronously. Parameters: Name Type Description Default name `str` The given name of this node. required child `dendron.tree_node.TreeNode` The child of this node. required timelimit `int` The integer number of milliseconds to wait before returning failure. required Source code in src/dendron/decorators/timeout.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Timeout ( DecoratorNode ): \"\"\" The timeout decorator ticks its child and starts a timer. The next time it receives a tick it will check its timer against the time limit. If the elapsed time exceeds the limit, this node returns `FAILURE`. This is primarily useful for nodes that are executing asynchronously. Args: name (`str`): The given name of this node. child (`dendron.tree_node.TreeNode`): The child of this node. timelimit (`int`): The integer number of *milliseconds* to wait before returning failure. \"\"\" def __init__ ( self , name : str , child : TreeNode , timelimit : int ) -> None : super () . __init__ ( name , child ) self . timelimit = timelimit self . timer_started = False self . start_time = 0 # this is an int in millis. def reset ( self ) -> None : \"\"\" Reset the timer and instruct the child node to reset. \"\"\" self . timer_started = False self . start_time = 0 self . reset_child () def tick ( self ) -> NodeStatus : \"\"\" Tick the child node, but with a time limit. If the time limit is exceeded, return `FAILURE`. \"\"\" if not self . timer_started : self . timer_started = True self . set_status ( NodeStatus . RUNNING ) self . start_time = time . time_ns () child_status = self . child_node . execute_tick () elapsed_ms = ( time . time_ns () - self . start_time ) / 1e6 if elapsed_ms > self . timelimit : return NodeStatus . FAILURE else : return child_status","title":"Timeout"},{"location":"api/decorators/timeout/#dendron.decorators.timeout.Timeout.reset","text":"Reset the timer and instruct the child node to reset. Source code in src/dendron/decorators/timeout.py 30 31 32 33 34 35 36 def reset ( self ) -> None : \"\"\" Reset the timer and instruct the child node to reset. \"\"\" self . timer_started = False self . start_time = 0 self . reset_child ()","title":"reset"},{"location":"api/decorators/timeout/#dendron.decorators.timeout.Timeout.tick","text":"Tick the child node, but with a time limit. If the time limit is exceeded, return FAILURE . Source code in src/dendron/decorators/timeout.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def tick ( self ) -> NodeStatus : \"\"\" Tick the child node, but with a time limit. If the time limit is exceeded, return `FAILURE`. \"\"\" if not self . timer_started : self . timer_started = True self . set_status ( NodeStatus . RUNNING ) self . start_time = time . time_ns () child_status = self . child_node . execute_tick () elapsed_ms = ( time . time_ns () - self . start_time ) / 1e6 if elapsed_ms > self . timelimit : return NodeStatus . FAILURE else : return child_status","title":"tick"}]}